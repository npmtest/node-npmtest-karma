{"/home/travis/build/npmtest/node-npmtest-karma/test.js":"/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/lib.npmtest_karma.js":"/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_karma = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_karma = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-karma && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_karma\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_karma.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_karma.rollup.js'] =\n            local.assetsDict['/assets.npmtest_karma.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_karma.__dirname +\n                    '/lib.npmtest_karma.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/index.js":"// index module\n\nvar constants = require('./constants')\nvar Server = require('./server')\nvar runner = require('./runner')\nvar stopper = require('./stopper')\nvar launcher = require('./launcher')\nvar cfg = require('./config')\n\n// TODO: remove in 1.0\nvar oldServer = {\n  start: function (cliOptions, done) {\n    console.error('WARN `start` method is deprecated since 0.13. It will be removed in 0.14. Please use \\n' +\n      '  server = new Server(config, [done])\\n' +\n      '  server.start()\\n' +\n      'instead.')\n    var server = new Server(cliOptions, done)\n    server.start()\n  }\n}\n\nmodule.exports = {\n  constants: constants,\n  VERSION: constants.VERSION,\n  Server: Server,\n  runner: runner,\n  stopper: stopper,\n  launcher: launcher,\n  config: { parseConfig: cfg.parseConfig }, // lets start with only opening up the `parseConfig` api\n  server: oldServer\n}\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/constants.js":"var fs = require('graceful-fs')\nvar path = require('path')\n\nvar pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '/../package.json')).toString())\n\nexports.VERSION = pkg.version\n\nexports.DEFAULT_PORT = process.env.PORT || 9876\nexports.DEFAULT_HOSTNAME = process.env.IP || 'localhost'\nexports.DEFAULT_LISTEN_ADDR = process.env.LISTEN_ADDR || '0.0.0.0'\n\n// log levels\nexports.LOG_DISABLE = 'OFF'\nexports.LOG_ERROR = 'ERROR'\nexports.LOG_WARN = 'WARN'\nexports.LOG_INFO = 'INFO'\nexports.LOG_DEBUG = 'DEBUG'\nexports.LOG_LOG = 'LOG'\nexports.LOG_PRIORITIES = [\n  exports.LOG_DISABLE,\n  exports.LOG_ERROR,\n  exports.LOG_WARN,\n  exports.LOG_INFO,\n  exports.LOG_DEBUG,\n  exports.LOG_LOG\n]\n\n// Default patterns for the pattern layout.\nexports.COLOR_PATTERN = '%[%d{DATE}:%p [%c]: %]%m'\nexports.NO_COLOR_PATTERN = '%d{DATE}:%p [%c]: %m'\n\n// Default console appender\nexports.CONSOLE_APPENDER = {\n  type: 'console',\n  layout: {\n    type: 'pattern',\n    pattern: exports.COLOR_PATTERN\n  }\n}\n\nexports.EXIT_CODE = '\\x1FEXIT'\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/server.js":"var SocketIO = require('socket.io')\nvar di = require('di')\nvar util = require('util')\nvar Promise = require('bluebird')\nvar spawn = require('child_process').spawn\nvar tmp = require('tmp')\nvar fs = require('fs')\nvar path = require('path')\nvar root = global || window || this\n\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar constant = require('./constants')\nvar watcher = require('./watcher')\nvar plugin = require('./plugin')\n\nvar ws = require('./web-server')\nvar preprocessor = require('./preprocessor')\nvar Launcher = require('./launcher').Launcher\nvar FileList = require('./file-list')\nvar reporter = require('./reporter')\nvar helper = require('./helper')\nvar events = require('./events')\nvar EventEmitter = events.EventEmitter\nvar Executor = require('./executor')\nvar Browser = require('./browser')\nvar BrowserCollection = require('./browser_collection')\nvar EmitterWrapper = require('./emitter_wrapper')\nvar processWrapper = new EmitterWrapper(process)\n\nfunction createSocketIoServer (webServer, executor, config) {\n  var server = new SocketIO(webServer, {\n    // avoid destroying http upgrades from socket.io to get proxied websockets working\n    destroyUpgrade: false,\n    path: config.urlRoot + 'socket.io/',\n    transports: config.transports,\n    forceJSONP: config.forceJSONP\n  })\n\n  // hack to overcome circular dependency\n  executor.socketIoSockets = server.sockets\n\n  return server\n}\n\n// Constructor\nvar Server = function (cliOptions, done) {\n  EventEmitter.call(this)\n\n  logger.setupFromConfig(cliOptions)\n\n  this.log = logger.create()\n\n  this.loadErrors = []\n\n  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)\n\n  var modules = [{\n    helper: ['value', helper],\n    logger: ['value', logger],\n    done: ['value', done || process.exit],\n    emitter: ['value', this],\n    server: ['value', this],\n    launcher: ['type', Launcher],\n    config: ['value', config],\n    preprocess: ['factory', preprocessor.createPreprocessor],\n    fileList: ['type', FileList],\n    webServer: ['factory', ws.create],\n    socketServer: ['factory', createSocketIoServer],\n    executor: ['type', Executor],\n    // TODO(vojta): remove\n    customFileHandlers: ['value', []],\n    // TODO(vojta): remove, once karma-dart does not rely on it\n    customScriptTypes: ['value', []],\n    reporter: ['factory', reporter.createReporters],\n    capturedBrowsers: ['type', BrowserCollection],\n    args: ['value', {}],\n    timer: ['value', {\n      setTimeout: function () {\n        return setTimeout.apply(root, arguments)\n      },\n      clearTimeout: function (timeoutId) {\n        clearTimeout(timeoutId)\n      }\n    }]\n  }]\n\n  this._setUpLoadErrorListener()\n  // Load the plugins\n  modules = modules.concat(plugin.resolve(config.plugins, this))\n\n  this._injector = new di.Injector(modules)\n}\n\n// Inherit from events.EventEmitter\nutil.inherits(Server, EventEmitter)\n\n// Public Methods\n// --------------\n\n// Start the server\nServer.prototype.start = function () {\n  this._injector.invoke(this._start, this)\n}\n\n/**\n * Backward-compatibility with karma-intellij bundled with WebStorm.\n * Deprecated since version 0.13, to be removed in 0.14\n */\nServer.start = function (cliOptions, done) {\n  var server = new Server(cliOptions, done)\n  server.start()\n}\n\n// Get properties from the injector\n//\n// token - String\nServer.prototype.get = function (token) {\n  return this._injector.get(token)\n}\n\n// Force a refresh of the file list\nServer.prototype.refreshFiles = function () {\n  if (!this._fileList) return Promise.resolve()\n\n  return this._fileList.refresh()\n}\n\n// Private Methods\n// ---------------\n\nServer.prototype._start = function (config, launcher, preprocess, fileList,\n                                    capturedBrowsers, executor, done) {\n  var self = this\n  if (config.detached) {\n    this._detach(config, done)\n    return\n  }\n\n  self._fileList = fileList\n\n  config.frameworks.forEach(function (framework) {\n    self._injector.get('framework:' + framework)\n  })\n\n  var webServer = self._injector.get('webServer')\n  var socketServer = self._injector.get('socketServer')\n\n  // A map of launched browsers.\n  var singleRunDoneBrowsers = Object.create(null)\n\n  // Passing fake event emitter, so that it does not emit on the global,\n  // we don't care about these changes.\n  var singleRunBrowsers = new BrowserCollection(new EventEmitter())\n\n  // Some browsers did not get captured.\n  var singleRunBrowserNotCaptured = false\n\n  webServer.on('error', function (e) {\n    if (e.code === 'EADDRINUSE') {\n      self.log.warn('Port %d in use', config.port)\n      config.port++\n      webServer.listen(config.port, config.listenAddress)\n    } else {\n      throw e\n    }\n  })\n\n  var afterPreprocess = function () {\n    if (config.autoWatch) {\n      self._injector.invoke(watcher.watch)\n    }\n\n    webServer.listen(config.port, config.listenAddress, function () {\n      self.log.info('Karma v%s server started at %s//%s:%s%s', constant.VERSION,\n        config.protocol, config.listenAddress, config.port, config.urlRoot)\n\n      self.emit('listening', config.port)\n      if (config.browsers && config.browsers.length) {\n        self._injector.invoke(launcher.launch, launcher).forEach(function (browserLauncher) {\n          singleRunDoneBrowsers[browserLauncher.id] = false\n        })\n      }\n      var noLoadErrors = self.loadErrors.length\n      if (noLoadErrors > 0) {\n        self.log.error('Found %d load error%s', noLoadErrors, noLoadErrors === 1 ? '' : 's')\n        process.exitCode = 1\n        process.kill(process.pid, 'SIGINT')\n      }\n    })\n  }\n\n  fileList.refresh().then(afterPreprocess, afterPreprocess)\n\n  self.on('browsers_change', function () {\n    // TODO(vojta): send only to interested browsers\n    socketServer.sockets.emit('info', capturedBrowsers.serialize())\n  })\n\n  self.on('browser_register', function (browser) {\n    launcher.markCaptured(browser.id)\n\n    // TODO(vojta): This is lame, browser can get captured and then\n    // crash (before other browsers get captured).\n    if (launcher.areAllCaptured()) {\n      self.emit('browsers_ready')\n\n      if (config.autoWatch) {\n        executor.schedule()\n      }\n    }\n  })\n\n  if (config.browserConsoleLogOptions && config.browserConsoleLogOptions.path) {\n    var configLevel = config.browserConsoleLogOptions.level || 'debug'\n    var configFormat = config.browserConsoleLogOptions.format || '%b %T: %m'\n    var configPath = config.browserConsoleLogOptions.path\n    self.log.info('Writing browser console to file: %s', configPath)\n    var browserLogFile = fs.openSync(configPath, 'w+')\n    var levels = ['log', 'error', 'warn', 'info', 'debug']\n    self.on('browser_log', function (browser, message, level) {\n      if (levels.indexOf(level.toLowerCase()) > levels.indexOf(configLevel)) return\n      if (!helper.isString(message)) {\n        message = util.inspect(message, {showHidden: false, colors: false})\n      }\n      var logMap = {'%m': message, '%t': level.toLowerCase(), '%T': level.toUpperCase(), '%b': browser}\n      var logString = configFormat.replace(/%[mtTb]/g, function (m) {\n        return logMap[m]\n      })\n      self.log.debug('Writing browser console line: %s', logString)\n      fs.write(browserLogFile, logString + '\\n')\n    })\n  }\n\n  var EVENTS_TO_REPLY = ['start', 'info', 'karma_error', 'result', 'complete']\n  socketServer.sockets.on('connection', function (socket) {\n    self.log.debug('A browser has connected on socket ' + socket.id)\n\n    var replySocketEvents = events.bufferEvents(socket, EVENTS_TO_REPLY)\n\n    socket.on('complete', function (data, ack) {\n      ack()\n    })\n\n    socket.on('register', function (info) {\n      var newBrowser\n      var isRestart\n\n      if (info.id) {\n        newBrowser = capturedBrowsers.getById(info.id) || singleRunBrowsers.getById(info.id)\n      }\n\n      if (newBrowser) {\n        isRestart = newBrowser.state === Browser.STATE_DISCONNECTED\n        newBrowser.reconnect(socket)\n\n        // We are restarting a previously disconnected browser.\n        if (isRestart && config.singleRun) {\n          newBrowser.execute(config.client)\n        }\n      } else {\n        newBrowser = self._injector.createChild([{\n          id: ['value', info.id || null],\n          fullName: ['value', (helper.isDefined(info.displayName) ? info.displayName : info.name)],\n          socket: ['value', socket]\n        }]).instantiate(Browser)\n\n        newBrowser.init()\n\n        // execute in this browser immediately\n        if (config.singleRun) {\n          newBrowser.execute(config.client)\n          singleRunBrowsers.add(newBrowser)\n        }\n      }\n\n      replySocketEvents()\n    })\n  })\n\n  var emitRunCompleteIfAllBrowsersDone = function () {\n    // all browsers done\n    var isDone = Object.keys(singleRunDoneBrowsers).reduce(function (isDone, id) {\n      return isDone && singleRunDoneBrowsers[id]\n    }, true)\n\n    if (isDone) {\n      var results = singleRunBrowsers.getResults()\n      if (singleRunBrowserNotCaptured) {\n        results.exitCode = 1\n      } else if (results.success + results.failed === 0 && !config.failOnEmptyTestSuite) {\n        results.exitCode = 0\n        self.log.warn('Test suite was empty.')\n      }\n      self.emit('run_complete', singleRunBrowsers, results)\n    }\n  }\n\n  self.on('browser_complete', function (completedBrowser) {\n    if (completedBrowser.lastResult.disconnected &&\n      completedBrowser.disconnectsCount <= config.browserDisconnectTolerance) {\n      self.log.info('Restarting %s (%d of %d attempts)', completedBrowser.name,\n        completedBrowser.disconnectsCount, config.browserDisconnectTolerance)\n\n      if (!launcher.restart(completedBrowser.id)) {\n        self.emit('browser_restart_failure', completedBrowser)\n      }\n    } else {\n      self.emit('browser_complete_with_no_more_retries', completedBrowser)\n    }\n  })\n\n  if (config.singleRun) {\n    self.on('browser_restart_failure', function (completedBrowser) {\n      singleRunDoneBrowsers[completedBrowser.id] = true\n      emitRunCompleteIfAllBrowsersDone()\n    })\n    self.on('browser_complete_with_no_more_retries', function (completedBrowser) {\n      singleRunDoneBrowsers[completedBrowser.id] = true\n\n      if (launcher.kill(completedBrowser.id)) {\n        // workaround to supress \"disconnect\" warning\n        completedBrowser.state = Browser.STATE_DISCONNECTED\n      }\n\n      emitRunCompleteIfAllBrowsersDone()\n    })\n\n    self.on('browser_process_failure', function (browserLauncher) {\n      singleRunDoneBrowsers[browserLauncher.id] = true\n      singleRunBrowserNotCaptured = true\n\n      emitRunCompleteIfAllBrowsersDone()\n    })\n\n    self.on('run_complete', function (browsers, results) {\n      self.log.debug('Run complete, exiting.')\n      disconnectBrowsers(results.exitCode)\n    })\n\n    self.emit('run_start', singleRunBrowsers)\n  }\n\n  if (config.autoWatch) {\n    self.on('file_list_modified', function () {\n      self.log.debug('List of files has changed, trying to execute')\n      if (config.restartOnFileChange) {\n        socketServer.sockets.emit('stop')\n      }\n      executor.schedule()\n    })\n  }\n\n  var webServerCloseTimeout = 3000\n  var disconnectBrowsers = function (code) {\n    // Slightly hacky way of removing disconnect listeners\n    // to suppress \"browser disconnect\" warnings\n    // TODO(vojta): change the client to not send the event (if disconnected by purpose)\n    var sockets = socketServer.sockets.sockets\n\n    Object.keys(sockets).forEach(function (id) {\n      var socket = sockets[id]\n      socket.removeAllListeners('disconnect')\n      if (!socket.disconnected) {\n        // Disconnect asynchronously. Socket.io mutates the `sockets.sockets` array\n        // underneath us so this would skip every other browser/socket.\n        process.nextTick(socket.disconnect.bind(socket))\n      }\n    })\n\n    var removeAllListenersDone = false\n    var removeAllListeners = function () {\n      // make sure we don't execute cleanup twice\n      if (removeAllListenersDone) {\n        return\n      }\n      removeAllListenersDone = true\n      webServer.removeAllListeners()\n      processWrapper.removeAllListeners()\n      done(code || 0)\n    }\n\n    self.emitAsync('exit').then(function () {\n      // don't wait forever on webServer.close() because\n      // pending client connections prevent it from closing.\n      var closeTimeout = setTimeout(removeAllListeners, webServerCloseTimeout)\n\n      // shutdown the server...\n      webServer.close(function () {\n        clearTimeout(closeTimeout)\n        removeAllListeners()\n      })\n    })\n  }\n\n  processWrapper.on('SIGINT', function () {\n    disconnectBrowsers(process.exitCode)\n  })\n  processWrapper.on('SIGTERM', disconnectBrowsers)\n\n  // Handle all unhandled exceptions, so we don't just exit but\n  // disconnect the browsers before exiting.\n  processWrapper.on('uncaughtException', function (error) {\n    self.log.error(error)\n    disconnectBrowsers(1)\n  })\n}\n\nServer.prototype._setUpLoadErrorListener = function () {\n  var self = this\n  self.on('load_error', function (type, name) {\n    self.log.debug('Registered a load error of type %s with name %s', type, name)\n    self.loadErrors.push([type, name])\n  })\n}\n\nServer.prototype._detach = function (config, done) {\n  var log = this.log\n  var tmpFile = tmp.fileSync({keep: true})\n  log.info('Starting karma detached')\n  log.info('Run \"karma stop\" to stop the server.')\n  log.debug('Writing config to tmp-file %s', tmpFile.name)\n  config.detached = false\n  try {\n    fs.writeFileSync(tmpFile.name, JSON.stringify(config), 'utf8')\n  } catch (e) {\n    log.error(\"Couldn't write temporary configuration file\")\n    done(1)\n    return\n  }\n  var child = spawn(process.argv[0], [path.resolve(__dirname, '../lib/detached.js'), tmpFile.name], {\n    detached: true,\n    stdio: 'ignore'\n  })\n  child.unref()\n}\n\n// Export\n// ------\n\nmodule.exports = Server\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/config.js":"var path = require('path')\n\nvar logger = require('./logger')\nvar log = logger.create('config')\nvar helper = require('./helper')\nvar constant = require('./constants')\n\nvar _ = require('lodash')\n\nvar COFFEE_SCRIPT_AVAILABLE = false\nvar LIVE_SCRIPT_AVAILABLE = false\nvar TYPE_SCRIPT_AVAILABLE = false\n\n// Coffee is required here to enable config files written in coffee-script.\n// It's not directly used in this file.\ntry {\n  require('coffee-script').register()\n  COFFEE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\n// LiveScript is required here to enable config files written in LiveScript.\n// It's not directly used in this file.\ntry {\n  require('LiveScript')\n  LIVE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\ntry {\n  require('ts-node').register()\n  TYPE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\nvar Pattern = function (pattern, served, included, watched, nocache) {\n  this.pattern = pattern\n  this.served = helper.isDefined(served) ? served : true\n  this.included = helper.isDefined(included) ? included : true\n  this.watched = helper.isDefined(watched) ? watched : true\n  this.nocache = helper.isDefined(nocache) ? nocache : false\n  this.weight = helper.mmPatternWeight(pattern)\n}\n\nPattern.prototype.compare = function (other) {\n  return helper.mmComparePatternWeights(this.weight, other.weight)\n}\n\nvar UrlPattern = function (url) {\n  Pattern.call(this, url, false, true, false, false)\n}\n\nvar createPatternObject = function (pattern) {\n  if (pattern && helper.isString(pattern)) {\n    return helper.isUrlAbsolute(pattern) ? new UrlPattern(pattern) : new Pattern(pattern)\n  }\n\n  if (helper.isObject(pattern)) {\n    if (pattern.pattern && helper.isString(pattern.pattern)) {\n      return helper.isUrlAbsolute(pattern.pattern)\n        ? new UrlPattern(pattern.pattern)\n        : new Pattern(\n          pattern.pattern,\n          pattern.served,\n          pattern.included,\n          pattern.watched,\n          pattern.nocache)\n    }\n\n    log.warn('Invalid pattern %s!\\n\\tObject is missing \"pattern\" property.', pattern)\n    return new Pattern(null, false, false, false, false)\n  }\n\n  log.warn('Invalid pattern %s!\\n\\tExpected string or object with \"pattern\" property.', pattern)\n  return new Pattern(null, false, false, false, false)\n}\n\nvar normalizeUrl = function (url) {\n  if (url.charAt(0) !== '/') {\n    url = '/' + url\n  }\n\n  if (url.charAt(url.length - 1) !== '/') {\n    url = url + '/'\n  }\n\n  return url\n}\n\nvar normalizeUrlRoot = function (urlRoot) {\n  var normalizedUrlRoot = normalizeUrl(urlRoot)\n\n  if (normalizedUrlRoot !== urlRoot) {\n    log.warn('urlRoot normalized to \"%s\"', normalizedUrlRoot)\n  }\n\n  return normalizedUrlRoot\n}\n\nvar normalizeProxyPath = function (proxyPath) {\n  var normalizedProxyPath = normalizeUrl(proxyPath)\n\n  if (normalizedProxyPath !== proxyPath) {\n    log.warn('proxyPath normalized to \"%s\"', normalizedProxyPath)\n  }\n\n  return normalizedProxyPath\n}\n\nvar normalizeConfig = function (config, configFilePath) {\n  var basePathResolve = function (relativePath) {\n    if (helper.isUrlAbsolute(relativePath)) {\n      return relativePath\n    }\n\n    if (!helper.isDefined(config.basePath) || !helper.isDefined(relativePath)) {\n      return ''\n    }\n    return path.resolve(config.basePath, relativePath)\n  }\n\n  var createPatternMapper = function (resolve) {\n    return function (objectPattern) {\n      objectPattern.pattern = resolve(objectPattern.pattern)\n\n      return objectPattern\n    }\n  }\n\n  if (helper.isString(configFilePath)) {\n    // resolve basePath\n    config.basePath = path.resolve(path.dirname(configFilePath), config.basePath)\n\n    // always ignore the config file itself\n    config.exclude.push(configFilePath)\n  } else {\n    config.basePath = path.resolve(config.basePath || '.')\n  }\n\n  config.files = config.files.map(createPatternObject).map(createPatternMapper(basePathResolve))\n  config.exclude = config.exclude.map(basePathResolve)\n  config.customContextFile = config.customContextFile && basePathResolve(config.customContextFile)\n  config.customDebugFile = config.customDebugFile && basePathResolve(config.customDebugFile)\n  config.customClientContextFile = config.customClientContextFile && basePathResolve(config.customClientContextFile)\n\n  // normalize paths on windows\n  config.basePath = helper.normalizeWinPath(config.basePath)\n  config.files = config.files.map(createPatternMapper(helper.normalizeWinPath))\n  config.exclude = config.exclude.map(helper.normalizeWinPath)\n  config.customContextFile = helper.normalizeWinPath(config.customContextFile)\n  config.customDebugFile = helper.normalizeWinPath(config.customDebugFile)\n  config.customClientContextFile = helper.normalizeWinPath(config.customClientContextFile)\n\n  // normalize urlRoot\n  config.urlRoot = normalizeUrlRoot(config.urlRoot)\n\n  // normalize and default upstream proxy settings if given\n  if (config.upstreamProxy) {\n    var proxy = config.upstreamProxy\n    proxy.path = _.isUndefined(proxy.path) ? '/' : normalizeProxyPath(proxy.path)\n    proxy.hostname = _.isUndefined(proxy.hostname) ? 'localhost' : proxy.hostname\n    proxy.port = _.isUndefined(proxy.port) ? 9875 : proxy.port\n\n    // force protocol to end with ':'\n    proxy.protocol = (proxy.protocol || 'http').split(':')[0] + ':'\n    if (proxy.protocol.match(/https?:/) === null) {\n      log.warn('\"%s\" is not a supported upstream proxy protocol, defaulting to \"http:\"',\n        proxy.protocol)\n      proxy.protocol = 'http:'\n    }\n  }\n\n  // force protocol to end with ':'\n  config.protocol = (config.protocol || 'http').split(':')[0] + ':'\n  if (config.protocol.match(/https?:/) === null) {\n    log.warn('\"%s\" is not a supported protocol, defaulting to \"http:\"',\n      config.protocol)\n    config.protocol = 'http:'\n  }\n\n  if (config.proxies && config.proxies.hasOwnProperty(config.urlRoot)) {\n    log.warn('\"%s\" is proxied, you should probably change urlRoot to avoid conflicts',\n      config.urlRoot)\n  }\n\n  if (config.singleRun && config.autoWatch) {\n    log.debug('autoWatch set to false, because of singleRun')\n    config.autoWatch = false\n  }\n\n  if (config.runInParent) {\n    log.debug('useIframe set to false, because using runInParent')\n    config.useIframe = false\n  }\n\n  if (!config.singleRun && !config.useIframe && config.runInParent) {\n    log.debug('singleRun set to true, because using runInParent')\n    config.singleRun = true\n  }\n\n  if (helper.isString(config.reporters)) {\n    config.reporters = config.reporters.split(',')\n  }\n\n  if (config.client && config.client.args && !Array.isArray(config.client.args)) {\n    throw new Error('Invalid configuration: client.args must be an array of strings')\n  }\n\n  if (config.browsers && Array.isArray(config.browsers) === false) {\n    throw new TypeError('Invalid configuration: browsers option must be an array')\n  }\n\n  if (config.formatError && !helper.isFunction(config.formatError)) {\n    throw new TypeError('Invalid configuration: formatError option must be a function.')\n  }\n\n  if (config.processKillTimeout && !helper.isNumber(config.processKillTimeout)) {\n    throw new TypeError('Invalid configuration: processKillTimeout option must be a number.')\n  }\n\n  var defaultClient = config.defaultClient || {}\n  Object.keys(defaultClient).forEach(function (key) {\n    var option = config.client[key]\n    config.client[key] = helper.isDefined(option) ? option : defaultClient[key]\n  })\n\n  // normalize preprocessors\n  var preprocessors = config.preprocessors || {}\n  var normalizedPreprocessors = config.preprocessors = Object.create(null)\n\n  Object.keys(preprocessors).forEach(function (pattern) {\n    var normalizedPattern = helper.normalizeWinPath(basePathResolve(pattern))\n\n    normalizedPreprocessors[normalizedPattern] = helper.isString(preprocessors[pattern])\n      ? [preprocessors[pattern]] : preprocessors[pattern]\n  })\n\n  // define custom launchers/preprocessors/reporters - create an inlined plugin\n  var module = Object.create(null)\n  var hasSomeInlinedPlugin = false\n  var types = ['launcher', 'preprocessor', 'reporter']\n\n  types.forEach(function (type) {\n    var definitions = config['custom' + helper.ucFirst(type) + 's'] || {}\n\n    Object.keys(definitions).forEach(function (name) {\n      var definition = definitions[name]\n\n      if (!helper.isObject(definition)) {\n        return log.warn('Can not define %s %s. Definition has to be an object.', type, name)\n      }\n\n      if (!helper.isString(definition.base)) {\n        return log.warn('Can not define %s %s. Missing base %s.', type, name, type)\n      }\n\n      var token = type + ':' + definition.base\n      var locals = {\n        args: ['value', definition]\n      }\n\n      module[type + ':' + name] = ['factory', function (injector) {\n        var plugin = injector.createChild([locals], [token]).get(token)\n        if (type === 'launcher' && helper.isDefined(definition.displayName)) {\n          plugin.displayName = definition.displayName\n        }\n        return plugin\n      }]\n      hasSomeInlinedPlugin = true\n    })\n  })\n\n  if (hasSomeInlinedPlugin) {\n    config.plugins.push(module)\n  }\n\n  return config\n}\n\nvar Config = function () {\n  var config = this\n\n  this.LOG_DISABLE = constant.LOG_DISABLE\n  this.LOG_ERROR = constant.LOG_ERROR\n  this.LOG_WARN = constant.LOG_WARN\n  this.LOG_INFO = constant.LOG_INFO\n  this.LOG_DEBUG = constant.LOG_DEBUG\n\n  this.set = function (newConfig) {\n    _.merge(config, newConfig, function (obj, src) {\n      // Overwrite arrays to keep consistent with #283\n      if (_.isArray(src)) {\n        return src\n      }\n    })\n  }\n\n  // DEFAULT CONFIG\n  this.frameworks = []\n  this.protocol = 'http:'\n  this.port = constant.DEFAULT_PORT\n  this.listenAddress = constant.DEFAULT_LISTEN_ADDR\n  this.hostname = constant.DEFAULT_HOSTNAME\n  this.httpsServerConfig = {}\n  this.basePath = ''\n  this.files = []\n  this.browserConsoleLogOptions = {\n    level: 'debug',\n    format: '%b %T: %m',\n    terminal: true\n  }\n  this.customContextFile = null\n  this.customDebugFile = null\n  this.customClientContextFile = null\n  this.exclude = []\n  this.logLevel = constant.LOG_INFO\n  this.colors = true\n  this.autoWatch = true\n  this.autoWatchBatchDelay = 250\n  this.restartOnFileChange = false\n  this.usePolling = process.platform === 'darwin' || process.platform === 'linux'\n  this.reporters = ['progress']\n  this.singleRun = false\n  this.browsers = []\n  this.captureTimeout = 60000\n  this.proxies = {}\n  this.proxyValidateSSL = true\n  this.preprocessors = {}\n  this.urlRoot = '/'\n  this.upstreamProxy = undefined\n  this.reportSlowerThan = 0\n  this.loggers = [constant.CONSOLE_APPENDER]\n  this.transports = ['polling', 'websocket']\n  this.forceJSONP = false\n  this.plugins = ['karma-*']\n  this.defaultClient = this.client = {\n    args: [],\n    useIframe: true,\n    runInParent: false,\n    captureConsole: true,\n    clearContext: true\n  }\n  this.browserDisconnectTimeout = 2000\n  this.browserDisconnectTolerance = 0\n  this.browserNoActivityTimeout = 10000\n  this.processKillTimeout = 2000\n  this.concurrency = Infinity\n  this.failOnEmptyTestSuite = true\n  this.retryLimit = 2\n  this.detached = false\n  this.crossOriginAttribute = true\n}\n\nvar CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\n  '    config.set({\\n' +\n  '      // your config\\n' +\n  '    });\\n' +\n  '  };\\n'\n\nvar parseConfig = function (configFilePath, cliOptions) {\n  var configModule\n  if (configFilePath) {\n    log.debug('Loading config %s', configFilePath)\n\n    try {\n      configModule = require(configFilePath)\n      if (typeof configModule === 'object' && typeof configModule.default !== 'undefined') {\n        configModule = configModule.default\n      }\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(configFilePath) !== -1) {\n        log.error('File %s does not exist!', configFilePath)\n      } else {\n        log.error('Invalid config file!\\n  ' + e.stack)\n\n        var extension = path.extname(configFilePath)\n        if (extension === '.coffee' && !COFFEE_SCRIPT_AVAILABLE) {\n          log.error('You need to install CoffeeScript.\\n' +\n            '  npm install coffee-script --save-dev')\n        } else if (extension === '.ls' && !LIVE_SCRIPT_AVAILABLE) {\n          log.error('You need to install LiveScript.\\n' +\n            '  npm install LiveScript --save-dev')\n        } else if (extension === '.ts' && !TYPE_SCRIPT_AVAILABLE) {\n          log.error('You need to install TypeScript.\\n' +\n            '  npm install typescript ts-node --save-dev')\n        }\n      }\n      return process.exit(1)\n    }\n    if (!helper.isFunction(configModule)) {\n      log.error('Config file must export a function!\\n' + CONFIG_SYNTAX_HELP)\n      return process.exit(1)\n    }\n  } else {\n    log.debug('No config file specified.')\n    // if no config file path is passed, we define a dummy config module.\n    configModule = function () {}\n  }\n\n  var config = new Config()\n\n  // save and reset hostname and listenAddress so we can detect if the user\n  // changed them\n  var defaultHostname = config.hostname\n  config.hostname = null\n  var defaultListenAddress = config.listenAddress\n  config.listenAddress = null\n\n  // add the user's configuration in\n  config.set(cliOptions)\n\n  try {\n    configModule(config)\n  } catch (e) {\n    log.error('Error in config file!\\n', e)\n    return process.exit(1)\n  }\n\n  // merge the config from config file and cliOptions (precedence)\n  config.set(cliOptions)\n\n  // if the user changed listenAddress, but didn't set a hostname, warn them\n  if (config.hostname === null && config.listenAddress !== null) {\n    log.warn('ListenAddress was set to %s but hostname was left as the default: ' +\n      '%s. If your browsers fail to connect, consider changing the hostname option.',\n      config.listenAddress, defaultHostname)\n  }\n  // restore values that weren't overwritten by the user\n  if (config.hostname === null) {\n    config.hostname = defaultHostname\n  }\n  if (config.listenAddress === null) {\n    config.listenAddress = defaultListenAddress\n  }\n\n  // configure the logger as soon as we can\n  logger.setup(config.logLevel, config.colors, config.loggers)\n\n  return normalizeConfig(config, configFilePath)\n}\n\n// PUBLIC API\nexports.parseConfig = parseConfig\nexports.Pattern = Pattern\nexports.createPatternObject = createPatternObject\nexports.Config = Config\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/logger.js":"// This is the **logger** module for *Karma*. It uses\n// [log4js](https://github.com/nomiddlename/log4js-node) to handle and\n// configure all logging that happens inside of *Karma*.\n\n// ### Helpers and Setup\n\nvar log4js = require('log4js')\nvar helper = require('./helper')\nvar constant = require('./constants')\n\n// #### Public Functions\n\n// Setup the logger by passing in the configuration options. It needs\n// three arguments:\n//\n//     setup(logLevel, colors, appenders)\n//\n// * `logLevel`: *String* Defines the global log level.\n// * `colors`: *Boolean* Use colors in the stdout or not.\n// * `appenders`: *Array* This will be passed as appenders to log4js\n//   to allow for fine grained configuration of log4js. For more information\n//   see https://github.com/nomiddlename/log4js-node.\nvar setup = function (level, colors, appenders) {\n  // Turn color on/off on the console appenders with pattern layout\n  var pattern = colors ? constant.COLOR_PATTERN : constant.NO_COLOR_PATTERN\n\n  // If there are no appenders use the default one\n  appenders = helper.isDefined(appenders) ? appenders : [constant.CONSOLE_APPENDER]\n\n  appenders = appenders.map(function (appender) {\n    if (appender.type === 'console') {\n      if (helper.isDefined(appender.layout) && appender.layout.type === 'pattern') {\n        appender.layout.pattern = pattern\n      }\n    }\n    return appender\n  })\n\n  // Pass the values to log4js\n  log4js.setGlobalLogLevel(level)\n  log4js.configure({\n    appenders: appenders\n  })\n}\n\n// Setup the logger by passing in the config object. The function sets the\n// `colors` and `logLevel` if they are defined. It takes two arguments:\n//\n//     setupFromConfig(config, appenders)\n//\n// * `config`: *Object* The configuration object.\n// * `appenders`: *Array* This will be passed as appenders to log4js\n//   to allow for fine grained configuration of log4js. For more information\n//   see https://github.com/nomiddlename/log4js-node.\nvar setupFromConfig = function (config, appenders) {\n  var useColors = true\n  var logLevel = constant.LOG_INFO\n\n  if (helper.isDefined(config.colors)) {\n    useColors = config.colors\n  }\n\n  if (helper.isDefined(config.logLevel)) {\n    logLevel = config.logLevel\n  }\n  setup(logLevel, useColors, appenders)\n}\n\n// Create a new logger. There are two optional arguments\n// * `name`, which defaults to `karma` and\n//   If the `name = 'socket.io'` this will create a special wrapper\n//   to be used as a logger for socket.io.\n// * `level`, which defaults to the global level.\nvar create = function (name, level) {\n  var logger = log4js.getLogger(name || 'karma')\n  if (helper.isDefined(level)) {\n    logger.setLevel(level)\n  }\n  return logger\n}\n\n// #### Publish\n\nexports.create = create\nexports.setup = setup\nexports.setupFromConfig = setupFromConfig\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/helper.js":"var fs = require('graceful-fs')\nvar path = require('path')\nvar _ = require('lodash')\nvar useragent = require('useragent')\nvar Promise = require('bluebird')\nvar mm = require('minimatch')\n\nexports.browserFullNameToShort = function (fullName) {\n  var agent = useragent.parse(fullName)\n  var isKnown = agent.family !== 'Other' && agent.os.family !== 'Other'\n  return isKnown ? agent.toAgent() + ' (' + agent.os + ')' : fullName\n}\n\nexports.isDefined = function (value) {\n  return !_.isUndefined(value)\n}\nvar parser = function (pattern, out) {\n  if (pattern.length === 0) return out\n  var p = /^(\\[[^\\]]*\\]|[*+@?]\\((.+?)\\))/g\n  var matches = p.exec(pattern)\n  if (!matches) {\n    var c = pattern[0]\n    var t = 'word'\n    if (c === '*') {\n      t = 'star'\n    } else if (c === '?') {\n      t = 'optional'\n    }\n    out[t]++\n    return parser(pattern.substring(1), out)\n  }\n  if (matches[2] !== undefined) {\n    out.ext_glob++\n    parser(matches[2], out)\n    return parser(pattern.substring(matches[0].length), out)\n  }\n  out.range++\n  return parser(pattern.substring(matches[0].length), out)\n}\n\nvar gsParser = function (pattern, out) {\n  if (pattern === '**') {\n    out.glob_star++\n    return out\n  }\n  return parser(pattern, out)\n}\n\nvar compareWeightObject = function (w1, w2) {\n  return exports.mmComparePatternWeights(\n    [w1.glob_star, w1.star, w1.ext_glob, w1.range, w1.optional],\n    [w2.glob_star, w2.star, w2.ext_glob, w2.range, w2.optional]\n  )\n}\n\nexports.mmPatternWeight = function (pattern) {\n  var m = new mm.Minimatch(pattern)\n  if (!m.globParts) return [0, 0, 0, 0, 0, 0]\n  var result = m.globParts.reduce(function (prev, p) {\n    var r = p.reduce(function (prev, p) {\n      return gsParser(p, prev)\n    }, {glob_star: 0, ext_glob: 0, word: 0, star: 0, optional: 0, range: 0})\n    if (prev === undefined) return r\n    return compareWeightObject(r, prev) > 0 ? r : prev\n  }, undefined)\n  result.glob_sets = m.set.length\n  return [result.glob_sets, result.glob_star, result.star, result.ext_glob, result.range, result.optional]\n}\n\nexports.mmComparePatternWeights = function (weight1, weight2) {\n  var n1, n2, diff\n  n1 = weight1[0]\n  n2 = weight2[0]\n  diff = n1 - n2\n  if (diff !== 0) return diff / Math.abs(diff)\n  return weight1.length > 1 ? exports.mmComparePatternWeights(weight1.slice(1), weight2.slice(1)) : 0\n}\n\nexports.isFunction = _.isFunction\nexports.isString = _.isString\nexports.isObject = _.isObject\nexports.isArray = _.isArray\nexports.isNumber = _.isNumber\n\nvar ABS_URL = /^https?:\\/\\//\nexports.isUrlAbsolute = function (url) {\n  return ABS_URL.test(url)\n}\n\nexports.camelToSnake = function (camelCase) {\n  return camelCase.replace(/[A-Z]/g, function (match, pos) {\n    return (pos > 0 ? '_' : '') + match.toLowerCase()\n  })\n}\n\nexports.ucFirst = function (word) {\n  return word.charAt(0).toUpperCase() + word.substr(1)\n}\n\nexports.dashToCamel = function (dash) {\n  var words = dash.split('-')\n  return words.shift() + words.map(exports.ucFirst).join('')\n}\n\nexports.arrayRemove = function (collection, item) {\n  var idx = collection.indexOf(item)\n\n  if (idx !== -1) {\n    collection.splice(idx, 1)\n    return true\n  }\n\n  return false\n}\n\nexports.merge = function () {\n  var args = Array.prototype.slice.call(arguments, 0)\n  args.unshift({})\n  return _.merge.apply({}, args)\n}\n\nexports.formatTimeInterval = function (time) {\n  var mins = Math.floor(time / 60000)\n  var secs = (time - mins * 60000) / 1000\n  var str = secs + (secs === 1 ? ' sec' : ' secs')\n\n  if (mins) {\n    str = mins + (mins === 1 ? ' min ' : ' mins ') + str\n  }\n\n  return str\n}\n\nvar replaceWinPath = function (path) {\n  return _.isString(path) ? path.replace(/\\\\/g, '/') : path\n}\n\nexports.normalizeWinPath = process.platform === 'win32' ? replaceWinPath : _.identity\n\nexports.mkdirIfNotExists = function mkdir (directory, done) {\n  // TODO(vojta): handle if it's a file\n  /* eslint-disable handle-callback-err */\n  fs.stat(directory, function (err, stat) {\n    if (stat && stat.isDirectory()) {\n      done()\n    } else {\n      mkdir(path.dirname(directory), function () {\n        fs.mkdir(directory, done)\n      })\n    }\n  })\n  /* eslint-enable handle-callback-err */\n}\n\nexports.defer = function () {\n  var resolve\n  var reject\n  var promise = new Promise(function () {\n    resolve = arguments[0]\n    reject = arguments[1]\n  })\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  }\n}\n\n// export lodash\nObject.defineProperty(exports, '_', {\n  get: function () {\n    console.log('DEPRECATED: use your own version of lodash, this will go away in karma@2.0')\n    return _\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/watcher.js":"var chokidar = require('chokidar')\nvar mm = require('minimatch')\nvar expandBraces = require('expand-braces')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('watcher')\n\nvar DIR_SEP = require('path').sep\n\n// Get parent folder, that be watched (does not contain any special globbing character)\nvar baseDirFromPattern = function (pattern) {\n  return pattern\n    .replace(/[/\\\\][^/\\\\]*\\*.*$/, '')              // remove parts with *\n    .replace(/[/\\\\][^/\\\\]*[!+]\\(.*$/, '')         // remove parts with !(...) and +(...)\n    .replace(/[/\\\\][^/\\\\]*\\)\\?.*$/, '') || DIR_SEP // remove parts with (...)?\n}\n\nvar watchPatterns = function (patterns, watcher) {\n  // filter only unique non url patterns paths\n  var pathsToWatch = []\n  var uniqueMap = {}\n  var path\n\n  // expand ['a/{b,c}'] to ['a/b', 'a/c']\n  patterns = expandBraces(patterns)\n\n  patterns.forEach(function (pattern) {\n    path = baseDirFromPattern(pattern)\n    if (!uniqueMap[path]) {\n      uniqueMap[path] = true\n      pathsToWatch.push(path)\n    }\n  })\n\n  // watch only common parents, no sub paths\n  pathsToWatch.forEach(function (path) {\n    if (!pathsToWatch.some(function (p) {\n      return p !== path && path.substr(0, p.length + 1) === p + DIR_SEP\n    })) {\n      watcher.add(path)\n      log.debug('Watching \"%s\"', path)\n    }\n  })\n}\n\n// Function to test if a path should be ignored by chokidar.\nvar createIgnore = function (patterns, excludes) {\n  return function (path, stat) {\n    if (!stat || stat.isDirectory()) {\n      return false\n    }\n\n    // Check if the path matches any of the watched patterns.\n    if (!patterns.some(function (pattern) {\n      return mm(path, pattern, {dot: true})\n    })) {\n      return true\n    }\n\n    // Check if the path matches any of the exclude patterns.\n    if (excludes.some(function (pattern) {\n      return mm(path, pattern, {dot: true})\n    })) {\n      return true\n    }\n\n    return false\n  }\n}\n\nvar onlyWatchedTrue = function (pattern) {\n  return pattern.watched\n}\n\nvar getWatchedPatterns = function (patternObjects) {\n  return patternObjects.filter(onlyWatchedTrue).map(function (patternObject) {\n    return patternObject.pattern\n  })\n}\n\nexports.watch = function (patterns, excludes, fileList, usePolling, emitter) {\n  var watchedPatterns = getWatchedPatterns(patterns)\n  var options = {\n    usePolling: usePolling,\n    ignorePermissionErrors: true,\n    ignoreInitial: true,\n    ignored: createIgnore(watchedPatterns, excludes)\n  }\n  var chokidarWatcher = new chokidar.FSWatcher(options)\n\n  watchPatterns(watchedPatterns, chokidarWatcher)\n\n  var bind = function (fn) {\n    return function (path) {\n      return fn.call(fileList, helper.normalizeWinPath(path))\n    }\n  }\n\n  // register events\n  chokidarWatcher.on('add', bind(fileList.addFile))\n    .on('change', bind(fileList.changeFile))\n    .on('unlink', bind(fileList.removeFile))\n    // If we don't subscribe; unhandled errors from Chokidar will bring Karma down\n    // (see GH Issue #959)\n    .on('error', function (e) {\n      log.debug(e)\n    })\n\n  emitter.on('exit', function (done) {\n    chokidarWatcher.close()\n    done()\n  })\n\n  return chokidarWatcher\n}\n\nexports.watch.$inject = ['config.files', 'config.exclude', 'fileList', 'config.usePolling',\n  'emitter']\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/plugin.js":"var fs = require('graceful-fs')\nvar path = require('path')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('plugin')\n\nvar IGNORED_PACKAGES = ['karma-cli', 'karma-runner.github.com']\n\nexports.resolve = function (plugins, emitter) {\n  var modules = []\n\n  var requirePlugin = function (name) {\n    log.debug('Loading plugin %s.', name)\n    try {\n      modules.push(require(name))\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\n        log.error('Cannot find plugin \"%s\".\\n  Did you forget to install it?\\n' +\n          '  npm install %s --save-dev', name, name)\n      } else {\n        log.error('Error during loading \"%s\" plugin:\\n  %s', name, e.message)\n      }\n      emitter.emit('load_error', 'plug_in', name)\n    }\n  }\n\n  plugins.forEach(function (plugin) {\n    if (helper.isString(plugin)) {\n      if (plugin.indexOf('*') === -1) {\n        requirePlugin(plugin)\n        return\n      }\n      var pluginDirectory = path.normalize(path.join(__dirname, '/../..'))\n      var regexp = new RegExp('^' + plugin.replace('*', '.*'))\n\n      log.debug('Loading %s from %s', plugin, pluginDirectory)\n      fs.readdirSync(pluginDirectory).filter(function (pluginName) {\n        return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName)\n      }).forEach(function (pluginName) {\n        requirePlugin(pluginDirectory + '/' + pluginName)\n      })\n      return\n    }\n    if (helper.isObject(plugin)) {\n      log.debug('Loading inlined plugin (defining %s).', Object.keys(plugin).join(', '))\n      modules.push(plugin)\n      return\n    }\n    log.error('Invalid plugin %s', plugin)\n    emitter.emit('load_error', 'plug_in', plugin)\n  })\n\n  return modules\n}\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/web-server.js":"var fs = require('graceful-fs')\nvar http = require('http')\nvar https = require('https')\nvar path = require('path')\nvar connect = require('connect')\nvar Promise = require('bluebird')\n\nvar common = require('./middleware/common')\nvar runnerMiddleware = require('./middleware/runner')\nvar stopperMiddleware = require('./middleware/stopper')\nvar stripHostMiddleware = require('./middleware/strip_host')\nvar karmaMiddleware = require('./middleware/karma')\nvar sourceFilesMiddleware = require('./middleware/source_files')\nvar proxyMiddleware = require('./middleware/proxy')\n\nvar log = require('./logger').create('web-server')\n\nvar createCustomHandler = function (customFileHandlers, /* config.basePath */ basePath) {\n  return function (request, response, next) {\n    for (var i = 0; i < customFileHandlers.length; i++) {\n      if (customFileHandlers[i].urlRegex.test(request.url)) {\n        return customFileHandlers[i].handler(request, response, 'fake/static', 'fake/adapter',\n          basePath, 'fake/root')\n      }\n    }\n\n    return next()\n  }\n}\n\ncreateCustomHandler.$inject = ['customFileHandlers', 'config.basePath']\n\nvar createWebServer = function (injector, emitter, fileList) {\n  var config = injector.get('config')\n  common.initializeMimeTypes(config)\n  var serveStaticFile = common.createServeFile(fs, path.normalize(path.join(__dirname, '/../static')), config)\n  var serveFile = common.createServeFile(fs, null, config)\n  var filesPromise = new common.PromiseContainer()\n\n  // Set an empty list of files to avoid race issues with\n  // file_list_modified not having been emitted yet\n  filesPromise.set(Promise.resolve(fileList.files))\n\n  emitter.on('file_list_modified', function (files) {\n    filesPromise.set(Promise.resolve(files))\n  })\n\n  // locals for webserver module\n  // NOTE(vojta): figure out how to do this with DI\n  injector = injector.createChild([{\n    serveFile: ['value', serveFile],\n    serveStaticFile: ['value', serveStaticFile],\n    filesPromise: ['value', filesPromise]\n  }])\n\n  var proxyMiddlewareInstance = injector.invoke(proxyMiddleware.create)\n\n  log.debug('Instantiating middleware')\n  var handler = connect()\n\n  if (config.beforeMiddleware) {\n    config.beforeMiddleware.forEach(function (middleware) {\n      handler.use(injector.get('middleware:' + middleware))\n    })\n  }\n\n  handler.use(injector.invoke(runnerMiddleware.create))\n  handler.use(injector.invoke(stopperMiddleware.create))\n  handler.use(injector.invoke(stripHostMiddleware.create))\n  handler.use(injector.invoke(karmaMiddleware.create))\n  handler.use(injector.invoke(sourceFilesMiddleware.create))\n  // TODO(vojta): extract the proxy into a plugin\n  handler.use(proxyMiddlewareInstance)\n  // TODO(vojta): remove, this is only here because of karma-dart\n  // we need a better way of custom handlers\n  handler.use(injector.invoke(createCustomHandler))\n\n  if (config.middleware) {\n    config.middleware.forEach(function (middleware) {\n      handler.use(injector.get('middleware:' + middleware))\n    })\n  }\n\n  handler.use(function (request, response) {\n    common.serve404(response, request.url)\n  })\n\n  var serverClass = http\n  var serverArguments = [handler]\n\n  if (config.protocol === 'https:') {\n    serverClass = https\n    serverArguments.unshift(config.httpsServerOptions || {})\n  }\n\n  if (config.httpModule) {\n    serverClass = config.httpModule\n  }\n\n  var server = serverClass.createServer.apply(null, serverArguments)\n\n  server.on('upgrade', function (req, socket, head) {\n    log.debug('upgrade %s', req.url)\n    proxyMiddlewareInstance.upgrade(req, socket, head)\n  })\n\n  return server\n}\n\n// PUBLIC API\nexports.create = createWebServer\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/common.js":"/**\n * This module contains some common helpers shared between middlewares\n */\n\nvar mime = require('mime')\nvar _ = require('lodash')\nvar parseRange = require('range-parser')\nvar Buffer = require('safe-buffer').Buffer\n\nvar log = require('../logger').create('web-server')\n\nvar PromiseContainer = function () {\n  var promise\n\n  this.then = function (success, error) {\n    error = error || _.noop\n    return promise.then(success).catch(error)\n  }\n\n  this.set = function (newPromise) {\n    promise = newPromise\n  }\n}\n\nvar serve404 = function (response, path) {\n  log.warn('404: ' + path)\n  response.writeHead(404)\n  return response.end('NOT FOUND')\n}\n\nvar createServeFile = function (fs, directory, config) {\n  var cache = Object.create(null)\n\n  return function (filepath, rangeHeader, response, transform, content, doNotCache) {\n    var responseData\n\n    var convertForRangeRequest = function () {\n      var range = parseRange(responseData.length, rangeHeader)\n      if (range === -2) {\n        // malformed header string\n        return 200\n      } else if (range === -1) {\n        // unsatisfiable range\n        responseData = Buffer.alloc(0)\n        return 416\n      } else if (range.type === 'bytes') {\n        responseData = Buffer.from(responseData)\n        if (range.length === 1) {\n          var start = range[0].start\n          var end = range[0].end\n          response.setHeader(\n            'Content-Range',\n            'bytes ' + start + '-' + end + '/' + responseData.length\n          )\n          response.setHeader('Accept-Ranges', 'bytes')\n          response.setHeader('Content-Length', end - start + 1)\n          responseData = responseData.slice(start, end + 1)\n          return 206\n        } else {\n          // Multiple ranges are not supported. Maybe future?\n          responseData = new Buffer(0)\n          return 416\n        }\n      }\n      // All other states, ignore\n      return 200\n    }\n\n    if (directory) {\n      filepath = directory + filepath\n    }\n\n    if (!content && cache[filepath]) {\n      content = cache[filepath]\n    }\n\n    if (config && config.customHeaders && config.customHeaders.length > 0) {\n      config.customHeaders.forEach(function (header) {\n        var regex = new RegExp(header.match)\n        if (regex.test(filepath)) {\n          log.debug('setting header: ' + header.name + ' for: ' + filepath)\n          response.setHeader(header.name, header.value)\n        }\n      })\n    }\n\n    // serve from cache\n    if (content && !doNotCache) {\n      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))\n\n      // call custom transform fn to transform the data\n      responseData = (transform && transform(content)) || content\n\n      if (rangeHeader) {\n        var code = convertForRangeRequest()\n        response.writeHead(code)\n      } else {\n        response.writeHead(200)\n      }\n\n      log.debug('serving (cached): ' + filepath)\n      return response.end(responseData)\n    }\n\n    return fs.readFile(filepath, function (error, data) {\n      if (error) {\n        return serve404(response, filepath)\n      }\n\n      if (!doNotCache) {\n        cache[filepath] = data.toString()\n      }\n\n      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))\n\n      // call custom transform fn to transform the data\n      responseData = (transform && transform(data.toString())) || data\n\n      if (rangeHeader) {\n        var code = convertForRangeRequest()\n        response.writeHead(code)\n      } else {\n        response.writeHead(200)\n      }\n\n      log.debug('serving: ' + filepath)\n      return response.end(responseData)\n    })\n  }\n}\n\nvar setNoCacheHeaders = function (response) {\n  response.setHeader('Cache-Control', 'no-cache')\n  response.setHeader('Pragma', 'no-cache')\n  response.setHeader('Expires', (new Date(0)).toUTCString())\n}\n\nvar setHeavyCacheHeaders = function (response) {\n  response.setHeader('Cache-Control', 'public, max-age=31536000')\n}\n\nvar initializeMimeTypes = function (config) {\n  if (config && config.mime) {\n    _.forEach(config.mime, function (value, key) {\n      var map = {}\n      map[key] = value\n      mime.define(map)\n    })\n  }\n}\n\n// PUBLIC API\nexports.PromiseContainer = PromiseContainer\nexports.createServeFile = createServeFile\nexports.setNoCacheHeaders = setNoCacheHeaders\nexports.setHeavyCacheHeaders = setHeavyCacheHeaders\nexports.initializeMimeTypes = initializeMimeTypes\nexports.serve404 = serve404\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/runner.js":"/**\n * Runner middleware is responsible for communication with `karma run`.\n *\n * It basically triggers a test run and streams stdout back.\n */\n\nvar _ = require('lodash')\nvar path = require('path')\nvar helper = require('../helper')\nvar log = require('../logger').create()\nvar constant = require('../constants')\nvar json = require('body-parser').json()\n\n// TODO(vojta): disable when single-run mode\nvar createRunnerMiddleware = function (emitter, fileList, capturedBrowsers, reporter, executor,\n  /* config.protocol */ protocol, /* config.hostname */ hostname, /* config.port */\n  port, /* config.urlRoot */ urlRoot, config) {\n  return function (request, response, next) {\n    if (request.url !== '/__run__' && request.url !== urlRoot + 'run') {\n      return next()\n    }\n\n    log.debug('Execution (fired by runner)')\n    response.writeHead(200)\n\n    if (!capturedBrowsers.length) {\n      var url = protocol + '//' + hostname + ':' + port + urlRoot\n\n      return response.end('No captured browser, open ' + url + '\\n')\n    }\n\n    json(request, response, function () {\n      if (!capturedBrowsers.areAllReady([])) {\n        response.write('Waiting for previous execution...\\n')\n      }\n\n      var data = request.body\n      emitter.once('run_start', function () {\n        var responseWrite = response.write.bind(response)\n        responseWrite.colors = data.colors\n        reporter.addAdapter(responseWrite)\n\n        // clean up, close runner response\n        emitter.once('run_complete', function (browsers, results) {\n          reporter.removeAdapter(responseWrite)\n          var emptyTestSuite = (results.failed + results.success) === 0 ? 0 : 1\n          response.end(constant.EXIT_CODE + emptyTestSuite + results.exitCode)\n        })\n      })\n\n      if (_.isEmpty(data.args)) {\n        log.debug('Ignoring empty client.args from run command')\n      } else if ((_.isArray(data.args) && _.isArray(config.client.args)) ||\n        (_.isPlainObject(data.args) && _.isPlainObject(config.client.args))) {\n        log.debug('Merging client.args with ', data.args)\n        config.client.args = _.merge(config.client.args, data.args)\n      } else {\n        log.warn('Replacing client.args with ', data.args, ' as their types do not match.')\n        config.client.args = data.args\n      }\n\n      var fullRefresh = true\n\n      if (helper.isArray(data.changedFiles)) {\n        data.changedFiles.forEach(function (filepath) {\n          fileList.changeFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (helper.isArray(data.addedFiles)) {\n        data.addedFiles.forEach(function (filepath) {\n          fileList.addFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (helper.isArray(data.removedFiles)) {\n        data.removedFiles.forEach(function (filepath) {\n          fileList.removeFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (fullRefresh && data.refresh !== false) {\n        log.debug('Refreshing all the files / patterns')\n        fileList.refresh().then(function () {\n          // Wait for the file list refresh to complete before starting test run,\n          // otherwise the context.html generation might not see new/updated files.\n          if (!config.autoWatch) {\n            executor.schedule()\n          }\n        })\n      } else {\n        executor.schedule()\n      }\n    })\n  }\n}\n\ncreateRunnerMiddleware.$inject = ['emitter', 'fileList', 'capturedBrowsers', 'reporter', 'executor',\n  'config.protocol', 'config.hostname', 'config.port', 'config.urlRoot', 'config']\n\n// PUBLIC API\nexports.create = createRunnerMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/stopper.js":"/**\n * Stopper middleware is responsible for communicating with `karma stop`.\n */\n\nvar log = require('../logger').create('middleware:stopper')\n\nvar createStopperMiddleware = function (urlRoot) {\n  return function (request, response, next) {\n    if (request.url !== urlRoot + 'stop') return next()\n    response.writeHead(200)\n    log.info('Stopping server')\n    response.end('OK')\n    process.kill(process.pid, 'SIGINT')\n  }\n}\n\ncreateStopperMiddleware.$inject = ['config.urlRoot']\nexports.create = createStopperMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/strip_host.js":"/**\n * Strip host middleware is responsible for stripping hostname from request path\n * This to handle requests that uses (normally over proxies) an absoluteURI as request path\n */\n\nvar createStripHostMiddleware = function () {\n  return function (request, response, next) {\n    function stripHostFromUrl (url) {\n      return url.replace(/^http[s]?:\\/\\/([a-z\\-.:\\d]+)\\//, '/')\n    }\n\n    request.normalizedUrl = stripHostFromUrl(request.url) || request.url\n    next()\n  }\n}\n\n// PUBLIC API\nexports.create = createStripHostMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/karma.js":"/**\n * Karma middleware is responsible for serving:\n * - client.html (the entrypoint for capturing a browser)\n * - debug.html\n * - context.html (the execution context, loaded within an iframe)\n * - karma.js\n *\n * The main part is generating context.html, as it contains:\n * - generating mappings\n * - including <script> and <link> tags\n * - setting propert caching headers\n */\n\nvar path = require('path')\nvar util = require('util')\nvar url = require('url')\nvar useragent = require('useragent')\n\nvar log = require('../logger').create('middleware:karma')\n\nvar urlparse = function (urlStr) {\n  var urlObj = url.parse(urlStr, true)\n  urlObj.query = urlObj.query || {}\n  return urlObj\n}\n\nvar common = require('./common')\n\nvar VERSION = require('../constants').VERSION\nvar SCRIPT_TAG = '<script type=\"%s\" src=\"%s\" %s></script>'\nvar CROSSORIGIN_ATTRIBUTE = 'crossorigin=\"anonymous\"'\nvar LINK_TAG_CSS = '<link type=\"text/css\" href=\"%s\" rel=\"stylesheet\">'\nvar LINK_TAG_HTML = '<link href=\"%s\" rel=\"import\">'\nvar SCRIPT_TYPE = {\n  '.js': 'text/javascript',\n  '.dart': 'application/dart'\n}\n\nvar filePathToUrlPath = function (filePath, basePath, urlRoot, proxyPath) {\n  if (filePath.indexOf(basePath) === 0) {\n    return proxyPath + urlRoot.substr(1) + 'base' + filePath.substr(basePath.length)\n  }\n\n  return proxyPath + urlRoot.substr(1) + 'absolute' + filePath\n}\n\nvar getXUACompatibleMetaElement = function (url) {\n  var tag = ''\n  var urlObj = urlparse(url)\n  if (urlObj.query['x-ua-compatible']) {\n    tag = '\\n<meta http-equiv=\"X-UA-Compatible\" content=\"' +\n      urlObj.query['x-ua-compatible'] + '\"/>'\n  }\n  return tag\n}\n\nvar getXUACompatibleUrl = function (url) {\n  var value = ''\n  var urlObj = urlparse(url)\n  if (urlObj.query['x-ua-compatible']) {\n    value = '?x-ua-compatible=' + encodeURIComponent(urlObj.query['x-ua-compatible'])\n  }\n  return value\n}\n\nvar isFirefox = function (req) {\n  if (!(req && req.headers)) {\n    return false\n  }\n\n  // Browser check\n  var firefox = useragent.is(req.headers['user-agent']).firefox\n\n  return firefox\n}\n\nvar createKarmaMiddleware = function (\n  filesPromise,\n  serveStaticFile,\n  serveFile,\n  injector,\n  basePath,\n  urlRoot,\n  upstreamProxy\n) {\n  var proxyPath = upstreamProxy ? upstreamProxy.path : '/'\n  return function (request, response, next) {\n    // These config values should be up to date on every request\n    var client = injector.get('config.client')\n    var customContextFile = injector.get('config.customContextFile')\n    var customDebugFile = injector.get('config.customDebugFile')\n    var customClientContextFile = injector.get('config.customClientContextFile')\n    var jsVersion = injector.get('config.jsVersion')\n    var includeCrossOriginAttribute = injector.get('config.crossOriginAttribute')\n\n    var requestUrl = request.normalizedUrl.replace(/\\?.*/, '')\n    var requestedRangeHeader = request.headers['range']\n\n    // redirect /__karma__ to /__karma__ (trailing slash)\n    if (requestUrl === urlRoot.substr(0, urlRoot.length - 1)) {\n      response.setHeader('Location', proxyPath + urlRoot.substr(1))\n      response.writeHead(301)\n      return response.end('MOVED PERMANENTLY')\n    }\n\n    // ignore urls outside urlRoot\n    if (requestUrl.indexOf(urlRoot) !== 0) {\n      return next()\n    }\n\n    // remove urlRoot prefix\n    requestUrl = requestUrl.substr(urlRoot.length - 1)\n\n    // serve client.html\n    if (requestUrl === '/') {\n      // redirect client_with_context.html\n      if (!client.useIframe && client.runInParent) {\n        requestUrl = '/client_with_context.html'\n      } else { // serve client.html\n        return serveStaticFile('/client.html', requestedRangeHeader, response, function (data) {\n          return data\n            .replace('\\n%X_UA_COMPATIBLE%', getXUACompatibleMetaElement(request.url))\n            .replace('%X_UA_COMPATIBLE_URL%', getXUACompatibleUrl(request.url))\n        })\n      }\n    }\n\n    // serve karma.js, context.js, and debug.js\n    var jsFiles = ['/karma.js', '/context.js', '/debug.js']\n    var isRequestingJsFile = jsFiles.indexOf(requestUrl) !== -1\n    if (isRequestingJsFile) {\n      return serveStaticFile(requestUrl, requestedRangeHeader, response, function (data) {\n        return data.replace('%KARMA_URL_ROOT%', urlRoot)\n          .replace('%KARMA_VERSION%', VERSION)\n          .replace('%KARMA_PROXY_PATH%', proxyPath)\n      })\n    }\n\n    // serve the favicon\n    if (requestUrl === '/favicon.ico') {\n      return serveStaticFile(requestUrl, requestedRangeHeader, response)\n    }\n\n    // serve context.html - execution context within the iframe\n    // or debug.html - execution context without channel to the server\n    var isRequestingContextFile = requestUrl === '/context.html'\n    var isRequestingDebugFile = requestUrl === '/debug.html'\n    var isRequestingClientContextFile = requestUrl === '/client_with_context.html'\n    if (isRequestingContextFile || isRequestingDebugFile || isRequestingClientContextFile) {\n      return filesPromise.then(function (files) {\n        var fileServer\n        var requestedFileUrl\n        log.debug('custom files', customContextFile, customDebugFile, customClientContextFile)\n        if (isRequestingContextFile && customContextFile) {\n          log.debug('Serving customContextFile %s', customContextFile)\n          fileServer = serveFile\n          requestedFileUrl = customContextFile\n        } else if (isRequestingDebugFile && customDebugFile) {\n          log.debug('Serving customDebugFile %s', customDebugFile)\n          fileServer = serveFile\n          requestedFileUrl = customDebugFile\n        } else if (isRequestingClientContextFile && customClientContextFile) {\n          log.debug('Serving customClientContextFile %s', customClientContextFile)\n          fileServer = serveFile\n          requestedFileUrl = customClientContextFile\n        } else {\n          log.debug('Serving static request %s', requestUrl)\n          fileServer = serveStaticFile\n          requestedFileUrl = requestUrl\n        }\n\n        fileServer(requestedFileUrl, requestedRangeHeader, response, function (data) {\n          common.setNoCacheHeaders(response)\n\n          var scriptTags = []\n          var scriptUrls = []\n          for (var i in files.included) {\n            var file = files.included[i]\n            var filePath = file.path\n            var fileExt = path.extname(filePath)\n\n            if (!files.included.hasOwnProperty(i)) {\n              continue\n            }\n\n            if (!file.isUrl) {\n              filePath = filePathToUrlPath(filePath, basePath, urlRoot, proxyPath)\n\n              if (requestUrl === '/context.html') {\n                filePath += '?' + file.sha\n              }\n            }\n\n            scriptUrls.push(filePath)\n\n            if (fileExt === '.css') {\n              scriptTags.push(util.format(LINK_TAG_CSS, filePath))\n              continue\n            }\n\n            if (fileExt === '.html') {\n              scriptTags.push(util.format(LINK_TAG_HTML, filePath))\n              continue\n            }\n\n            // The script tag to be placed\n            var scriptType = (SCRIPT_TYPE[fileExt] || 'text/javascript')\n\n            // In case there is a JavaScript version specified and this is a Firefox browser\n            if (jsVersion && jsVersion > 0 && isFirefox(request)) {\n              scriptType += ';version=' + jsVersion\n            }\n\n            var crossOriginAttribute = includeCrossOriginAttribute ? CROSSORIGIN_ATTRIBUTE : ''\n            scriptTags.push(util.format(SCRIPT_TAG, scriptType, filePath, crossOriginAttribute))\n          }\n\n          // TODO(vojta): don't compute if it's not in the template\n          var mappings = files.served.map(function (file) {\n            // Windows paths contain backslashes and generate bad IDs if not escaped\n            var filePath = filePathToUrlPath(file.path, basePath, urlRoot, proxyPath).replace(/\\\\/g, '\\\\\\\\')\n            // Escape single quotes that might be in the filename -\n            // double quotes should not be allowed!\n            filePath = filePath.replace(/'/g, '\\\\\\'')\n\n            return util.format(\"  '%s': '%s'\", filePath, file.sha)\n          })\n\n          var clientConfig = 'window.__karma__.config = ' + JSON.stringify(client) + ';\\n'\n\n          var scriptUrlsJS = 'window.__karma__.scriptUrls = ' + JSON.stringify(scriptUrls) + ';\\n'\n\n          mappings = 'window.__karma__.files = {\\n' + mappings.join(',\\n') + '\\n};\\n'\n\n          return data\n            .replace('%SCRIPTS%', scriptTags.join('\\n'))\n            .replace('%CLIENT_CONFIG%', clientConfig)\n            .replace('%SCRIPT_URL_ARRAY%', scriptUrlsJS)\n            .replace('%MAPPINGS%', mappings)\n            .replace('\\n%X_UA_COMPATIBLE%', getXUACompatibleMetaElement(request.url))\n        })\n      }, function (errorFiles) {\n        serveStaticFile(requestUrl, response, function (data) {\n          common.setNoCacheHeaders(response)\n          return data.replace('%SCRIPTS%', '').replace('%CLIENT_CONFIG%', '').replace('%MAPPINGS%',\n            'window.__karma__.error(\"TEST RUN WAS CANCELLED because ' +\n            (errorFiles.length > 1 ? 'these files contain' : 'this file contains') +\n            ' some errors:\\\\n  ' + errorFiles.join('\\\\n  ') + '\");')\n        })\n      })\n    } else if (requestUrl === '/context.json') {\n      return filesPromise.then(function (files) {\n        common.setNoCacheHeaders(response)\n        response.writeHead(200)\n        response.end(JSON.stringify({\n          files: files.included.map(function (file) {\n            return filePathToUrlPath(file.path + '?' + file.sha, basePath, urlRoot, proxyPath)\n          })\n        }))\n      })\n    }\n\n    return next()\n  }\n}\n\ncreateKarmaMiddleware.$inject = [\n  'filesPromise',\n  'serveStaticFile',\n  'serveFile',\n  'injector',\n  'config.basePath',\n  'config.urlRoot',\n  'config.upstreamProxy'\n]\n\n// PUBLIC API\nexports.create = createKarmaMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/source_files.js":"var from = require('core-js/library/fn/array/from')\nvar querystring = require('querystring')\nvar _ = require('lodash')\n\nvar common = require('./common')\nvar logger = require('../logger')\nvar log = logger.create('middleware:source-files')\n\n// Files is a Set\nvar findByPath = function (files, path) {\n  return _.find(from(files), function (file) {\n    return file.path === path\n  })\n}\n\nvar composeUrl = function (url, basePath, urlRoot, mustEscape) {\n  return (mustEscape ? querystring.unescape(url) : url)\n            .replace(urlRoot, '/')\n            .replace(/\\?.*$/, '')\n            .replace(/^\\/absolute/, '')\n            .replace(/^\\/base/, basePath)\n}\n\n// Source Files middleware is responsible for serving all the source files under the test.\nvar createSourceFilesMiddleware = function (filesPromise, serveFile, basePath, urlRoot) {\n  return function (request, response, next) {\n    var requestedFilePath = composeUrl(request.url, basePath, urlRoot, true)\n    // When a path contains HTML-encoded characters (e.g %2F used by Jenkins for branches with /)\n    var requestedFilePathUnescaped = composeUrl(request.url, basePath, urlRoot, false)\n\n    request.pause()\n\n    log.debug('Requesting %s', request.url, urlRoot)\n    log.debug('Fetching %s', requestedFilePath)\n\n    return filesPromise.then(function (files) {\n      // TODO(vojta): change served to be a map rather then an array\n      var file = findByPath(files.served, requestedFilePath) ||\n                 findByPath(files.served, requestedFilePathUnescaped)\n      var rangeHeader = request.headers['range']\n\n      if (file) {\n        serveFile(file.contentPath || file.path, rangeHeader, response, function () {\n          if (/\\?\\w+/.test(request.url)) {\n            // files with timestamps - cache one year, rely on timestamps\n            common.setHeavyCacheHeaders(response)\n          } else {\n            // without timestamps - no cache (debug)\n            common.setNoCacheHeaders(response)\n          }\n        }, file.content, file.doNotCache)\n      } else {\n        next()\n      }\n\n      request.resume()\n    })\n  }\n}\n\ncreateSourceFilesMiddleware.$inject = [\n  'filesPromise', 'serveFile', 'config.basePath', 'config.urlRoot'\n]\n\n// PUBLIC API\nexports.create = createSourceFilesMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/middleware/proxy.js":"var url = require('url')\nvar httpProxy = require('http-proxy')\nvar _ = require('lodash')\n\nvar log = require('../logger').create('proxy')\n\nvar parseProxyConfig = function (proxies, config) {\n  var endsWithSlash = function (str) {\n    return str.substr(-1) === '/'\n  }\n\n  if (!proxies) {\n    return []\n  }\n\n  return _.sortBy(_.map(proxies, function (proxyConfiguration, proxyPath) {\n    if (typeof proxyConfiguration === 'string') {\n      proxyConfiguration = {target: proxyConfiguration}\n    }\n    var proxyUrl = proxyConfiguration.target\n    var proxyDetails = url.parse(proxyUrl)\n    var pathname = proxyDetails.pathname\n\n    // normalize the proxies config\n    // should we move this to lib/config.js ?\n    if (endsWithSlash(proxyPath) && !endsWithSlash(proxyUrl)) {\n      log.warn('proxy \"%s\" normalized to \"%s\"', proxyUrl, proxyUrl + '/')\n      proxyUrl += '/'\n      pathname += '/'\n    }\n\n    if (!endsWithSlash(proxyPath) && endsWithSlash(proxyUrl)) {\n      log.warn('proxy \"%s\" normalized to \"%s\"', proxyPath, proxyPath + '/')\n      proxyPath += '/'\n    }\n\n    if (pathname === '/' && !endsWithSlash(proxyUrl)) {\n      pathname = ''\n    }\n\n    var hostname = proxyDetails.hostname || config.hostname\n    var protocol = proxyDetails.protocol || config.protocol\n    var https = proxyDetails.protocol === 'https:'\n    var port\n    if (proxyDetails.port) {\n      port = proxyDetails.port\n    } else if (proxyDetails.protocol) {\n      port = proxyDetails.protocol === 'https:' ? '443' : '80'\n    } else {\n      port = config.port\n    }\n    var changeOrigin = 'changeOrigin' in proxyConfiguration ? proxyConfiguration.changeOrigin : false\n    var proxy = httpProxy.createProxyServer({\n      target: {\n        host: hostname,\n        port: port,\n        https: https,\n        protocol: protocol\n      },\n      xfwd: true,\n      changeOrigin: changeOrigin,\n      secure: config.proxyValidateSSL\n    })\n\n    ;['proxyReq', 'proxyRes'].forEach(function (name) {\n      var callback = proxyDetails[name] || config[name]\n      if (callback) {\n        proxy.on(name, callback)\n      }\n    })\n\n    proxy.on('error', function proxyError (err, req, res) {\n      if (err.code === 'ECONNRESET' && req.socket.destroyed) {\n        log.debug('failed to proxy %s (browser hung up the socket)', req.url)\n      } else {\n        log.warn('failed to proxy %s (%s)', req.url, err.message)\n      }\n\n      res.destroy()\n    })\n\n    return {\n      path: proxyPath,\n      baseUrl: pathname,\n      host: hostname,\n      port: port,\n      https: https,\n      proxy: proxy\n    }\n  }), 'path').reverse()\n}\n\n/**\n * Returns a handler which understands the proxies and its redirects, along with the proxy to use\n * @param proxies An array of proxy record objects\n * @param urlRoot The URL root that karma is mounted on\n * @return {Function} handler function\n */\nvar createProxyHandler = function (proxies, urlRoot) {\n  if (!proxies.length) {\n    var nullProxy = function createNullProxy (request, response, next) {\n      return next()\n    }\n    nullProxy.upgrade = function upgradeNullProxy () {}\n    return nullProxy\n  }\n\n  var middleware = function createProxy (request, response, next) {\n    var proxyRecord = _.find(proxies, function (p) {\n      return request.url.indexOf(p.path) === 0\n    })\n\n    if (!proxyRecord) {\n      return next()\n    }\n\n    log.debug('proxying request - %s to %s:%s', request.url, proxyRecord.host, proxyRecord.port)\n    request.url = request.url.replace(proxyRecord.path, proxyRecord.baseUrl)\n    proxyRecord.proxy.web(request, response)\n  }\n\n  middleware.upgrade = function upgradeProxy (request, socket, head) {\n    // special-case karma's route to avoid upgrading it\n    if (request.url.indexOf(urlRoot) === 0) {\n      log.debug('NOT upgrading proxyWebSocketRequest %s', request.url)\n      return\n    }\n\n    var proxyRecord = _.find(proxies, function (p) {\n      return request.url.indexOf(p.path) === 0\n    })\n\n    if (!proxyRecord) {\n      return\n    }\n\n    log.debug('upgrade proxyWebSocketRequest %s to %s:%s',\n      request.url, proxyRecord.host, proxyRecord.port)\n    request.url = request.url.replace(proxyRecord.path, proxyRecord.baseUrl)\n    proxyRecord.proxy.ws(request, socket, head)\n  }\n\n  return middleware\n}\n\nexports.create = function (/* config */config, /* config.proxies */proxies) {\n  return createProxyHandler(parseProxyConfig(proxies, config), config.urlRoot)\n}\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/preprocessor.js":"var fs = require('graceful-fs')\nvar crypto = require('crypto')\nvar mm = require('minimatch')\nvar isBinaryFile = require('isbinaryfile')\nvar combineLists = require('combine-lists')\n\nvar log = require('./logger').create('preprocess')\n\nvar sha1 = function (data) {\n  var hash = crypto.createHash('sha1')\n  hash.update(data)\n  return hash.digest('hex')\n}\n\nvar createNextProcessor = function (preprocessors, file, done) {\n  return function nextPreprocessor (error, content) {\n    // normalize B-C\n    if (arguments.length === 1 && typeof error === 'string') {\n      content = error\n      error = null\n    }\n\n    if (error) {\n      file.content = null\n      file.contentPath = null\n      return done(error)\n    }\n\n    if (!preprocessors.length) {\n      file.contentPath = null\n      file.content = content\n      file.sha = sha1(content)\n      return done()\n    }\n\n    preprocessors.shift()(content, file, nextPreprocessor)\n  }\n}\n\nvar createPreprocessor = function (config, basePath, injector) {\n  var alreadyDisplayedErrors = {}\n  var instances = {}\n  var patterns = Object.keys(config)\n\n  var emitter = injector.get('emitter')\n\n  var instantiatePreprocessor = function (name) {\n    if (alreadyDisplayedErrors[name]) {\n      return\n    }\n\n    var p\n\n    try {\n      p = injector.get('preprocessor:' + name)\n    } catch (e) {\n      if (e.message.indexOf('No provider for \"preprocessor:' + name + '\"') !== -1) {\n        log.error('Can not load \"%s\", it is not registered!\\n  ' +\n          'Perhaps you are missing some plugin?', name)\n      } else {\n        log.error('Can not load \"%s\"!\\n  ' + e.stack, name)\n      }\n      alreadyDisplayedErrors[name] = true\n      emitter.emit('load_error', 'preprocessor', name)\n    }\n\n    return p\n  }\n\n  var allPreprocessors = []\n  patterns.forEach(function (pattern) {\n    allPreprocessors = combineLists(allPreprocessors, config[pattern])\n  })\n  allPreprocessors.forEach(instantiatePreprocessor)\n\n  return function preprocess (file, done) {\n    patterns = Object.keys(config)\n\n    return fs.readFile(file.originalPath, function (err, buffer) {\n      if (err) {\n        throw err\n      }\n\n      isBinaryFile(buffer, buffer.length, function (err, thisFileIsBinary) {\n        if (err) {\n          throw err\n        }\n\n        var preprocessorNames = []\n        for (var i = 0; i < patterns.length; i++) {\n          if (mm(file.originalPath, patterns[i], {dot: true})) {\n            if (thisFileIsBinary) {\n              log.warn('Ignoring preprocessing (%s) %s because it is a binary file.',\n                config[patterns[i]].join(', '), file.originalPath)\n            } else {\n              preprocessorNames = combineLists(preprocessorNames, config[patterns[i]])\n            }\n          }\n        }\n\n        var preprocessors = []\n        var nextPreprocessor = createNextProcessor(preprocessors, file, done)\n        preprocessorNames.forEach(function (name) {\n          var p = instances[name]\n          if (p == null) {\n            p = instantiatePreprocessor(name)\n          }\n\n          if (p == null) {\n            if (!alreadyDisplayedErrors[name]) {\n              alreadyDisplayedErrors[name] = true\n              log.error('Failed to instantiate preprocessor %s', name)\n              emitter.emit('load_error', 'preprocessor', name)\n            }\n            return\n          }\n\n          instances[name] = p\n          preprocessors.push(p)\n        })\n\n        nextPreprocessor(null, thisFileIsBinary ? buffer : buffer.toString())\n      })\n    })\n  }\n}\ncreatePreprocessor.$inject = ['config.preprocessors', 'config.basePath', 'injector']\n\nexports.createPreprocessor = createPreprocessor\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/launcher.js":"var Promise = require('bluebird')\nvar Jobs = require('qjobs')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('launcher')\n\nvar baseDecorator = require('./launchers/base').decoratorFactory\nvar captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory\nvar retryDecorator = require('./launchers/retry').decoratorFactory\nvar processDecorator = require('./launchers/process').decoratorFactory\n\n// TODO(vojta): remove once nobody uses it\nvar baseBrowserDecoratorFactory = function (\n  baseLauncherDecorator,\n  captureTimeoutLauncherDecorator,\n  retryLauncherDecorator,\n  processLauncherDecorator,\n  processKillTimeout\n) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher)\n    captureTimeoutLauncherDecorator(launcher)\n    retryLauncherDecorator(launcher)\n    processLauncherDecorator(launcher, processKillTimeout)\n  }\n}\n\nvar Launcher = function (server, emitter, injector) {\n  this._browsers = []\n  var lastStartTime\n  var self = this\n\n  var getBrowserById = function (id) {\n    for (var i = 0; i < self._browsers.length; i++) {\n      if (self._browsers[i].id === id) {\n        return self._browsers[i]\n      }\n    }\n\n    return null\n  }\n\n  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    var self = this\n    return function (name) {\n      if (upstreamProxy) {\n        protocol = upstreamProxy.protocol\n        hostname = upstreamProxy.hostname\n        port = upstreamProxy.port\n        urlRoot = upstreamProxy.path + urlRoot.substr(1)\n      }\n      var url = protocol + '//' + hostname + ':' + port + urlRoot\n\n      var locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }\n\n      // TODO(vojta): determine script from name\n      if (name.indexOf('/') !== -1) {\n        name = 'Script'\n      }\n\n      try {\n        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)\n      } catch (e) {\n        if (e.message.indexOf('No provider for \"launcher:' + name + '\"') !== -1) {\n          log.error('Cannot load browser \"%s\": it is not registered! ' +\n            'Perhaps you are missing some plugin?', name)\n        } else {\n          log.error('Cannot load browser \"%s\"!\\n  ' + e.stack, name)\n        }\n\n        emitter.emit('load_error', 'launcher', name)\n        return\n      }\n\n      // TODO(vojta): remove in v1.0 (BC for old launchers)\n      if (!browser.forceKill) {\n        browser.forceKill = function () {\n          var me = this\n          return new Promise(function (resolve) {\n            me.kill(resolve)\n          })\n        }\n\n        browser.restart = function () {\n          var me = this\n          this.kill(function () {\n            me.start(url)\n          })\n        }\n      }\n\n      self.jobs.add(function (args, done) {\n        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)\n\n        browser.on('browser_process_failure', function () {\n          done(browser.error)\n        })\n\n        browser.on('done', function () {\n          // We are not done if there was an error as first the retry takes\n          // place which we catch with `browser_process_failure` if it fails\n          if (browser.error || browser.state === browser.STATE_RESTARTING) return\n\n          done(null, browser)\n        })\n\n        browser.start(url)\n      }, [])\n\n      self.jobs.run()\n      self._browsers.push(browser)\n    }\n  }\n\n  this.launch = function (names, concurrency) {\n    log.info(\n      'Launching browser%s %s with %s',\n      names.length > 1 ? 's' : '',\n      names.join(', '),\n      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency\n    )\n    this.jobs = new Jobs({maxConcurrency: concurrency})\n\n    var self = this\n    lastStartTime = Date.now()\n\n    if (server.loadErrors.length === 0) {\n      names.forEach(function (name) {\n        injector.invoke(self.launchSingle, self)(name)\n      })\n    } else {\n      // Empty task to ensure `end` is emitted\n      this.jobs.add(function (args, done) {\n        done()\n      }, [])\n    }\n\n    this.jobs.on('end', function (err) {\n      log.debug('Finished all browsers')\n\n      if (err) {\n        log.error(err)\n      }\n    })\n\n    this.jobs.run()\n\n    return self._browsers\n  }\n\n  this.launch.$inject = [\n    'config.browsers',\n    'config.concurrency',\n    'config.processKillTimeout'\n  ]\n\n  this.launchSingle.$inject = [\n    'config.protocol',\n    'config.hostname',\n    'config.port',\n    'config.urlRoot',\n    'config.upstreamProxy',\n    'config.processKillTimeout'\n  ]\n\n  this.kill = function (id, callback) {\n    var browser = getBrowserById(id)\n    callback = callback || function () {}\n\n    if (!browser) {\n      process.nextTick(callback)\n      return false\n    }\n\n    browser.forceKill().then(callback)\n    return true\n  }\n\n  this.restart = function (id) {\n    var browser = getBrowserById(id)\n\n    if (!browser) {\n      return false\n    }\n\n    browser.restart()\n    return true\n  }\n\n  this.killAll = function (callback) {\n    log.debug('Disconnecting all browsers')\n\n    var remaining = 0\n    var finish = function () {\n      remaining--\n      if (!remaining && callback) {\n        callback()\n      }\n    }\n\n    if (!self._browsers.length) {\n      return process.nextTick(callback)\n    }\n\n    self._browsers.forEach(function (browser) {\n      remaining++\n      browser.forceKill().then(finish)\n    })\n  }\n\n  this.areAllCaptured = function () {\n    return !self._browsers.some(function (browser) {\n      return !browser.isCaptured()\n    })\n  }\n\n  this.markCaptured = function (id) {\n    self._browsers.forEach(function (browser) {\n      if (browser.id === id) {\n        browser.markCaptured()\n        log.debug('%s (id %s) captured in %d secs', browser.name, browser.id,\n          (Date.now() - lastStartTime) / 1000)\n      }\n    })\n  }\n\n  // register events\n  emitter.on('exit', this.killAll)\n}\n\nLauncher.$inject = ['server', 'emitter', 'injector']\n\nLauncher.generateId = function () {\n  return '' + Math.floor(Math.random() * 100000000)\n}\n\n// PUBLISH\nexports.Launcher = Launcher\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/launchers/base.js":"var KarmaEventEmitter = require('../events').EventEmitter\nvar EventEmitter = require('events').EventEmitter\nvar Promise = require('bluebird')\n\nvar log = require('../logger').create('launcher')\nvar helper = require('../helper')\n\nvar BEING_CAPTURED = 1\nvar CAPTURED = 2\nvar BEING_KILLED = 3\nvar FINISHED = 4\nvar RESTARTING = 5\nvar BEING_FORCE_KILLED = 6\n\n/**\n * Base launcher that any custom launcher extends.\n */\nvar BaseLauncher = function (id, emitter) {\n  if (this.start) {\n    return\n  }\n\n  // TODO(vojta): figure out how to do inheritance with DI\n  Object.keys(EventEmitter.prototype).forEach(function (method) {\n    this[method] = EventEmitter.prototype[method]\n  }, this)\n  KarmaEventEmitter.call(this)\n\n  this.id = id\n  this.state = null\n  this.error = null\n\n  var self = this\n  var killingPromise\n  var previousUrl\n\n  this.start = function (url) {\n    previousUrl = url\n\n    this.error = null\n    this.state = BEING_CAPTURED\n    this.emit('start', url + '?id=' + this.id + (helper.isDefined(self.displayName) ? '&displayName=' + encodeURIComponent(self.displayName) : ''))\n  }\n\n  this.kill = function () {\n    // Already killed, or being killed.\n    if (killingPromise) {\n      return killingPromise\n    }\n\n    killingPromise = this.emitAsync('kill').then(function () {\n      self.state = FINISHED\n    })\n\n    this.state = BEING_KILLED\n\n    return killingPromise\n  }\n\n  this.forceKill = function () {\n    this.kill()\n    this.state = BEING_FORCE_KILLED\n\n    return killingPromise\n  }\n\n  this.restart = function () {\n    if (this.state === BEING_FORCE_KILLED) {\n      return\n    }\n\n    if (!killingPromise) {\n      killingPromise = this.emitAsync('kill')\n    }\n\n    killingPromise.then(function () {\n      if (self.state === BEING_FORCE_KILLED) {\n        self.state = FINISHED\n      } else {\n        killingPromise = null\n        log.debug('Restarting %s', self.name)\n        self.start(previousUrl)\n      }\n    })\n\n    self.state = RESTARTING\n  }\n\n  this.markCaptured = function () {\n    if (this.state === BEING_CAPTURED) {\n      this.state = CAPTURED\n    }\n  }\n\n  this.isCaptured = function () {\n    return this.state === CAPTURED\n  }\n\n  this.toString = function () {\n    return this.name\n  }\n\n  this._done = function (error) {\n    killingPromise = killingPromise || Promise.resolve()\n\n    this.error = this.error || error\n    this.emit('done')\n\n    if (this.error && this.state !== BEING_FORCE_KILLED && this.state !== RESTARTING) {\n      emitter.emit('browser_process_failure', this)\n    }\n\n    this.state = FINISHED\n  }\n\n  this.STATE_BEING_CAPTURED = BEING_CAPTURED\n  this.STATE_CAPTURED = CAPTURED\n  this.STATE_BEING_KILLED = BEING_KILLED\n  this.STATE_FINISHED = FINISHED\n  this.STATE_RESTARTING = RESTARTING\n  this.STATE_BEING_FORCE_KILLED = BEING_FORCE_KILLED\n}\n\nBaseLauncher.decoratorFactory = function (id, emitter) {\n  return function (launcher) {\n    BaseLauncher.call(launcher, id, emitter)\n  }\n}\n\nmodule.exports = BaseLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/events.js":"var events = require('events')\nvar util = require('util')\n\nvar helper = require('./helper')\n\nvar bindAllEvents = function (object, context) {\n  context = context || this\n\n  var bindMethod = function (method) {\n    context.on(helper.camelToSnake(method.substr(2)), function () {\n      var args = Array.prototype.slice.call(arguments, 0)\n      args.push(context)\n      object[method].apply(object, args)\n    })\n  }\n\n  for (var method in object) {\n    if (helper.isFunction(object[method]) && method.substr(0, 2) === 'on') {\n      bindMethod(method)\n    }\n  }\n}\n\nvar bufferEvents = function (emitter, eventsToBuffer) {\n  var listeners = []\n  var eventsToReply = []\n  var genericListener = function () {\n    eventsToReply.push(Array.prototype.slice.call(arguments))\n  }\n\n  eventsToBuffer.forEach(function (eventName) {\n    var listener = genericListener.bind(null, eventName)\n    listeners.push(listener)\n    emitter.on(eventName, listener)\n  })\n\n  return function () {\n    if (!eventsToReply) {\n      return\n    }\n\n    // remove all buffering listeners\n    listeners.forEach(function (listener, i) {\n      emitter.removeListener(eventsToBuffer[i], listener)\n    })\n\n    // reply\n    eventsToReply.forEach(function (args) {\n      events.EventEmitter.prototype.emit.apply(emitter, args)\n    })\n\n    // free-up\n    listeners = eventsToReply = null\n  }\n}\n\n// TODO(vojta): log.debug all events\nvar EventEmitter = function () {\n  this.bind = bindAllEvents\n\n  this.emitAsync = function (name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    var pending = this.listeners(name).length\n    var deferred = helper.defer()\n    var done = function () {\n      if (!--pending) {\n        deferred.resolve()\n      }\n    }\n\n    this.emit(name, done)\n\n    if (!pending) {\n      deferred.resolve()\n    }\n\n    return deferred.promise\n  }\n}\n\nutil.inherits(EventEmitter, events.EventEmitter)\n\n// PUBLISH\nexports.EventEmitter = EventEmitter\nexports.bindAll = bindAllEvents\nexports.bufferEvents = bufferEvents\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/launchers/capture_timeout.js":"var log = require('../logger').create('launcher')\n\n/**\n * Kill browser if it does not capture in given `captureTimeout`.\n */\nvar CaptureTimeoutLauncher = function (timer, captureTimeout) {\n  if (!captureTimeout) {\n    return\n  }\n\n  var self = this\n  var pendingTimeoutId = null\n\n  this.on('start', function () {\n    pendingTimeoutId = timer.setTimeout(function () {\n      pendingTimeoutId = null\n      if (self.state !== self.STATE_BEING_CAPTURED) {\n        return\n      }\n\n      log.warn('%s have not captured in %d ms, killing.', self.name, captureTimeout)\n      self.error = 'timeout'\n      self.kill()\n    }, captureTimeout)\n  })\n\n  this.on('done', function () {\n    if (pendingTimeoutId) {\n      timer.clearTimeout(pendingTimeoutId)\n      pendingTimeoutId = null\n    }\n  })\n}\n\nCaptureTimeoutLauncher.decoratorFactory = function (timer,\n  /* config.captureTimeout */ captureTimeout) {\n  return function (launcher) {\n    CaptureTimeoutLauncher.call(launcher, timer, captureTimeout)\n  }\n}\n\nCaptureTimeoutLauncher.decoratorFactory.$inject = ['timer', 'config.captureTimeout']\n\nmodule.exports = CaptureTimeoutLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/launchers/retry.js":"var log = require('../logger').create('launcher')\n\nvar RetryLauncher = function (retryLimit) {\n  var self = this\n\n  this._retryLimit = retryLimit\n\n  this.on('done', function () {\n    if (!self.error) {\n      return\n    }\n\n    if (self._retryLimit > 0) {\n      var attempt = retryLimit - self._retryLimit + 1\n      log.info('Trying to start %s again (%d/%d).', self.name, attempt, retryLimit)\n      self.restart()\n      self._retryLimit--\n    } else if (self._retryLimit === 0) {\n      log.error('%s failed %d times (%s). Giving up.', self.name, retryLimit, self.error)\n    } else {\n      log.debug('%s failed (%s). Not restarting.', self.name, self.error)\n    }\n  })\n}\n\nRetryLauncher.decoratorFactory = function (retryLimit) {\n  return function (launcher) {\n    RetryLauncher.call(launcher, retryLimit)\n  }\n}\n\nRetryLauncher.decoratorFactory.$inject = ['config.retryLimit']\n\nmodule.exports = RetryLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/launchers/process.js":"var path = require('path')\nvar log = require('../logger').create('launcher')\nvar env = process.env\n\nvar ProcessLauncher = function (spawn, tempDir, timer, processKillTimeout) {\n  var self = this\n  var onExitCallback\n  var killTimeout = processKillTimeout || 2000\n\n  this._tempDir = tempDir.getPath('/karma-' + this.id.toString())\n\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir)\n    self._start(url)\n  })\n\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done)\n    }\n\n    onExitCallback = done\n    self._process.kill()\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)\n  })\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url))\n  }\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]\n  }\n\n  this._getOptions = function (url) {\n    return [url]\n  }\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.indexOf(cmd.charAt(0)) !== -1) {\n      cmd = cmd.substring(1, cmd.length - 1)\n      log.warn('The path should not be quoted.\\n  Normalized the path to %s', cmd)\n    }\n\n    return path.normalize(cmd)\n  }\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error('No binary for %s browser on your platform.\\n  ' +\n        'Please, set \"%s\" env variable.', self.name, self.ENV_CMD)\n\n      // disable restarting\n      self._retryLimit = -1\n\n      return self._clearTempDirAndReportDone('no binary')\n    }\n\n    cmd = this._normalizeCommand(cmd)\n\n    log.debug(cmd + ' ' + args.join(' '))\n    self._process = spawn(cmd, args)\n\n    var errorOutput = ''\n\n    self._process.on('exit', function (code) {\n      self._onProcessExit(code, errorOutput)\n    })\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1\n        errorOutput = 'Can not find the binary ' + cmd + '\\n\\t' +\n          'Please set env variable ' + self.ENV_CMD\n      } else {\n        errorOutput += err.toString()\n      }\n    })\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString()\n    })\n  }\n\n  this._onProcessExit = function (code, errorOutput) {\n    log.debug('Process %s exited with code %d', self.name, code)\n\n    var error = null\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error('Cannot start %s\\n\\t%s', self.name, errorOutput)\n      error = 'cannot start'\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error('%s crashed.\\n\\t%s', self.name, errorOutput)\n      error = 'crashed'\n    }\n\n    self._process = null\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer)\n      self._killTimer = null\n    }\n    self._clearTempDirAndReportDone(error)\n  }\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error)\n      if (onExitCallback) {\n        onExitCallback()\n        onExitCallback = null\n      }\n    })\n  }\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return\n    }\n\n    log.warn('%s was not killed in %d ms, sending SIGKILL.', self.name, killTimeout)\n    self._process.kill('SIGKILL')\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn('%s was not killed by SIGKILL in %d ms, continuing.', self.name, killTimeout)\n      self._onProcessExit(-1, '')\n    }, killTimeout)\n  }\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    var spawn = require('child_process').spawn\n\n    var spawnWithoutOutput = function () {\n      var proc = spawn.apply(null, arguments)\n      proc.stdout.resume()\n      proc.stderr.resume()\n\n      return proc\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)\n  }\n}\n\nmodule.exports = ProcessLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/file-list.js":"// File List\n// =========\n//\n// The List is an object for tracking all files that karma knows about\n// currently.\n\n// Dependencies\n// ------------\n\nrequire('core-js')\nvar from = require('core-js/library/fn/array/from')\nvar Promise = require('bluebird')\nvar mm = require('minimatch')\nvar Glob = require('glob').Glob\nvar fs = Promise.promisifyAll(require('graceful-fs'))\nvar pathLib = require('path')\nvar _ = require('lodash')\n\nvar File = require('./file')\nvar Url = require('./url')\nvar helper = require('./helper')\nvar log = require('./logger').create('watcher')\nvar createPatternObject = require('./config').createPatternObject\n\n// Constants\n// ---------\n\nvar GLOB_OPTS = {\n  cwd: '/',\n  follow: true,\n  nodir: true,\n  sync: true\n}\n\n// Helper Functions\n// ----------------\n\nfunction byPath (a, b) {\n  if (a.path > b.path) return 1\n  if (a.path < b.path) return -1\n\n  return 0\n}\n\n// Constructor\n//\n// patterns      - Array\n// excludes      - Array\n// emitter       - EventEmitter\n// preprocess    - Function\n// batchInterval - Number\nvar List = function (patterns, excludes, emitter, preprocess, batchInterval) {\n  // Store options\n  this._patterns = patterns\n  this._excludes = excludes\n  this._emitter = emitter\n  this._preprocess = Promise.promisify(preprocess)\n  this._batchInterval = batchInterval\n\n  // The actual list of files\n  this.buckets = new Map()\n\n  // Internal tracker if we are refreshing.\n  // When a refresh is triggered this gets set\n  // to the promise that `this._refresh` returns.\n  // So we know we are refreshing when this promise\n  // is still pending, and we are done when it's either\n  // resolved or rejected.\n  this._refreshing = Promise.resolve()\n\n  var self = this\n\n  // Emit the `file_list_modified` event.\n  // This function is throttled to the value of `batchInterval`\n  // to avoid spamming the listener.\n  function emit () {\n    self._emitter.emit('file_list_modified', self.files)\n  }\n  var throttledEmit = _.throttle(emit, self._batchInterval, {leading: false})\n  self._emitModified = function (immediate) {\n    immediate ? emit() : throttledEmit()\n  }\n}\n\n// Private Interface\n// -----------------\n\n// Is the given path matched by any exclusion filter\n//\n// path - String\n//\n// Returns `undefined` if no match, otherwise the matching\n// pattern.\nList.prototype._isExcluded = function (path) {\n  return _.find(this._excludes, function (pattern) {\n    return mm(path, pattern)\n  })\n}\n\n// Find the matching include pattern for the given path.\n//\n// path - String\n//\n// Returns the match or `undefined` if none found.\nList.prototype._isIncluded = function (path) {\n  return _.find(this._patterns, function (pattern) {\n    return mm(path, pattern.pattern)\n  })\n}\n\n// Find the given path in the bucket corresponding\n// to the given pattern.\n//\n// path    - String\n// pattern - Object\n//\n// Returns a File or undefined\nList.prototype._findFile = function (path, pattern) {\n  if (!path || !pattern) return\n  if (!this.buckets.has(pattern.pattern)) return\n\n  return _.find(from(this.buckets.get(pattern.pattern)), function (file) {\n    return file.originalPath === path\n  })\n}\n\n// Is the given path already in the files list.\n//\n// path - String\n//\n// Returns a boolean.\nList.prototype._exists = function (path) {\n  var self = this\n\n  var patterns = this._patterns.filter(function (pattern) {\n    return mm(path, pattern.pattern)\n  })\n\n  return !!_.find(patterns, function (pattern) {\n    return self._findFile(path, pattern)\n  })\n}\n\n// Check if we are currently refreshing\nList.prototype._isRefreshing = function () {\n  return this._refreshing.isPending()\n}\n\n// Do the actual work of refreshing\nList.prototype._refresh = function () {\n  var self = this\n  var buckets = this.buckets\n  var matchedFiles = new Set()\n\n  var promise = Promise.map(this._patterns, function (patternObject) {\n    var pattern = patternObject.pattern\n\n    if (helper.isUrlAbsolute(pattern)) {\n      buckets.set(pattern, new Set([new Url(pattern)]))\n      return Promise.resolve()\n    }\n\n    var mg = new Glob(pathLib.normalize(pattern), GLOB_OPTS)\n    var files = mg.found\n    buckets.set(pattern, new Set())\n\n    if (_.isEmpty(files)) {\n      log.warn('Pattern \"%s\" does not match any file.', pattern)\n      return\n    }\n\n    return Promise.map(files, function (path) {\n      if (self._isExcluded(path)) {\n        log.debug('Excluded file \"%s\"', path)\n        return Promise.resolve()\n      }\n\n      if (matchedFiles.has(path)) {\n        return Promise.resolve()\n      }\n\n      matchedFiles.add(path)\n\n      var mtime = mg.statCache[path].mtime\n      var doNotCache = patternObject.nocache\n      var file = new File(path, mtime, doNotCache)\n\n      if (file.doNotCache) {\n        log.debug('Not preprocessing \"%s\" due to nocache')\n        return Promise.resolve(file)\n      }\n\n      return self._preprocess(file).then(function () {\n        return file\n      })\n    })\n    .then(function (files) {\n      files = _.compact(files)\n\n      if (_.isEmpty(files)) {\n        log.warn('All files matched by \"%s\" were excluded or matched by prior matchers.', pattern)\n      } else {\n        buckets.set(pattern, new Set(files))\n      }\n    })\n  })\n  .then(function () {\n    if (self._refreshing !== promise) {\n      return self._refreshing\n    }\n    self.buckets = buckets\n    self._emitModified(true)\n    return self.files\n  })\n\n  return promise\n}\n\n// Public Interface\n// ----------------\n\nObject.defineProperty(List.prototype, 'files', {\n  get: function () {\n    var self = this\n    var uniqueFlat = function (list) {\n      return _.uniq(_.flatten(list), 'path')\n    }\n\n    var expandPattern = function (p) {\n      return from(self.buckets.get(p.pattern) || []).sort(byPath)\n    }\n\n    var served = this._patterns.filter(function (pattern) {\n      return pattern.served\n    })\n    .map(expandPattern)\n\n    var lookup = {}\n    var included = {}\n    this._patterns.forEach(function (p) {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      var bucket = expandPattern(p)\n      bucket.forEach(function (file) {\n        var other = lookup[file.path]\n        if (other && other.compare(p) < 0) return\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: uniqueFlat(served),\n      included: _.values(included)\n    }\n  }\n})\n\n// Reglob all patterns to update the list.\n//\n// Returns a promise that is resolved when the refresh\n// is completed.\nList.prototype.refresh = function () {\n  this._refreshing = this._refresh()\n  return this._refreshing\n}\n\n// Set new patterns and excludes and update\n// the list accordingly\n//\n// patterns - Array, the new patterns.\n// excludes - Array, the new exclude patterns.\n//\n// Returns a promise that is resolved when the refresh\n// is completed.\nList.prototype.reload = function (patterns, excludes) {\n  this._patterns = patterns\n  this._excludes = excludes\n\n  // Wait until the current refresh is done and then do a\n  // refresh to ensure a refresh actually happens\n  return this.refresh()\n}\n\n// Add a new file from the list.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.addFile = function (path) {\n  var self = this\n\n  // Ensure we are not adding a file that should be excluded\n  var excluded = this._isExcluded(path)\n  if (excluded) {\n    log.debug('Add file \"%s\" ignored. Excluded by \"%s\".', path, excluded)\n\n    return Promise.resolve(this.files)\n  }\n\n  var pattern = this._isIncluded(path)\n\n  if (!pattern) {\n    log.debug('Add file \"%s\" ignored. Does not match any pattern.', path)\n    return Promise.resolve(this.files)\n  }\n\n  if (this._exists(path)) {\n    log.debug('Add file \"%s\" ignored. Already in the list.', path)\n    return Promise.resolve(this.files)\n  }\n\n  var file = new File(path)\n  this.buckets.get(pattern.pattern).add(file)\n\n  return Promise.all([\n    fs.statAsync(path),\n    this._refreshing\n  ]).spread(function (stat) {\n    file.mtime = stat.mtime\n    return self._preprocess(file)\n  })\n  .then(function () {\n    log.info('Added file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n}\n\n// Update the `mtime` of a file.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.changeFile = function (path) {\n  var self = this\n\n  var pattern = this._isIncluded(path)\n  var file = this._findFile(path, pattern)\n\n  if (!pattern || !file) {\n    log.debug('Changed file \"%s\" ignored. Does not match any file in the list.', path)\n    return Promise.resolve(this.files)\n  }\n\n  return Promise.all([\n    fs.statAsync(path),\n    this._refreshing\n  ]).spread(function (stat) {\n    if (stat.mtime <= file.mtime) throw new Promise.CancellationError()\n\n    file.mtime = stat.mtime\n    return self._preprocess(file)\n  })\n  .then(function () {\n    log.info('Changed file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n  .catch(Promise.CancellationError, function () {\n    return self.files\n  })\n}\n\n// Remove a file from the list.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.removeFile = function (path) {\n  var self = this\n\n  return Promise.try(function () {\n    var pattern = self._isIncluded(path)\n    var file = self._findFile(path, pattern)\n\n    if (!pattern || !file) {\n      log.debug('Removed file \"%s\" ignored. Does not match any file in the list.', path)\n      return self.files\n    }\n\n    self.buckets.get(pattern.pattern).delete(file)\n\n    log.info('Removed file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n}\n\n// Inject dependencies\nList.$inject = ['config.files', 'config.exclude', 'emitter', 'preprocess',\n  'config.autoWatchBatchDelay']\n\n// PUBLIC\nmodule.exports = List\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/file.js":"// File\n// ====\n//\n// File object used for tracking files in `file-list.js`\n\n// Dependencies\n// ------------\n\nvar _ = require('lodash')\n\n// Constructor\nvar File = function (path, mtime, doNotCache) {\n  // used for serving (processed path, eg some/file.coffee -> some/file.coffee.js)\n  this.path = path\n\n  // original absolute path, id of the file\n  this.originalPath = path\n\n  // where the content is stored (processed)\n  this.contentPath = path\n\n  this.mtime = mtime\n  this.isUrl = false\n\n  this.doNotCache = _.isUndefined(doNotCache) ? false : doNotCache\n}\n\nFile.prototype.toString = function () {\n  return this.path\n}\n\n// PUBLIC\nmodule.exports = File\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/url.js":"// Url\n// ===\n//\n// Url object used for tracking files in `file-list.js`\n\nvar Url = function (path) {\n  this.path = path\n  this.isUrl = true\n}\n\nUrl.prototype.toString = function () {\n  return this.path\n}\n\n// PUBLIC\nmodule.exports = Url\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/reporter.js":"var util = require('util')\nvar resolve = require('url').resolve\nvar SourceMapConsumer = require('source-map').SourceMapConsumer\nvar WeakMap = require('core-js/es6/weak-map')\nvar _ = require('lodash')\n\nvar log = require('./logger').create('reporter')\nvar MultiReporter = require('./reporters/multi')\nvar baseReporterDecoratorFactory = require('./reporters/base').decoratorFactory\n\nvar createErrorFormatter = function (config, emitter, SourceMapConsumer) {\n  var basePath = config.basePath\n  var lastServedFiles = []\n\n  emitter.on('file_list_modified', function (files) {\n    lastServedFiles = files.served\n  })\n\n  var findFile = function (path) {\n    for (var i = 0; i < lastServedFiles.length; i++) {\n      if (lastServedFiles[i].path === path) {\n        return lastServedFiles[i]\n      }\n    }\n    return null\n  }\n\n  var URL_REGEXP = new RegExp('(?:https?:\\\\/\\\\/' +\n    config.hostname + '(?:\\\\:' + config.port + ')?' + ')?\\\\/?' +\n    '(base/|absolute)' + // prefix, including slash for base/ to create relative paths.\n    '((?:[A-z]\\\\:)?[^\\\\?\\\\s\\\\:]*)' + // path\n    '(\\\\?\\\\w*)?' + // sha\n    '(\\\\:(\\\\d+))?' + // line\n    '(\\\\:(\\\\d+))?' + // column\n    '', 'g')\n\n  var getSourceMapConsumer = (function () {\n    var cache = new WeakMap()\n    return function (sourceMap) {\n      if (!cache.has(sourceMap)) {\n        cache.set(sourceMap, new SourceMapConsumer(sourceMap))\n      }\n      return cache.get(sourceMap)\n    }\n  }())\n\n  return function (input, indentation) {\n    indentation = _.isString(indentation) ? indentation : ''\n    if (_.isError(input)) {\n      input = input.message\n    } else if (_.isEmpty(input)) {\n      input = ''\n    } else if (!_.isString(input)) {\n      input = JSON.stringify(input, null, indentation)\n    }\n\n    // remove domain and timestamp from source files\n    // and resolve base path / absolute path urls into absolute path\n    var msg = input.replace(URL_REGEXP, function (_, prefix, path, __, ___, line, ____, column) {\n      // Find the file using basePath + path, but use the more readable path down below.\n      var file = findFile(prefix === 'base/' ? basePath + '/' + path : path)\n\n      if (file && file.sourceMap && line) {\n        line = parseInt(line || '0', 10)\n\n        column = parseInt(column, 10)\n\n        // When no column is given and we default to 0, it doesn't make sense to only search for smaller\n        // or equal columns in the sourcemap, let's search for equal or greater columns.\n        var bias = column ? SourceMapConsumer.GREATEST_LOWER_BOUND : SourceMapConsumer.LEAST_UPPER_BOUND\n\n        try {\n          var original = getSourceMapConsumer(file.sourceMap)\n            .originalPositionFor({line: line, column: (column || 0), bias: bias})\n\n          // Source maps often only have a local file name, resolve to turn into a full path if\n          // the path is not absolute yet.\n          var sourcePath = resolve(path, original.source)\n          var formattedColumn = column ? util.format(':%s', column) : ''\n          return util.format('%s:%d:%d <- %s:%d%s', sourcePath, original.line, original.column,\n              path, line, formattedColumn)\n        } catch (e) {\n          log.warn('SourceMap position not found for trace: %s', msg)\n          // Fall back to non-source-mapped formatting.\n        }\n      }\n\n      var result = path + (line ? ':' + line : '') + (column ? ':' + column : '')\n      return result || prefix\n    })\n\n    // indent every line\n    if (indentation) {\n      msg = indentation + msg.replace(/\\n/g, '\\n' + indentation)\n    }\n\n    // allow the user to format the error\n    if (config.formatError) {\n      return config.formatError(msg)\n    }\n\n    return msg + '\\n'\n  }\n}\n\nvar createReporters = function (names, config, emitter, injector) {\n  var errorFormatter = createErrorFormatter(config, emitter, SourceMapConsumer)\n  var reporters = []\n\n  // TODO(vojta): instantiate all reporters through DI\n  names.forEach(function (name) {\n    if (['dots', 'progress'].indexOf(name) !== -1) {\n      var Cls = require('./reporters/' + name)\n      var ClsColor = require('./reporters/' + name + '_color')\n      reporters.push(new Cls(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions))\n      return reporters.push(new ClsColor(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions))\n    }\n\n    var locals = {\n      baseReporterDecorator: ['factory', baseReporterDecoratorFactory],\n      formatError: ['value', errorFormatter]\n    }\n\n    try {\n      log.debug('Trying to load reporter: %s', name)\n      reporters.push(injector.createChild([locals], ['reporter:' + name]).get('reporter:' + name))\n    } catch (e) {\n      if (e.message.indexOf('No provider for \"reporter:' + name + '\"') !== -1) {\n        log.error('Can not load reporter \"%s\", it is not registered!\\n  ' +\n          'Perhaps you are missing some plugin?', name)\n      } else {\n        log.error('Can not load \"%s\"!\\n  ' + e.stack, name)\n      }\n      emitter.emit('load_error', 'reporter', name)\n      return\n    }\n    var colorName = name + '_color'\n    if (names.indexOf(colorName) !== -1) {\n      return\n    }\n    try {\n      log.debug('Trying to load color-version of reporter: %s (%s)', name, colorName)\n      reporters.push(injector.createChild([locals], ['reporter:' + name + '_color']).get('reporter:' + name))\n    } catch (e) {\n      log.debug('Couldn\\'t load color-version.')\n    }\n  })\n\n  // bind all reporters\n  reporters.forEach(function (reporter) {\n    emitter.bind(reporter)\n  })\n\n  return new MultiReporter(reporters)\n}\n\ncreateReporters.$inject = [\n  'config.reporters',\n  'config',\n  'emitter',\n  'injector'\n]\n\n// PUBLISH\nexports.createReporters = createReporters\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/reporters/multi.js":"var helper = require('../helper')\n\nvar MultiReporter = function (reporters) {\n  this.addAdapter = function (adapter) {\n    reporters.forEach(function (reporter) {\n      reporter.adapters.push(adapter)\n    })\n  }\n\n  this.removeAdapter = function (adapter) {\n    reporters.forEach(function (reporter) {\n      helper.arrayRemove(reporter.adapters, adapter)\n    })\n  }\n}\n\n// PUBLISH\nmodule.exports = MultiReporter\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/reporters/base.js":"var util = require('util')\n\nvar constants = require('../constants')\nvar helper = require('../helper')\n\nvar BaseReporter = function (formatError, reportSlow, useColors, browserConsoleLogOptions, adapter) {\n  this.adapters = [adapter || process.stdout.write.bind(process.stdout)]\n\n  this.onRunStart = function () {\n    this._browsers = []\n  }\n\n  this.onBrowserStart = function (browser) {\n    this._browsers.push(browser)\n  }\n\n  this.renderBrowser = function (browser) {\n    var results = browser.lastResult\n    var totalExecuted = results.success + results.failed\n    var msg = util.format('%s: Executed %d of %d', browser, totalExecuted, results.total)\n\n    if (results.failed) {\n      msg += util.format(this.X_FAILED, results.failed)\n    }\n\n    if (results.skipped) {\n      msg += util.format(' (skipped %d)', results.skipped)\n    }\n\n    if (browser.isReady) {\n      if (results.disconnected) {\n        msg += this.FINISHED_DISCONNECTED\n      } else if (results.error) {\n        msg += this.FINISHED_ERROR\n      } else if (!results.failed) {\n        msg += this.FINISHED_SUCCESS\n      }\n\n      msg += util.format(' (%s / %s)', helper.formatTimeInterval(results.totalTime),\n        helper.formatTimeInterval(results.netTime))\n    }\n\n    return msg\n  }\n\n  this.renderBrowser = this.renderBrowser.bind(this)\n\n  this.write = function () {\n    var msg = util.format.apply(null, Array.prototype.slice.call(arguments))\n    var self = this\n    this.adapters.forEach(function (adapter) {\n      if (!helper.isDefined(adapter.colors)) {\n        adapter.colors = useColors\n      }\n      if (!helper.isDefined(self.EXCLUSIVELY_USE_COLORS) || adapter.colors === self.EXCLUSIVELY_USE_COLORS) {\n        return adapter(msg)\n      }\n    })\n  }\n\n  this.writeCommonMsg = this.write\n\n  this.onBrowserError = function (browser, error) {\n    this.writeCommonMsg(util.format(this.ERROR, browser) + formatError(error, '  '))\n  }\n\n  this.onBrowserLog = function (browser, log, type) {\n    if (!browserConsoleLogOptions || !browserConsoleLogOptions.terminal) return\n    type = type.toUpperCase()\n    if (browserConsoleLogOptions.level) {\n      var logPriority = constants.LOG_PRIORITIES.indexOf(browserConsoleLogOptions.level.toUpperCase())\n      if (constants.LOG_PRIORITIES.indexOf(type) > logPriority) return\n    }\n    if (!helper.isString(log)) {\n      // TODO(vojta): change util to new syntax (config object)\n      log = util.inspect(log, false, undefined, this.USE_COLORS)\n    }\n    if (this._browsers && this._browsers.length === 1) {\n      this.writeCommonMsg(util.format(this.LOG_SINGLE_BROWSER, type, log))\n    } else {\n      this.writeCommonMsg(util.format(this.LOG_MULTI_BROWSER, browser, type, log))\n    }\n  }\n\n  this.onSpecComplete = function (browser, result) {\n    if (result.skipped) {\n      this.specSkipped(browser, result)\n    } else if (result.success) {\n      this.specSuccess(browser, result)\n    } else {\n      this.specFailure(browser, result)\n    }\n\n    if (reportSlow && result.time > reportSlow) {\n      var specName = result.suite.join(' ') + ' ' + result.description\n      var time = helper.formatTimeInterval(result.time)\n\n      this.writeCommonMsg(util.format(this.SPEC_SLOW, browser, time, specName))\n    }\n  }\n\n  this.specSuccess = this.specSkipped = function () {\n  }\n\n  this.specFailure = function (browser, result) {\n    var specName = result.suite.join(' ') + ' ' + result.description\n    var msg = util.format(this.SPEC_FAILURE, browser, specName)\n\n    result.log.forEach(function (log) {\n      msg += formatError(log, '\\t')\n    })\n\n    this.writeCommonMsg(msg)\n  }\n\n  this.onRunComplete = function (browsers, results) {\n    if (browsers.length > 1 && !results.error && !results.disconnected) {\n      if (!results.failed) {\n        this.write(this.TOTAL_SUCCESS, results.success)\n      } else {\n        this.write(this.TOTAL_FAILED, results.failed, results.success)\n      }\n    }\n  }\n\n  this.USE_COLORS = false\n  this.EXCLUSIVELY_USE_COLORS = undefined\n  this.LOG_SINGLE_BROWSER = '%s: %s\\n'\n  this.LOG_MULTI_BROWSER = '%s %s: %s\\n'\n\n  this.SPEC_FAILURE = '%s %s FAILED' + '\\n'\n  this.SPEC_SLOW = '%s SLOW %s: %s\\n'\n  this.ERROR = '%s ERROR\\n'\n\n  this.FINISHED_ERROR = ' ERROR'\n  this.FINISHED_SUCCESS = ' SUCCESS'\n  this.FINISHED_DISCONNECTED = ' DISCONNECTED'\n\n  this.X_FAILED = ' (%d FAILED)'\n\n  this.TOTAL_SUCCESS = 'TOTAL: %d SUCCESS\\n'\n  this.TOTAL_FAILED = 'TOTAL: %d FAILED, %d SUCCESS\\n'\n}\n\nBaseReporter.decoratorFactory = function (formatError, reportSlow, useColors, browserConsoleLogOptions) {\n  return function (self) {\n    BaseReporter.call(self, formatError, reportSlow, useColors, browserConsoleLogOptions)\n  }\n}\n\nBaseReporter.decoratorFactory.$inject = [\n  'formatError',\n  'config.reportSlowerThan',\n  'config.colors',\n  'config.browserConsoleLogOptions'\n]\n\n// PUBLISH\nmodule.exports = BaseReporter\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/executor.js":"var log = require('./logger').create()\n\nvar Executor = function (capturedBrowsers, config, emitter) {\n  var self = this\n  var executionScheduled = false\n  var pendingCount = 0\n  var runningBrowsers\n\n  var schedule = function () {\n    var nonReady = []\n\n    if (!capturedBrowsers.length) {\n      log.warn('No captured browser, open %s//%s:%s%s', config.protocol, config.hostname,\n        config.port, config.urlRoot)\n      return false\n    }\n\n    if (capturedBrowsers.areAllReady(nonReady)) {\n      log.debug('All browsers are ready, executing')\n      log.debug('Captured %s browsers', capturedBrowsers.length)\n      executionScheduled = false\n      capturedBrowsers.clearResults()\n      capturedBrowsers.setAllToExecuting()\n      pendingCount = capturedBrowsers.length\n      runningBrowsers = capturedBrowsers.clone()\n      emitter.emit('run_start', runningBrowsers)\n      self.socketIoSockets.emit('execute', config.client)\n      return true\n    }\n\n    log.info('Delaying execution, these browsers are not ready: ' + nonReady.join(', '))\n    executionScheduled = true\n    return false\n  }\n\n  this.schedule = schedule\n\n  this.onRunComplete = function () {\n    if (executionScheduled) {\n      schedule()\n    }\n  }\n\n  this.onBrowserComplete = function () {\n    pendingCount--\n\n    if (!pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(function () {\n        emitter.emit('run_complete', runningBrowsers, runningBrowsers.getResults())\n      }, 0)\n    }\n  }\n\n  // bind all the events\n  emitter.bind(this)\n}\n\nmodule.exports = Executor\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/browser.js":"var helper = require('./helper')\nvar events = require('./events')\nvar logger = require('./logger')\n\nvar Result = require('./browser_result')\n\n// The browser is ready to execute tests.\nvar READY = 1\n\n// The browser is executing the tests.\nvar EXECUTING = 2\n\n// The browser is not executing, but temporarily disconnected (waiting for reconnecting).\nvar READY_DISCONNECTED = 3\n\n// The browser is executing the tests, but temporarily disconnect (waiting for reconnecting).\nvar EXECUTING_DISCONNECTED = 4\n\n// The browser got permanently disconnected (being removed from the collection and destroyed).\nvar DISCONNECTED = 5\n\nvar Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,\n  /* config.browserDisconnectTimeout */ disconnectDelay,\n  /* config.browserNoActivityTimeout */ noActivityTimeout) {\n  var name = helper.browserFullNameToShort(fullName)\n  var log = logger.create(name)\n  var activeSockets = [socket]\n  var activeSocketsIds = function () {\n    return activeSockets.map(function (s) {\n      return s.id\n    }).join(', ')\n  }\n\n  var self = this\n  var pendingDisconnect\n  var disconnect = function (reason) {\n    self.state = DISCONNECTED\n    self.disconnectsCount++\n    log.warn('Disconnected (%d times)' + (reason || ''), self.disconnectsCount)\n    emitter.emit('browser_error', self, 'Disconnected' + reason)\n    collection.remove(self)\n  }\n\n  var noActivityTimeoutId\n  var refreshNoActivityTimeout = noActivityTimeout ? function () {\n    clearNoActivityTimeout()\n    noActivityTimeoutId = timer.setTimeout(function () {\n      self.lastResult.totalTimeEnd()\n      self.lastResult.disconnected = true\n      disconnect(', because no message in ' + noActivityTimeout + ' ms.')\n      emitter.emit('browser_complete', self)\n    }, noActivityTimeout)\n  } : function () {}\n\n  var clearNoActivityTimeout = noActivityTimeout ? function () {\n    if (noActivityTimeoutId) {\n      timer.clearTimeout(noActivityTimeoutId)\n      noActivityTimeoutId = null\n    }\n  } : function () {}\n\n  this.id = id\n  this.fullName = fullName\n  this.name = name\n  this.state = READY\n  this.lastResult = new Result()\n  this.disconnectsCount = 0\n\n  this.init = function () {\n    collection.add(this)\n\n    events.bindAll(this, socket)\n\n    log.info('Connected on socket %s with id %s', socket.id, id)\n\n    // TODO(vojta): move to collection\n    emitter.emit('browsers_change', collection)\n\n    emitter.emit('browser_register', this)\n  }\n\n  this.isReady = function () {\n    return this.state === READY\n  }\n\n  this.toString = function () {\n    return this.name\n  }\n\n  this.onKarmaError = function (error) {\n    if (this.isReady()) {\n      return\n    }\n\n    this.lastResult.error = true\n    emitter.emit('browser_error', this, error)\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onInfo = function (info) {\n    if (this.isReady()) {\n      return\n    }\n\n    // TODO(vojta): remove\n    if (helper.isDefined(info.dump)) {\n      emitter.emit('browser_log', this, info.dump, 'dump')\n    }\n\n    if (helper.isDefined(info.log)) {\n      emitter.emit('browser_log', this, info.log, info.type)\n    }\n\n    if (\n      !helper.isDefined(info.log) &&\n      !helper.isDefined(info.dump)\n    ) {\n      emitter.emit('browser_info', this, info)\n    }\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onStart = function (info) {\n    this.lastResult = new Result()\n    this.lastResult.total = info.total\n\n    if (info.total === null) {\n      log.warn('Adapter did not report total number of specs.')\n    }\n\n    emitter.emit('browser_start', this, info)\n    refreshNoActivityTimeout()\n  }\n\n  this.onComplete = function (result) {\n    if (this.isReady()) {\n      return\n    }\n\n    this.state = READY\n    this.lastResult.totalTimeEnd()\n\n    if (!this.lastResult.success) {\n      this.lastResult.error = true\n    }\n\n    emitter.emit('browsers_change', collection)\n    emitter.emit('browser_complete', this, result)\n\n    clearNoActivityTimeout()\n  }\n\n  this.onDisconnect = function (_, disconnectedSocket) {\n    activeSockets.splice(activeSockets.indexOf(disconnectedSocket), 1)\n\n    if (activeSockets.length) {\n      log.debug('Disconnected %s, still have %s', disconnectedSocket.id, activeSocketsIds())\n      return\n    }\n\n    if (this.state === READY) {\n      disconnect()\n    } else if (this.state === EXECUTING) {\n      log.debug('Disconnected during run, waiting %sms for reconnecting.', disconnectDelay)\n      this.state = EXECUTING_DISCONNECTED\n\n      pendingDisconnect = timer.setTimeout(function () {\n        self.lastResult.totalTimeEnd()\n        self.lastResult.disconnected = true\n        disconnect()\n        emitter.emit('browser_complete', self)\n      }, disconnectDelay)\n\n      clearNoActivityTimeout()\n    }\n  }\n\n  this.reconnect = function (newSocket) {\n    if (this.state === EXECUTING_DISCONNECTED) {\n      this.state = EXECUTING\n      log.debug('Reconnected on %s.', newSocket.id)\n    } else if (this.state === EXECUTING || this.state === READY) {\n      log.debug('New connection %s (already have %s)', newSocket.id, activeSocketsIds())\n    } else if (this.state === DISCONNECTED) {\n      this.state = READY\n      log.info('Connected on socket %s with id %s', newSocket.id, this.id)\n      collection.add(this)\n\n      // TODO(vojta): move to collection\n      emitter.emit('browsers_change', collection)\n\n      emitter.emit('browser_register', this)\n    }\n\n    var exists = activeSockets.some(function (s) {\n      return s.id === newSocket.id\n    })\n    if (!exists) {\n      activeSockets.push(newSocket)\n      events.bindAll(this, newSocket)\n    }\n\n    if (pendingDisconnect) {\n      timer.clearTimeout(pendingDisconnect)\n    }\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onResult = function (result) {\n    if (result.length) {\n      return result.forEach(this.onResult, this)\n    }\n\n    // ignore - probably results from last run (after server disconnecting)\n    if (this.isReady()) {\n      return\n    }\n\n    this.lastResult.add(result)\n\n    emitter.emit('spec_complete', this, result)\n    refreshNoActivityTimeout()\n  }\n\n  this.serialize = function () {\n    return {\n      id: this.id,\n      name: this.name,\n      isReady: this.state === READY\n    }\n  }\n\n  this.execute = function (config) {\n    activeSockets.forEach(function (socket) {\n      socket.emit('execute', config)\n    })\n\n    this.state = EXECUTING\n    refreshNoActivityTimeout()\n  }\n}\n\nBrowser.STATE_READY = READY\nBrowser.STATE_EXECUTING = EXECUTING\nBrowser.STATE_READY_DISCONNECTED = READY_DISCONNECTED\nBrowser.STATE_EXECUTING_DISCONNECTED = EXECUTING_DISCONNECTED\nBrowser.STATE_DISCONNECTED = DISCONNECTED\n\nmodule.exports = Browser\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/browser_result.js":"var Result = function () {\n  var startTime = Date.now()\n\n  this.total = this.skipped = this.failed = this.success = 0\n  this.netTime = this.totalTime = 0\n  this.disconnected = this.error = false\n\n  this.totalTimeEnd = function () {\n    this.totalTime = Date.now() - startTime\n  }\n\n  this.add = function (result) {\n    if (result.skipped) {\n      this.skipped++\n    } else if (result.success) {\n      this.success++\n    } else {\n      this.failed++\n    }\n\n    this.netTime += result.time\n  }\n}\n\nmodule.exports = Result\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/browser_collection.js":"var EXECUTING = require('./browser').STATE_EXECUTING\nvar Result = require('./browser_result')\n\nvar Collection = function (emitter, browsers) {\n  browsers = browsers || []\n\n  this.add = function (browser) {\n    browsers.push(browser)\n    emitter.emit('browsers_change', this)\n  }\n\n  this.remove = function (browser) {\n    var index = browsers.indexOf(browser)\n\n    if (index === -1) {\n      return false\n    }\n\n    browsers.splice(index, 1)\n    emitter.emit('browsers_change', this)\n\n    return true\n  }\n\n  this.getById = function (browserId) {\n    for (var i = 0; i < browsers.length; i++) {\n      if (browsers[i].id === browserId) {\n        return browsers[i]\n      }\n    }\n\n    return null\n  }\n\n  this.setAllToExecuting = function () {\n    browsers.forEach(function (browser) {\n      browser.state = EXECUTING\n    })\n\n    emitter.emit('browsers_change', this)\n  }\n\n  this.areAllReady = function (nonReadyList) {\n    nonReadyList = nonReadyList || []\n\n    browsers.forEach(function (browser) {\n      if (!browser.isReady()) {\n        nonReadyList.push(browser)\n      }\n    })\n\n    return nonReadyList.length === 0\n  }\n\n  this.serialize = function () {\n    return browsers.map(function (browser) {\n      return browser.serialize()\n    })\n  }\n\n  this.getResults = function () {\n    var results = browsers.reduce(function (previous, current) {\n      previous.success += current.lastResult.success\n      previous.failed += current.lastResult.failed\n      previous.error = previous.error || current.lastResult.error\n      previous.disconnected = previous.disconnected || current.lastResult.disconnected\n      return previous\n    }, {success: 0, failed: 0, error: false, disconnected: false, exitCode: 0})\n\n    // compute exit status code\n    results.exitCode = results.failed || results.error || results.disconnected ? 1 : 0\n\n    return results\n  }\n\n  // TODO(vojta): can we remove this? (we clear the results per browser in onBrowserStart)\n  this.clearResults = function () {\n    browsers.forEach(function (browser) {\n      browser.lastResult = new Result()\n    })\n  }\n\n  this.clone = function () {\n    return new Collection(emitter, browsers.slice())\n  }\n\n  // Array APIs\n  this.map = function (callback, context) {\n    return browsers.map(callback, context)\n  }\n\n  this.forEach = function (callback, context) {\n    return browsers.forEach(callback, context)\n  }\n\n  // this.length\n  Object.defineProperty(this, 'length', {\n    get: function () {\n      return browsers.length\n    }\n  })\n}\nCollection.$inject = ['emitter']\n\nmodule.exports = Collection\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/emitter_wrapper.js":"function EmitterWrapper (emitter) {\n  this.listeners = {}\n  this.emitter = emitter\n}\n\nEmitterWrapper.prototype.addListener = EmitterWrapper.prototype.on = function (event, listener) {\n  this.emitter.addListener(event, listener)\n\n  if (!this.listeners.hasOwnProperty(event)) {\n    this.listeners[event] = []\n  }\n\n  this.listeners[event].push(listener)\n\n  return this\n}\n\nEmitterWrapper.prototype.removeAllListeners = function (event) {\n  var events = event ? [event] : Object.keys(this.listeners)\n  var self = this\n  events.forEach(function (event) {\n    self.listeners[event].forEach(function (listener) {\n      self.emitter.removeListener(event, listener)\n    })\n    delete self.listeners[event]\n  })\n\n  return this\n}\n\nmodule.exports = EmitterWrapper\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/runner.js":"var http = require('http')\n\nvar constant = require('./constants')\nvar helper = require('./helper')\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar log = logger.create('runner')\n\nvar parseExitCode = function (buffer, defaultCode, failOnEmptyTestSuite) {\n  var tailPos = buffer.length - Buffer.byteLength(constant.EXIT_CODE) - 2\n\n  if (tailPos < 0) {\n    return {exitCode: defaultCode, buffer: buffer}\n  }\n\n  // tail buffer which might contain the message\n  var tail = buffer.slice(tailPos)\n  var tailStr = tail.toString()\n  if (tailStr.substr(0, tailStr.length - 2) === constant.EXIT_CODE) {\n    var emptyInt = parseInt(tailStr.substr(-2, 1), 10)\n    var exitCode = parseInt(tailStr.substr(-1), 10)\n    if (failOnEmptyTestSuite === false && emptyInt === 0) {\n      log.warn('Test suite was empty.')\n      exitCode = 0\n    }\n    return {exitCode: exitCode, buffer: buffer.slice(0, tailPos)}\n  }\n\n  return {exitCode: defaultCode, buffer: buffer}\n}\n\n// TODO(vojta): read config file (port, host, urlRoot)\nexports.run = function (config, done) {\n  config = config || {}\n\n  logger.setupFromConfig(config)\n\n  done = helper.isFunction(done) ? done : process.exit\n  config = cfg.parseConfig(config.configFile, config)\n\n  var exitCode = 1\n  var options = {\n    hostname: config.hostname,\n    path: config.urlRoot + 'run',\n    port: config.port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }\n\n  var request = http.request(options, function (response) {\n    response.on('data', function (buffer) {\n      var parsedResult = parseExitCode(buffer, exitCode, config.failOnEmptyTestSuite)\n      exitCode = parsedResult.exitCode\n      process.stdout.write(parsedResult.buffer)\n    })\n\n    response.on('end', function () {\n      done(exitCode)\n    })\n  })\n\n  request.on('error', function (e) {\n    if (e.code === 'ECONNREFUSED') {\n      log.error('There is no server listening on port %d', options.port)\n      done(1, e.code)\n    } else {\n      throw e\n    }\n  })\n\n  request.end(JSON.stringify({\n    args: config.clientArgs,\n    removedFiles: config.removedFiles,\n    changedFiles: config.changedFiles,\n    addedFiles: config.addedFiles,\n    refresh: config.refresh,\n    colors: config.colors\n  }))\n}\n","/home/travis/build/npmtest/node-npmtest-karma/karma/lib/stopper.js":"var http = require('http')\n\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar helper = require('./helper')\n\nexports.stop = function (config, done) {\n  config = config || {}\n  logger.setupFromConfig(config)\n  done = helper.isFunction(done) ? done : process.exit\n  var log = logger.create('stopper')\n  config = cfg.parseConfig(config.configFile, config)\n\n  var options = {\n    hostname: config.hostname,\n    path: config.urlRoot + 'stop',\n    port: config.port,\n    method: 'GET'\n  }\n\n  var request = http.request(options)\n\n  request.on('response', function (response) {\n    if (response.statusCode !== 200) {\n      log.error('Server returned status code: ' + response.statusCode)\n      done(1)\n      return\n    }\n\n    log.info('Server stopped.')\n    done(0)\n  })\n\n  request.on('error', function (e) {\n    if (e.code === 'ECONNREFUSED') {\n      log.error('There is no server listening on port %d', options.port)\n      done(1, e.code)\n    } else {\n      throw e\n    }\n  })\n  request.end()\n}\n"}