{"/home/travis/build/npmtest/node-npmtest-karma/test.js":"/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/lib.npmtest_karma.js":"/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_karma = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_karma = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-karma && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_karma */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_karma\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_karma.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_karma.rollup.js'] =\n            local.assetsDict['/assets.npmtest_karma.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_karma.__dirname + '/lib.npmtest_karma.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/index.js":"// index module\n\nvar constants = require('./constants')\nvar Server = require('./server')\nvar runner = require('./runner')\nvar stopper = require('./stopper')\nvar launcher = require('./launcher')\nvar cfg = require('./config')\n\n// TODO: remove in 1.0\nvar oldServer = {\n  start: function (cliOptions, done) {\n    console.error('WARN `start` method is deprecated since 0.13. It will be removed in 0.14. Please use \\n' +\n      '  server = new Server(config, [done])\\n' +\n      '  server.start()\\n' +\n      'instead.')\n    var server = new Server(cliOptions, done)\n    server.start()\n  }\n}\n\nmodule.exports = {\n  constants: constants,\n  VERSION: constants.VERSION,\n  Server: Server,\n  runner: runner,\n  stopper: stopper,\n  launcher: launcher,\n  config: { parseConfig: cfg.parseConfig }, // lets start with only opening up the `parseConfig` api\n  server: oldServer\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/constants.js":"var fs = require('graceful-fs')\nvar path = require('path')\n\nvar pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '/../package.json')).toString())\n\nexports.VERSION = pkg.version\n\nexports.DEFAULT_PORT = process.env.PORT || 9876\nexports.DEFAULT_HOSTNAME = process.env.IP || 'localhost'\nexports.DEFAULT_LISTEN_ADDR = process.env.LISTEN_ADDR || '0.0.0.0'\n\n// log levels\nexports.LOG_DISABLE = 'OFF'\nexports.LOG_ERROR = 'ERROR'\nexports.LOG_WARN = 'WARN'\nexports.LOG_INFO = 'INFO'\nexports.LOG_DEBUG = 'DEBUG'\nexports.LOG_LOG = 'LOG'\nexports.LOG_PRIORITIES = [\n  exports.LOG_DISABLE,\n  exports.LOG_ERROR,\n  exports.LOG_WARN,\n  exports.LOG_INFO,\n  exports.LOG_DEBUG,\n  exports.LOG_LOG\n]\n\n// Default patterns for the pattern layout.\nexports.COLOR_PATTERN = '%[%d{DATE}:%p [%c]: %]%m'\nexports.NO_COLOR_PATTERN = '%d{DATE}:%p [%c]: %m'\n\n// Default console appender\nexports.CONSOLE_APPENDER = {\n  type: 'console',\n  layout: {\n    type: 'pattern',\n    pattern: exports.COLOR_PATTERN\n  }\n}\n\nexports.EXIT_CODE = '\\x1FEXIT'\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/server.js":"var SocketIO = require('socket.io')\nvar di = require('di')\nvar util = require('util')\nvar Promise = require('bluebird')\nvar spawn = require('child_process').spawn\nvar tmp = require('tmp')\nvar fs = require('fs')\nvar path = require('path')\nvar root = global || window || this\n\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar constant = require('./constants')\nvar watcher = require('./watcher')\nvar plugin = require('./plugin')\n\nvar ws = require('./web-server')\nvar preprocessor = require('./preprocessor')\nvar Launcher = require('./launcher').Launcher\nvar FileList = require('./file-list')\nvar reporter = require('./reporter')\nvar helper = require('./helper')\nvar events = require('./events')\nvar EventEmitter = events.EventEmitter\nvar Executor = require('./executor')\nvar Browser = require('./browser')\nvar BrowserCollection = require('./browser_collection')\nvar EmitterWrapper = require('./emitter_wrapper')\nvar processWrapper = new EmitterWrapper(process)\n\nfunction createSocketIoServer (webServer, executor, config) {\n  var server = new SocketIO(webServer, {\n    // avoid destroying http upgrades from socket.io to get proxied websockets working\n    destroyUpgrade: false,\n    path: config.urlRoot + 'socket.io/',\n    transports: config.transports,\n    forceJSONP: config.forceJSONP\n  })\n\n  // hack to overcome circular dependency\n  executor.socketIoSockets = server.sockets\n\n  return server\n}\n\n// Constructor\nvar Server = function (cliOptions, done) {\n  EventEmitter.call(this)\n\n  logger.setupFromConfig(cliOptions)\n\n  this.log = logger.create()\n\n  this.loadErrors = []\n\n  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)\n\n  var modules = [{\n    helper: ['value', helper],\n    logger: ['value', logger],\n    done: ['value', done || process.exit],\n    emitter: ['value', this],\n    server: ['value', this],\n    launcher: ['type', Launcher],\n    config: ['value', config],\n    preprocess: ['factory', preprocessor.createPreprocessor],\n    fileList: ['type', FileList],\n    webServer: ['factory', ws.create],\n    socketServer: ['factory', createSocketIoServer],\n    executor: ['type', Executor],\n    // TODO(vojta): remove\n    customFileHandlers: ['value', []],\n    // TODO(vojta): remove, once karma-dart does not rely on it\n    customScriptTypes: ['value', []],\n    reporter: ['factory', reporter.createReporters],\n    capturedBrowsers: ['type', BrowserCollection],\n    args: ['value', {}],\n    timer: ['value', {\n      setTimeout: function () {\n        return setTimeout.apply(root, arguments)\n      },\n      clearTimeout: function (timeoutId) {\n        clearTimeout(timeoutId)\n      }\n    }]\n  }]\n\n  this._setUpLoadErrorListener()\n  // Load the plugins\n  modules = modules.concat(plugin.resolve(config.plugins, this))\n\n  this._injector = new di.Injector(modules)\n}\n\n// Inherit from events.EventEmitter\nutil.inherits(Server, EventEmitter)\n\n// Public Methods\n// --------------\n\n// Start the server\nServer.prototype.start = function () {\n  this._injector.invoke(this._start, this)\n}\n\n/**\n * Backward-compatibility with karma-intellij bundled with WebStorm.\n * Deprecated since version 0.13, to be removed in 0.14\n */\nServer.start = function (cliOptions, done) {\n  var server = new Server(cliOptions, done)\n  server.start()\n}\n\n// Get properties from the injector\n//\n// token - String\nServer.prototype.get = function (token) {\n  return this._injector.get(token)\n}\n\n// Force a refresh of the file list\nServer.prototype.refreshFiles = function () {\n  if (!this._fileList) return Promise.resolve()\n\n  return this._fileList.refresh()\n}\n\n// Private Methods\n// ---------------\n\nServer.prototype._start = function (config, launcher, preprocess, fileList,\n                                    capturedBrowsers, executor, done) {\n  var self = this\n  if (config.detached) {\n    this._detach(config, done)\n    return\n  }\n\n  self._fileList = fileList\n\n  config.frameworks.forEach(function (framework) {\n    self._injector.get('framework:' + framework)\n  })\n\n  var webServer = self._injector.get('webServer')\n  var socketServer = self._injector.get('socketServer')\n\n  // A map of launched browsers.\n  var singleRunDoneBrowsers = Object.create(null)\n\n  // Passing fake event emitter, so that it does not emit on the global,\n  // we don't care about these changes.\n  var singleRunBrowsers = new BrowserCollection(new EventEmitter())\n\n  // Some browsers did not get captured.\n  var singleRunBrowserNotCaptured = false\n\n  webServer.on('error', function (e) {\n    if (e.code === 'EADDRINUSE') {\n      self.log.warn('Port %d in use', config.port)\n      config.port++\n      webServer.listen(config.port, config.listenAddress)\n    } else {\n      throw e\n    }\n  })\n\n  var afterPreprocess = function () {\n    if (config.autoWatch) {\n      self._injector.invoke(watcher.watch)\n    }\n\n    webServer.listen(config.port, config.listenAddress, function () {\n      self.log.info('Karma v%s server started at %s//%s:%s%s', constant.VERSION,\n        config.protocol, config.listenAddress, config.port, config.urlRoot)\n\n      self.emit('listening', config.port)\n      if (config.browsers && config.browsers.length) {\n        self._injector.invoke(launcher.launch, launcher).forEach(function (browserLauncher) {\n          singleRunDoneBrowsers[browserLauncher.id] = false\n        })\n      }\n      var noLoadErrors = self.loadErrors.length\n      if (noLoadErrors > 0) {\n        self.log.error('Found %d load error%s', noLoadErrors, noLoadErrors === 1 ? '' : 's')\n        process.exitCode = 1\n        process.kill(process.pid, 'SIGINT')\n      }\n    })\n  }\n\n  fileList.refresh().then(afterPreprocess, afterPreprocess)\n\n  self.on('browsers_change', function () {\n    // TODO(vojta): send only to interested browsers\n    socketServer.sockets.emit('info', capturedBrowsers.serialize())\n  })\n\n  self.on('browser_register', function (browser) {\n    launcher.markCaptured(browser.id)\n\n    // TODO(vojta): This is lame, browser can get captured and then\n    // crash (before other browsers get captured).\n    if (launcher.areAllCaptured()) {\n      self.emit('browsers_ready')\n\n      if (config.autoWatch) {\n        executor.schedule()\n      }\n    }\n  })\n\n  if (config.browserConsoleLogOptions && config.browserConsoleLogOptions.path) {\n    var configLevel = config.browserConsoleLogOptions.level || 'debug'\n    var configFormat = config.browserConsoleLogOptions.format || '%b %T: %m'\n    var configPath = config.browserConsoleLogOptions.path\n    self.log.info('Writing browser console to file: %s', configPath)\n    var browserLogFile = fs.openSync(configPath, 'w+')\n    var levels = ['log', 'error', 'warn', 'info', 'debug']\n    self.on('browser_log', function (browser, message, level) {\n      if (levels.indexOf(level.toLowerCase()) > levels.indexOf(configLevel)) return\n      if (!helper.isString(message)) {\n        message = util.inspect(message, {showHidden: false, colors: false})\n      }\n      var logMap = {'%m': message, '%t': level.toLowerCase(), '%T': level.toUpperCase(), '%b': browser}\n      var logString = configFormat.replace(/%[mtTb]/g, function (m) {\n        return logMap[m]\n      })\n      self.log.debug('Writing browser console line: %s', logString)\n      fs.write(browserLogFile, logString + '\\n')\n    })\n  }\n\n  var EVENTS_TO_REPLY = ['start', 'info', 'karma_error', 'result', 'complete']\n  socketServer.sockets.on('connection', function (socket) {\n    self.log.debug('A browser has connected on socket ' + socket.id)\n\n    var replySocketEvents = events.bufferEvents(socket, EVENTS_TO_REPLY)\n\n    socket.on('complete', function (data, ack) {\n      ack()\n    })\n\n    socket.on('register', function (info) {\n      var newBrowser\n      var isRestart\n\n      if (info.id) {\n        newBrowser = capturedBrowsers.getById(info.id) || singleRunBrowsers.getById(info.id)\n      }\n\n      if (newBrowser) {\n        isRestart = newBrowser.state === Browser.STATE_DISCONNECTED\n        newBrowser.reconnect(socket)\n\n        // We are restarting a previously disconnected browser.\n        if (isRestart && config.singleRun) {\n          newBrowser.execute(config.client)\n        }\n      } else {\n        newBrowser = self._injector.createChild([{\n          id: ['value', info.id || null],\n          fullName: ['value', (helper.isDefined(info.displayName) ? info.displayName : info.name)],\n          socket: ['value', socket]\n        }]).instantiate(Browser)\n\n        newBrowser.init()\n\n        // execute in this browser immediately\n        if (config.singleRun) {\n          newBrowser.execute(config.client)\n          singleRunBrowsers.add(newBrowser)\n        }\n      }\n\n      replySocketEvents()\n    })\n  })\n\n  var emitRunCompleteIfAllBrowsersDone = function () {\n    // all browsers done\n    var isDone = Object.keys(singleRunDoneBrowsers).reduce(function (isDone, id) {\n      return isDone && singleRunDoneBrowsers[id]\n    }, true)\n\n    if (isDone) {\n      var results = singleRunBrowsers.getResults()\n      if (singleRunBrowserNotCaptured) {\n        results.exitCode = 1\n      } else if (results.success + results.failed === 0 && !config.failOnEmptyTestSuite) {\n        results.exitCode = 0\n        self.log.warn('Test suite was empty.')\n      }\n      self.emit('run_complete', singleRunBrowsers, results)\n    }\n  }\n\n  self.on('browser_complete', function (completedBrowser) {\n    if (completedBrowser.lastResult.disconnected &&\n      completedBrowser.disconnectsCount <= config.browserDisconnectTolerance) {\n      self.log.info('Restarting %s (%d of %d attempts)', completedBrowser.name,\n        completedBrowser.disconnectsCount, config.browserDisconnectTolerance)\n\n      if (!launcher.restart(completedBrowser.id)) {\n        self.emit('browser_restart_failure', completedBrowser)\n      }\n    } else {\n      self.emit('browser_complete_with_no_more_retries', completedBrowser)\n    }\n  })\n\n  if (config.singleRun) {\n    self.on('browser_restart_failure', function (completedBrowser) {\n      singleRunDoneBrowsers[completedBrowser.id] = true\n      emitRunCompleteIfAllBrowsersDone()\n    })\n    self.on('browser_complete_with_no_more_retries', function (completedBrowser) {\n      singleRunDoneBrowsers[completedBrowser.id] = true\n\n      if (launcher.kill(completedBrowser.id)) {\n        // workaround to supress \"disconnect\" warning\n        completedBrowser.state = Browser.STATE_DISCONNECTED\n      }\n\n      emitRunCompleteIfAllBrowsersDone()\n    })\n\n    self.on('browser_process_failure', function (browserLauncher) {\n      singleRunDoneBrowsers[browserLauncher.id] = true\n      singleRunBrowserNotCaptured = true\n\n      emitRunCompleteIfAllBrowsersDone()\n    })\n\n    self.on('run_complete', function (browsers, results) {\n      self.log.debug('Run complete, exiting.')\n      disconnectBrowsers(results.exitCode)\n    })\n\n    self.emit('run_start', singleRunBrowsers)\n  }\n\n  if (config.autoWatch) {\n    self.on('file_list_modified', function () {\n      self.log.debug('List of files has changed, trying to execute')\n      if (config.restartOnFileChange) {\n        socketServer.sockets.emit('stop')\n      }\n      executor.schedule()\n    })\n  }\n\n  var webServerCloseTimeout = 3000\n  var disconnectBrowsers = function (code) {\n    // Slightly hacky way of removing disconnect listeners\n    // to suppress \"browser disconnect\" warnings\n    // TODO(vojta): change the client to not send the event (if disconnected by purpose)\n    var sockets = socketServer.sockets.sockets\n\n    Object.keys(sockets).forEach(function (id) {\n      var socket = sockets[id]\n      socket.removeAllListeners('disconnect')\n      if (!socket.disconnected) {\n        // Disconnect asynchronously. Socket.io mutates the `sockets.sockets` array\n        // underneath us so this would skip every other browser/socket.\n        process.nextTick(socket.disconnect.bind(socket))\n      }\n    })\n\n    var removeAllListenersDone = false\n    var removeAllListeners = function () {\n      // make sure we don't execute cleanup twice\n      if (removeAllListenersDone) {\n        return\n      }\n      removeAllListenersDone = true\n      webServer.removeAllListeners()\n      processWrapper.removeAllListeners()\n      done(code || 0)\n    }\n\n    self.emitAsync('exit').then(function () {\n      // don't wait forever on webServer.close() because\n      // pending client connections prevent it from closing.\n      var closeTimeout = setTimeout(removeAllListeners, webServerCloseTimeout)\n\n      // shutdown the server...\n      webServer.close(function () {\n        clearTimeout(closeTimeout)\n        removeAllListeners()\n      })\n    })\n  }\n\n  processWrapper.on('SIGINT', function () {\n    disconnectBrowsers(process.exitCode)\n  })\n  processWrapper.on('SIGTERM', disconnectBrowsers)\n\n  // Handle all unhandled exceptions, so we don't just exit but\n  // disconnect the browsers before exiting.\n  processWrapper.on('uncaughtException', function (error) {\n    self.log.error(error)\n    disconnectBrowsers(1)\n  })\n}\n\nServer.prototype._setUpLoadErrorListener = function () {\n  var self = this\n  self.on('load_error', function (type, name) {\n    self.log.debug('Registered a load error of type %s with name %s', type, name)\n    self.loadErrors.push([type, name])\n  })\n}\n\nServer.prototype._detach = function (config, done) {\n  var log = this.log\n  var tmpFile = tmp.fileSync({keep: true})\n  log.info('Starting karma detached')\n  log.info('Run \"karma stop\" to stop the server.')\n  log.debug('Writing config to tmp-file %s', tmpFile.name)\n  config.detached = false\n  try {\n    fs.writeFileSync(tmpFile.name, JSON.stringify(config), 'utf8')\n  } catch (e) {\n    log.error(\"Couldn't write temporary configuration file\")\n    done(1)\n    return\n  }\n  var child = spawn(process.argv[0], [path.resolve(__dirname, '../lib/detached.js'), tmpFile.name], {\n    detached: true,\n    stdio: 'ignore'\n  })\n  child.unref()\n}\n\n// Export\n// ------\n\nmodule.exports = Server\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/config.js":"var path = require('path')\n\nvar logger = require('./logger')\nvar log = logger.create('config')\nvar helper = require('./helper')\nvar constant = require('./constants')\n\nvar _ = require('lodash')\n\nvar COFFEE_SCRIPT_AVAILABLE = false\nvar LIVE_SCRIPT_AVAILABLE = false\nvar TYPE_SCRIPT_AVAILABLE = false\n\n// Coffee is required here to enable config files written in coffee-script.\n// It's not directly used in this file.\ntry {\n  require('coffee-script').register()\n  COFFEE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\n// LiveScript is required here to enable config files written in LiveScript.\n// It's not directly used in this file.\ntry {\n  require('LiveScript')\n  LIVE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\ntry {\n  require('ts-node').register()\n  TYPE_SCRIPT_AVAILABLE = true\n} catch (e) {}\n\nvar Pattern = function (pattern, served, included, watched, nocache) {\n  this.pattern = pattern\n  this.served = helper.isDefined(served) ? served : true\n  this.included = helper.isDefined(included) ? included : true\n  this.watched = helper.isDefined(watched) ? watched : true\n  this.nocache = helper.isDefined(nocache) ? nocache : false\n  this.weight = helper.mmPatternWeight(pattern)\n}\n\nPattern.prototype.compare = function (other) {\n  return helper.mmComparePatternWeights(this.weight, other.weight)\n}\n\nvar UrlPattern = function (url) {\n  Pattern.call(this, url, false, true, false, false)\n}\n\nvar createPatternObject = function (pattern) {\n  if (pattern && helper.isString(pattern)) {\n    return helper.isUrlAbsolute(pattern) ? new UrlPattern(pattern) : new Pattern(pattern)\n  }\n\n  if (helper.isObject(pattern)) {\n    if (pattern.pattern && helper.isString(pattern.pattern)) {\n      return helper.isUrlAbsolute(pattern.pattern)\n        ? new UrlPattern(pattern.pattern)\n        : new Pattern(\n          pattern.pattern,\n          pattern.served,\n          pattern.included,\n          pattern.watched,\n          pattern.nocache)\n    }\n\n    log.warn('Invalid pattern %s!\\n\\tObject is missing \"pattern\" property.', pattern)\n    return new Pattern(null, false, false, false, false)\n  }\n\n  log.warn('Invalid pattern %s!\\n\\tExpected string or object with \"pattern\" property.', pattern)\n  return new Pattern(null, false, false, false, false)\n}\n\nvar normalizeUrl = function (url) {\n  if (url.charAt(0) !== '/') {\n    url = '/' + url\n  }\n\n  if (url.charAt(url.length - 1) !== '/') {\n    url = url + '/'\n  }\n\n  return url\n}\n\nvar normalizeUrlRoot = function (urlRoot) {\n  var normalizedUrlRoot = normalizeUrl(urlRoot)\n\n  if (normalizedUrlRoot !== urlRoot) {\n    log.warn('urlRoot normalized to \"%s\"', normalizedUrlRoot)\n  }\n\n  return normalizedUrlRoot\n}\n\nvar normalizeProxyPath = function (proxyPath) {\n  var normalizedProxyPath = normalizeUrl(proxyPath)\n\n  if (normalizedProxyPath !== proxyPath) {\n    log.warn('proxyPath normalized to \"%s\"', normalizedProxyPath)\n  }\n\n  return normalizedProxyPath\n}\n\nvar normalizeConfig = function (config, configFilePath) {\n  var basePathResolve = function (relativePath) {\n    if (helper.isUrlAbsolute(relativePath)) {\n      return relativePath\n    }\n\n    if (!helper.isDefined(config.basePath) || !helper.isDefined(relativePath)) {\n      return ''\n    }\n    return path.resolve(config.basePath, relativePath)\n  }\n\n  var createPatternMapper = function (resolve) {\n    return function (objectPattern) {\n      objectPattern.pattern = resolve(objectPattern.pattern)\n\n      return objectPattern\n    }\n  }\n\n  if (helper.isString(configFilePath)) {\n    // resolve basePath\n    config.basePath = path.resolve(path.dirname(configFilePath), config.basePath)\n\n    // always ignore the config file itself\n    config.exclude.push(configFilePath)\n  } else {\n    config.basePath = path.resolve(config.basePath || '.')\n  }\n\n  config.files = config.files.map(createPatternObject).map(createPatternMapper(basePathResolve))\n  config.exclude = config.exclude.map(basePathResolve)\n  config.customContextFile = config.customContextFile && basePathResolve(config.customContextFile)\n  config.customDebugFile = config.customDebugFile && basePathResolve(config.customDebugFile)\n  config.customClientContextFile = config.customClientContextFile && basePathResolve(config.customClientContextFile)\n\n  // normalize paths on windows\n  config.basePath = helper.normalizeWinPath(config.basePath)\n  config.files = config.files.map(createPatternMapper(helper.normalizeWinPath))\n  config.exclude = config.exclude.map(helper.normalizeWinPath)\n  config.customContextFile = helper.normalizeWinPath(config.customContextFile)\n  config.customDebugFile = helper.normalizeWinPath(config.customDebugFile)\n  config.customClientContextFile = helper.normalizeWinPath(config.customClientContextFile)\n\n  // normalize urlRoot\n  config.urlRoot = normalizeUrlRoot(config.urlRoot)\n\n  // normalize and default upstream proxy settings if given\n  if (config.upstreamProxy) {\n    var proxy = config.upstreamProxy\n    proxy.path = _.isUndefined(proxy.path) ? '/' : normalizeProxyPath(proxy.path)\n    proxy.hostname = _.isUndefined(proxy.hostname) ? 'localhost' : proxy.hostname\n    proxy.port = _.isUndefined(proxy.port) ? 9875 : proxy.port\n\n    // force protocol to end with ':'\n    proxy.protocol = (proxy.protocol || 'http').split(':')[0] + ':'\n    if (proxy.protocol.match(/https?:/) === null) {\n      log.warn('\"%s\" is not a supported upstream proxy protocol, defaulting to \"http:\"',\n        proxy.protocol)\n      proxy.protocol = 'http:'\n    }\n  }\n\n  // force protocol to end with ':'\n  config.protocol = (config.protocol || 'http').split(':')[0] + ':'\n  if (config.protocol.match(/https?:/) === null) {\n    log.warn('\"%s\" is not a supported protocol, defaulting to \"http:\"',\n      config.protocol)\n    config.protocol = 'http:'\n  }\n\n  if (config.proxies && config.proxies.hasOwnProperty(config.urlRoot)) {\n    log.warn('\"%s\" is proxied, you should probably change urlRoot to avoid conflicts',\n      config.urlRoot)\n  }\n\n  if (config.singleRun && config.autoWatch) {\n    log.debug('autoWatch set to false, because of singleRun')\n    config.autoWatch = false\n  }\n\n  if (config.runInParent) {\n    log.debug('useIframe set to false, because using runInParent')\n    config.useIframe = false\n  }\n\n  if (!config.singleRun && !config.useIframe && config.runInParent) {\n    log.debug('singleRun set to true, because using runInParent')\n    config.singleRun = true\n  }\n\n  if (helper.isString(config.reporters)) {\n    config.reporters = config.reporters.split(',')\n  }\n\n  if (config.client && config.client.args && !Array.isArray(config.client.args)) {\n    throw new Error('Invalid configuration: client.args must be an array of strings')\n  }\n\n  if (config.browsers && Array.isArray(config.browsers) === false) {\n    throw new TypeError('Invalid configuration: browsers option must be an array')\n  }\n\n  if (config.formatError && !helper.isFunction(config.formatError)) {\n    throw new TypeError('Invalid configuration: formatError option must be a function.')\n  }\n\n  if (config.processKillTimeout && !helper.isNumber(config.processKillTimeout)) {\n    throw new TypeError('Invalid configuration: processKillTimeout option must be a number.')\n  }\n\n  var defaultClient = config.defaultClient || {}\n  Object.keys(defaultClient).forEach(function (key) {\n    var option = config.client[key]\n    config.client[key] = helper.isDefined(option) ? option : defaultClient[key]\n  })\n\n  // normalize preprocessors\n  var preprocessors = config.preprocessors || {}\n  var normalizedPreprocessors = config.preprocessors = Object.create(null)\n\n  Object.keys(preprocessors).forEach(function (pattern) {\n    var normalizedPattern = helper.normalizeWinPath(basePathResolve(pattern))\n\n    normalizedPreprocessors[normalizedPattern] = helper.isString(preprocessors[pattern])\n      ? [preprocessors[pattern]] : preprocessors[pattern]\n  })\n\n  // define custom launchers/preprocessors/reporters - create an inlined plugin\n  var module = Object.create(null)\n  var hasSomeInlinedPlugin = false\n  var types = ['launcher', 'preprocessor', 'reporter']\n\n  types.forEach(function (type) {\n    var definitions = config['custom' + helper.ucFirst(type) + 's'] || {}\n\n    Object.keys(definitions).forEach(function (name) {\n      var definition = definitions[name]\n\n      if (!helper.isObject(definition)) {\n        return log.warn('Can not define %s %s. Definition has to be an object.', type, name)\n      }\n\n      if (!helper.isString(definition.base)) {\n        return log.warn('Can not define %s %s. Missing base %s.', type, name, type)\n      }\n\n      var token = type + ':' + definition.base\n      var locals = {\n        args: ['value', definition]\n      }\n\n      module[type + ':' + name] = ['factory', function (injector) {\n        var plugin = injector.createChild([locals], [token]).get(token)\n        if (type === 'launcher' && helper.isDefined(definition.displayName)) {\n          plugin.displayName = definition.displayName\n        }\n        return plugin\n      }]\n      hasSomeInlinedPlugin = true\n    })\n  })\n\n  if (hasSomeInlinedPlugin) {\n    config.plugins.push(module)\n  }\n\n  return config\n}\n\nvar Config = function () {\n  var config = this\n\n  this.LOG_DISABLE = constant.LOG_DISABLE\n  this.LOG_ERROR = constant.LOG_ERROR\n  this.LOG_WARN = constant.LOG_WARN\n  this.LOG_INFO = constant.LOG_INFO\n  this.LOG_DEBUG = constant.LOG_DEBUG\n\n  this.set = function (newConfig) {\n    _.merge(config, newConfig, function (obj, src) {\n      // Overwrite arrays to keep consistent with #283\n      if (_.isArray(src)) {\n        return src\n      }\n    })\n  }\n\n  // DEFAULT CONFIG\n  this.frameworks = []\n  this.protocol = 'http:'\n  this.port = constant.DEFAULT_PORT\n  this.listenAddress = constant.DEFAULT_LISTEN_ADDR\n  this.hostname = constant.DEFAULT_HOSTNAME\n  this.httpsServerConfig = {}\n  this.basePath = ''\n  this.files = []\n  this.browserConsoleLogOptions = {\n    level: 'debug',\n    format: '%b %T: %m',\n    terminal: true\n  }\n  this.customContextFile = null\n  this.customDebugFile = null\n  this.customClientContextFile = null\n  this.exclude = []\n  this.logLevel = constant.LOG_INFO\n  this.colors = true\n  this.autoWatch = true\n  this.autoWatchBatchDelay = 250\n  this.restartOnFileChange = false\n  this.usePolling = process.platform === 'darwin' || process.platform === 'linux'\n  this.reporters = ['progress']\n  this.singleRun = false\n  this.browsers = []\n  this.captureTimeout = 60000\n  this.proxies = {}\n  this.proxyValidateSSL = true\n  this.preprocessors = {}\n  this.urlRoot = '/'\n  this.upstreamProxy = undefined\n  this.reportSlowerThan = 0\n  this.loggers = [constant.CONSOLE_APPENDER]\n  this.transports = ['polling', 'websocket']\n  this.forceJSONP = false\n  this.plugins = ['karma-*']\n  this.defaultClient = this.client = {\n    args: [],\n    useIframe: true,\n    runInParent: false,\n    captureConsole: true,\n    clearContext: true\n  }\n  this.browserDisconnectTimeout = 2000\n  this.browserDisconnectTolerance = 0\n  this.browserNoActivityTimeout = 10000\n  this.processKillTimeout = 2000\n  this.concurrency = Infinity\n  this.failOnEmptyTestSuite = true\n  this.retryLimit = 2\n  this.detached = false\n  this.crossOriginAttribute = true\n}\n\nvar CONFIG_SYNTAX_HELP = '  module.exports = function(config) {\\n' +\n  '    config.set({\\n' +\n  '      // your config\\n' +\n  '    });\\n' +\n  '  };\\n'\n\nvar parseConfig = function (configFilePath, cliOptions) {\n  var configModule\n  if (configFilePath) {\n    log.debug('Loading config %s', configFilePath)\n\n    try {\n      configModule = require(configFilePath)\n      if (typeof configModule === 'object' && typeof configModule.default !== 'undefined') {\n        configModule = configModule.default\n      }\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(configFilePath) !== -1) {\n        log.error('File %s does not exist!', configFilePath)\n      } else {\n        log.error('Invalid config file!\\n  ' + e.stack)\n\n        var extension = path.extname(configFilePath)\n        if (extension === '.coffee' && !COFFEE_SCRIPT_AVAILABLE) {\n          log.error('You need to install CoffeeScript.\\n' +\n            '  npm install coffee-script --save-dev')\n        } else if (extension === '.ls' && !LIVE_SCRIPT_AVAILABLE) {\n          log.error('You need to install LiveScript.\\n' +\n            '  npm install LiveScript --save-dev')\n        } else if (extension === '.ts' && !TYPE_SCRIPT_AVAILABLE) {\n          log.error('You need to install TypeScript.\\n' +\n            '  npm install typescript ts-node --save-dev')\n        }\n      }\n      return process.exit(1)\n    }\n    if (!helper.isFunction(configModule)) {\n      log.error('Config file must export a function!\\n' + CONFIG_SYNTAX_HELP)\n      return process.exit(1)\n    }\n  } else {\n    log.debug('No config file specified.')\n    // if no config file path is passed, we define a dummy config module.\n    configModule = function () {}\n  }\n\n  var config = new Config()\n\n  // save and reset hostname and listenAddress so we can detect if the user\n  // changed them\n  var defaultHostname = config.hostname\n  config.hostname = null\n  var defaultListenAddress = config.listenAddress\n  config.listenAddress = null\n\n  // add the user's configuration in\n  config.set(cliOptions)\n\n  try {\n    configModule(config)\n  } catch (e) {\n    log.error('Error in config file!\\n', e)\n    return process.exit(1)\n  }\n\n  // merge the config from config file and cliOptions (precedence)\n  config.set(cliOptions)\n\n  // if the user changed listenAddress, but didn't set a hostname, warn them\n  if (config.hostname === null && config.listenAddress !== null) {\n    log.warn('ListenAddress was set to %s but hostname was left as the default: ' +\n      '%s. If your browsers fail to connect, consider changing the hostname option.',\n      config.listenAddress, defaultHostname)\n  }\n  // restore values that weren't overwritten by the user\n  if (config.hostname === null) {\n    config.hostname = defaultHostname\n  }\n  if (config.listenAddress === null) {\n    config.listenAddress = defaultListenAddress\n  }\n\n  // configure the logger as soon as we can\n  logger.setup(config.logLevel, config.colors, config.loggers)\n\n  return normalizeConfig(config, configFilePath)\n}\n\n// PUBLIC API\nexports.parseConfig = parseConfig\nexports.Pattern = Pattern\nexports.createPatternObject = createPatternObject\nexports.Config = Config\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/logger.js":"// This is the **logger** module for *Karma*. It uses\n// [log4js](https://github.com/nomiddlename/log4js-node) to handle and\n// configure all logging that happens inside of *Karma*.\n\n// ### Helpers and Setup\n\nvar log4js = require('log4js')\nvar helper = require('./helper')\nvar constant = require('./constants')\n\n// #### Public Functions\n\n// Setup the logger by passing in the configuration options. It needs\n// three arguments:\n//\n//     setup(logLevel, colors, appenders)\n//\n// * `logLevel`: *String* Defines the global log level.\n// * `colors`: *Boolean* Use colors in the stdout or not.\n// * `appenders`: *Array* This will be passed as appenders to log4js\n//   to allow for fine grained configuration of log4js. For more information\n//   see https://github.com/nomiddlename/log4js-node.\nvar setup = function (level, colors, appenders) {\n  // Turn color on/off on the console appenders with pattern layout\n  var pattern = colors ? constant.COLOR_PATTERN : constant.NO_COLOR_PATTERN\n\n  // If there are no appenders use the default one\n  appenders = helper.isDefined(appenders) ? appenders : [constant.CONSOLE_APPENDER]\n\n  appenders = appenders.map(function (appender) {\n    if (appender.type === 'console') {\n      if (helper.isDefined(appender.layout) && appender.layout.type === 'pattern') {\n        appender.layout.pattern = pattern\n      }\n    }\n    return appender\n  })\n\n  // Pass the values to log4js\n  log4js.setGlobalLogLevel(level)\n  log4js.configure({\n    appenders: appenders\n  })\n}\n\n// Setup the logger by passing in the config object. The function sets the\n// `colors` and `logLevel` if they are defined. It takes two arguments:\n//\n//     setupFromConfig(config, appenders)\n//\n// * `config`: *Object* The configuration object.\n// * `appenders`: *Array* This will be passed as appenders to log4js\n//   to allow for fine grained configuration of log4js. For more information\n//   see https://github.com/nomiddlename/log4js-node.\nvar setupFromConfig = function (config, appenders) {\n  var useColors = true\n  var logLevel = constant.LOG_INFO\n\n  if (helper.isDefined(config.colors)) {\n    useColors = config.colors\n  }\n\n  if (helper.isDefined(config.logLevel)) {\n    logLevel = config.logLevel\n  }\n  setup(logLevel, useColors, appenders)\n}\n\n// Create a new logger. There are two optional arguments\n// * `name`, which defaults to `karma` and\n//   If the `name = 'socket.io'` this will create a special wrapper\n//   to be used as a logger for socket.io.\n// * `level`, which defaults to the global level.\nvar create = function (name, level) {\n  var logger = log4js.getLogger(name || 'karma')\n  if (helper.isDefined(level)) {\n    logger.setLevel(level)\n  }\n  return logger\n}\n\n// #### Publish\n\nexports.create = create\nexports.setup = setup\nexports.setupFromConfig = setupFromConfig\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/helper.js":"var fs = require('graceful-fs')\nvar path = require('path')\nvar _ = require('lodash')\nvar useragent = require('useragent')\nvar Promise = require('bluebird')\nvar mm = require('minimatch')\n\nexports.browserFullNameToShort = function (fullName) {\n  var agent = useragent.parse(fullName)\n  var isKnown = agent.family !== 'Other' && agent.os.family !== 'Other'\n  return isKnown ? agent.toAgent() + ' (' + agent.os + ')' : fullName\n}\n\nexports.isDefined = function (value) {\n  return !_.isUndefined(value)\n}\nvar parser = function (pattern, out) {\n  if (pattern.length === 0) return out\n  var p = /^(\\[[^\\]]*\\]|[*+@?]\\((.+?)\\))/g\n  var matches = p.exec(pattern)\n  if (!matches) {\n    var c = pattern[0]\n    var t = 'word'\n    if (c === '*') {\n      t = 'star'\n    } else if (c === '?') {\n      t = 'optional'\n    }\n    out[t]++\n    return parser(pattern.substring(1), out)\n  }\n  if (matches[2] !== undefined) {\n    out.ext_glob++\n    parser(matches[2], out)\n    return parser(pattern.substring(matches[0].length), out)\n  }\n  out.range++\n  return parser(pattern.substring(matches[0].length), out)\n}\n\nvar gsParser = function (pattern, out) {\n  if (pattern === '**') {\n    out.glob_star++\n    return out\n  }\n  return parser(pattern, out)\n}\n\nvar compareWeightObject = function (w1, w2) {\n  return exports.mmComparePatternWeights(\n    [w1.glob_star, w1.star, w1.ext_glob, w1.range, w1.optional],\n    [w2.glob_star, w2.star, w2.ext_glob, w2.range, w2.optional]\n  )\n}\n\nexports.mmPatternWeight = function (pattern) {\n  var m = new mm.Minimatch(pattern)\n  if (!m.globParts) return [0, 0, 0, 0, 0, 0]\n  var result = m.globParts.reduce(function (prev, p) {\n    var r = p.reduce(function (prev, p) {\n      return gsParser(p, prev)\n    }, {glob_star: 0, ext_glob: 0, word: 0, star: 0, optional: 0, range: 0})\n    if (prev === undefined) return r\n    return compareWeightObject(r, prev) > 0 ? r : prev\n  }, undefined)\n  result.glob_sets = m.set.length\n  return [result.glob_sets, result.glob_star, result.star, result.ext_glob, result.range, result.optional]\n}\n\nexports.mmComparePatternWeights = function (weight1, weight2) {\n  var n1, n2, diff\n  n1 = weight1[0]\n  n2 = weight2[0]\n  diff = n1 - n2\n  if (diff !== 0) return diff / Math.abs(diff)\n  return weight1.length > 1 ? exports.mmComparePatternWeights(weight1.slice(1), weight2.slice(1)) : 0\n}\n\nexports.isFunction = _.isFunction\nexports.isString = _.isString\nexports.isObject = _.isObject\nexports.isArray = _.isArray\nexports.isNumber = _.isNumber\n\nvar ABS_URL = /^https?:\\/\\//\nexports.isUrlAbsolute = function (url) {\n  return ABS_URL.test(url)\n}\n\nexports.camelToSnake = function (camelCase) {\n  return camelCase.replace(/[A-Z]/g, function (match, pos) {\n    return (pos > 0 ? '_' : '') + match.toLowerCase()\n  })\n}\n\nexports.ucFirst = function (word) {\n  return word.charAt(0).toUpperCase() + word.substr(1)\n}\n\nexports.dashToCamel = function (dash) {\n  var words = dash.split('-')\n  return words.shift() + words.map(exports.ucFirst).join('')\n}\n\nexports.arrayRemove = function (collection, item) {\n  var idx = collection.indexOf(item)\n\n  if (idx !== -1) {\n    collection.splice(idx, 1)\n    return true\n  }\n\n  return false\n}\n\nexports.merge = function () {\n  var args = Array.prototype.slice.call(arguments, 0)\n  args.unshift({})\n  return _.merge.apply({}, args)\n}\n\nexports.formatTimeInterval = function (time) {\n  var mins = Math.floor(time / 60000)\n  var secs = (time - mins * 60000) / 1000\n  var str = secs + (secs === 1 ? ' sec' : ' secs')\n\n  if (mins) {\n    str = mins + (mins === 1 ? ' min ' : ' mins ') + str\n  }\n\n  return str\n}\n\nvar replaceWinPath = function (path) {\n  return _.isString(path) ? path.replace(/\\\\/g, '/') : path\n}\n\nexports.normalizeWinPath = process.platform === 'win32' ? replaceWinPath : _.identity\n\nexports.mkdirIfNotExists = function mkdir (directory, done) {\n  // TODO(vojta): handle if it's a file\n  /* eslint-disable handle-callback-err */\n  fs.stat(directory, function (err, stat) {\n    if (stat && stat.isDirectory()) {\n      done()\n    } else {\n      mkdir(path.dirname(directory), function () {\n        fs.mkdir(directory, done)\n      })\n    }\n  })\n  /* eslint-enable handle-callback-err */\n}\n\nexports.defer = function () {\n  var resolve\n  var reject\n  var promise = new Promise(function () {\n    resolve = arguments[0]\n    reject = arguments[1]\n  })\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  }\n}\n\n// export lodash\nObject.defineProperty(exports, '_', {\n  get: function () {\n    console.log('DEPRECATED: use your own version of lodash, this will go away in karma@2.0')\n    return _\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/watcher.js":"var chokidar = require('chokidar')\nvar mm = require('minimatch')\nvar expandBraces = require('expand-braces')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('watcher')\n\nvar DIR_SEP = require('path').sep\n\n// Get parent folder, that be watched (does not contain any special globbing character)\nvar baseDirFromPattern = function (pattern) {\n  return pattern\n    .replace(/[/\\\\][^/\\\\]*\\*.*$/, '')              // remove parts with *\n    .replace(/[/\\\\][^/\\\\]*[!+]\\(.*$/, '')         // remove parts with !(...) and +(...)\n    .replace(/[/\\\\][^/\\\\]*\\)\\?.*$/, '') || DIR_SEP // remove parts with (...)?\n}\n\nvar watchPatterns = function (patterns, watcher) {\n  // filter only unique non url patterns paths\n  var pathsToWatch = []\n  var uniqueMap = {}\n  var path\n\n  // expand ['a/{b,c}'] to ['a/b', 'a/c']\n  patterns = expandBraces(patterns)\n\n  patterns.forEach(function (pattern) {\n    path = baseDirFromPattern(pattern)\n    if (!uniqueMap[path]) {\n      uniqueMap[path] = true\n      pathsToWatch.push(path)\n    }\n  })\n\n  // watch only common parents, no sub paths\n  pathsToWatch.forEach(function (path) {\n    if (!pathsToWatch.some(function (p) {\n      return p !== path && path.substr(0, p.length + 1) === p + DIR_SEP\n    })) {\n      watcher.add(path)\n      log.debug('Watching \"%s\"', path)\n    }\n  })\n}\n\n// Function to test if a path should be ignored by chokidar.\nvar createIgnore = function (patterns, excludes) {\n  return function (path, stat) {\n    if (!stat || stat.isDirectory()) {\n      return false\n    }\n\n    // Check if the path matches any of the watched patterns.\n    if (!patterns.some(function (pattern) {\n      return mm(path, pattern, {dot: true})\n    })) {\n      return true\n    }\n\n    // Check if the path matches any of the exclude patterns.\n    if (excludes.some(function (pattern) {\n      return mm(path, pattern, {dot: true})\n    })) {\n      return true\n    }\n\n    return false\n  }\n}\n\nvar onlyWatchedTrue = function (pattern) {\n  return pattern.watched\n}\n\nvar getWatchedPatterns = function (patternObjects) {\n  return patternObjects.filter(onlyWatchedTrue).map(function (patternObject) {\n    return patternObject.pattern\n  })\n}\n\nexports.watch = function (patterns, excludes, fileList, usePolling, emitter) {\n  var watchedPatterns = getWatchedPatterns(patterns)\n  var options = {\n    usePolling: usePolling,\n    ignorePermissionErrors: true,\n    ignoreInitial: true,\n    ignored: createIgnore(watchedPatterns, excludes)\n  }\n  var chokidarWatcher = new chokidar.FSWatcher(options)\n\n  watchPatterns(watchedPatterns, chokidarWatcher)\n\n  var bind = function (fn) {\n    return function (path) {\n      return fn.call(fileList, helper.normalizeWinPath(path))\n    }\n  }\n\n  // register events\n  chokidarWatcher.on('add', bind(fileList.addFile))\n    .on('change', bind(fileList.changeFile))\n    .on('unlink', bind(fileList.removeFile))\n    // If we don't subscribe; unhandled errors from Chokidar will bring Karma down\n    // (see GH Issue #959)\n    .on('error', function (e) {\n      log.debug(e)\n    })\n\n  emitter.on('exit', function (done) {\n    chokidarWatcher.close()\n    done()\n  })\n\n  return chokidarWatcher\n}\n\nexports.watch.$inject = ['config.files', 'config.exclude', 'fileList', 'config.usePolling',\n  'emitter']\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/plugin.js":"var fs = require('graceful-fs')\nvar path = require('path')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('plugin')\n\nvar IGNORED_PACKAGES = ['karma-cli', 'karma-runner.github.com']\n\nexports.resolve = function (plugins, emitter) {\n  var modules = []\n\n  var requirePlugin = function (name) {\n    log.debug('Loading plugin %s.', name)\n    try {\n      modules.push(require(name))\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND' && e.message.indexOf(name) !== -1) {\n        log.error('Cannot find plugin \"%s\".\\n  Did you forget to install it?\\n' +\n          '  npm install %s --save-dev', name, name)\n      } else {\n        log.error('Error during loading \"%s\" plugin:\\n  %s', name, e.message)\n      }\n      emitter.emit('load_error', 'plug_in', name)\n    }\n  }\n\n  plugins.forEach(function (plugin) {\n    if (helper.isString(plugin)) {\n      if (plugin.indexOf('*') === -1) {\n        requirePlugin(plugin)\n        return\n      }\n      var pluginDirectory = path.normalize(path.join(__dirname, '/../..'))\n      var regexp = new RegExp('^' + plugin.replace('*', '.*'))\n\n      log.debug('Loading %s from %s', plugin, pluginDirectory)\n      fs.readdirSync(pluginDirectory).filter(function (pluginName) {\n        return IGNORED_PACKAGES.indexOf(pluginName) === -1 && regexp.test(pluginName)\n      }).forEach(function (pluginName) {\n        requirePlugin(pluginDirectory + '/' + pluginName)\n      })\n      return\n    }\n    if (helper.isObject(plugin)) {\n      log.debug('Loading inlined plugin (defining %s).', Object.keys(plugin).join(', '))\n      modules.push(plugin)\n      return\n    }\n    log.error('Invalid plugin %s', plugin)\n    emitter.emit('load_error', 'plug_in', plugin)\n  })\n\n  return modules\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/web-server.js":"var fs = require('graceful-fs')\nvar http = require('http')\nvar https = require('https')\nvar path = require('path')\nvar connect = require('connect')\nvar Promise = require('bluebird')\n\nvar common = require('./middleware/common')\nvar runnerMiddleware = require('./middleware/runner')\nvar stopperMiddleware = require('./middleware/stopper')\nvar stripHostMiddleware = require('./middleware/strip_host')\nvar karmaMiddleware = require('./middleware/karma')\nvar sourceFilesMiddleware = require('./middleware/source_files')\nvar proxyMiddleware = require('./middleware/proxy')\n\nvar log = require('./logger').create('web-server')\n\nvar createCustomHandler = function (customFileHandlers, /* config.basePath */ basePath) {\n  return function (request, response, next) {\n    for (var i = 0; i < customFileHandlers.length; i++) {\n      if (customFileHandlers[i].urlRegex.test(request.url)) {\n        return customFileHandlers[i].handler(request, response, 'fake/static', 'fake/adapter',\n          basePath, 'fake/root')\n      }\n    }\n\n    return next()\n  }\n}\n\ncreateCustomHandler.$inject = ['customFileHandlers', 'config.basePath']\n\nvar createWebServer = function (injector, emitter, fileList) {\n  var config = injector.get('config')\n  common.initializeMimeTypes(config)\n  var serveStaticFile = common.createServeFile(fs, path.normalize(path.join(__dirname, '/../static')), config)\n  var serveFile = common.createServeFile(fs, null, config)\n  var filesPromise = new common.PromiseContainer()\n\n  // Set an empty list of files to avoid race issues with\n  // file_list_modified not having been emitted yet\n  filesPromise.set(Promise.resolve(fileList.files))\n\n  emitter.on('file_list_modified', function (files) {\n    filesPromise.set(Promise.resolve(files))\n  })\n\n  // locals for webserver module\n  // NOTE(vojta): figure out how to do this with DI\n  injector = injector.createChild([{\n    serveFile: ['value', serveFile],\n    serveStaticFile: ['value', serveStaticFile],\n    filesPromise: ['value', filesPromise]\n  }])\n\n  var proxyMiddlewareInstance = injector.invoke(proxyMiddleware.create)\n\n  log.debug('Instantiating middleware')\n  var handler = connect()\n\n  if (config.beforeMiddleware) {\n    config.beforeMiddleware.forEach(function (middleware) {\n      handler.use(injector.get('middleware:' + middleware))\n    })\n  }\n\n  handler.use(injector.invoke(runnerMiddleware.create))\n  handler.use(injector.invoke(stopperMiddleware.create))\n  handler.use(injector.invoke(stripHostMiddleware.create))\n  handler.use(injector.invoke(karmaMiddleware.create))\n  handler.use(injector.invoke(sourceFilesMiddleware.create))\n  // TODO(vojta): extract the proxy into a plugin\n  handler.use(proxyMiddlewareInstance)\n  // TODO(vojta): remove, this is only here because of karma-dart\n  // we need a better way of custom handlers\n  handler.use(injector.invoke(createCustomHandler))\n\n  if (config.middleware) {\n    config.middleware.forEach(function (middleware) {\n      handler.use(injector.get('middleware:' + middleware))\n    })\n  }\n\n  handler.use(function (request, response) {\n    common.serve404(response, request.url)\n  })\n\n  var serverClass = http\n  var serverArguments = [handler]\n\n  if (config.protocol === 'https:') {\n    serverClass = https\n    serverArguments.unshift(config.httpsServerOptions || {})\n  }\n\n  if (config.httpModule) {\n    serverClass = config.httpModule\n  }\n\n  var server = serverClass.createServer.apply(null, serverArguments)\n\n  server.on('upgrade', function (req, socket, head) {\n    log.debug('upgrade %s', req.url)\n    proxyMiddlewareInstance.upgrade(req, socket, head)\n  })\n\n  return server\n}\n\n// PUBLIC API\nexports.create = createWebServer\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/common.js":"/**\n * This module contains some common helpers shared between middlewares\n */\n\nvar mime = require('mime')\nvar _ = require('lodash')\nvar parseRange = require('range-parser')\nvar Buffer = require('safe-buffer').Buffer\n\nvar log = require('../logger').create('web-server')\n\nvar PromiseContainer = function () {\n  var promise\n\n  this.then = function (success, error) {\n    error = error || _.noop\n    return promise.then(success).catch(error)\n  }\n\n  this.set = function (newPromise) {\n    promise = newPromise\n  }\n}\n\nvar serve404 = function (response, path) {\n  log.warn('404: ' + path)\n  response.writeHead(404)\n  return response.end('NOT FOUND')\n}\n\nvar createServeFile = function (fs, directory, config) {\n  var cache = Object.create(null)\n\n  return function (filepath, rangeHeader, response, transform, content, doNotCache) {\n    var responseData\n\n    var convertForRangeRequest = function () {\n      var range = parseRange(responseData.length, rangeHeader)\n      if (range === -2) {\n        // malformed header string\n        return 200\n      } else if (range === -1) {\n        // unsatisfiable range\n        responseData = Buffer.alloc(0)\n        return 416\n      } else if (range.type === 'bytes') {\n        responseData = Buffer.from(responseData)\n        if (range.length === 1) {\n          var start = range[0].start\n          var end = range[0].end\n          response.setHeader(\n            'Content-Range',\n            'bytes ' + start + '-' + end + '/' + responseData.length\n          )\n          response.setHeader('Accept-Ranges', 'bytes')\n          response.setHeader('Content-Length', end - start + 1)\n          responseData = responseData.slice(start, end + 1)\n          return 206\n        } else {\n          // Multiple ranges are not supported. Maybe future?\n          responseData = new Buffer(0)\n          return 416\n        }\n      }\n      // All other states, ignore\n      return 200\n    }\n\n    if (directory) {\n      filepath = directory + filepath\n    }\n\n    if (!content && cache[filepath]) {\n      content = cache[filepath]\n    }\n\n    if (config && config.customHeaders && config.customHeaders.length > 0) {\n      config.customHeaders.forEach(function (header) {\n        var regex = new RegExp(header.match)\n        if (regex.test(filepath)) {\n          log.debug('setting header: ' + header.name + ' for: ' + filepath)\n          response.setHeader(header.name, header.value)\n        }\n      })\n    }\n\n    // serve from cache\n    if (content && !doNotCache) {\n      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))\n\n      // call custom transform fn to transform the data\n      responseData = (transform && transform(content)) || content\n\n      if (rangeHeader) {\n        var code = convertForRangeRequest()\n        response.writeHead(code)\n      } else {\n        response.writeHead(200)\n      }\n\n      log.debug('serving (cached): ' + filepath)\n      return response.end(responseData)\n    }\n\n    return fs.readFile(filepath, function (error, data) {\n      if (error) {\n        return serve404(response, filepath)\n      }\n\n      if (!doNotCache) {\n        cache[filepath] = data.toString()\n      }\n\n      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))\n\n      // call custom transform fn to transform the data\n      responseData = (transform && transform(data.toString())) || data\n\n      if (rangeHeader) {\n        var code = convertForRangeRequest()\n        response.writeHead(code)\n      } else {\n        response.writeHead(200)\n      }\n\n      log.debug('serving: ' + filepath)\n      return response.end(responseData)\n    })\n  }\n}\n\nvar setNoCacheHeaders = function (response) {\n  response.setHeader('Cache-Control', 'no-cache')\n  response.setHeader('Pragma', 'no-cache')\n  response.setHeader('Expires', (new Date(0)).toUTCString())\n}\n\nvar setHeavyCacheHeaders = function (response) {\n  response.setHeader('Cache-Control', 'public, max-age=31536000')\n}\n\nvar initializeMimeTypes = function (config) {\n  if (config && config.mime) {\n    _.forEach(config.mime, function (value, key) {\n      var map = {}\n      map[key] = value\n      mime.define(map)\n    })\n  }\n}\n\n// PUBLIC API\nexports.PromiseContainer = PromiseContainer\nexports.createServeFile = createServeFile\nexports.setNoCacheHeaders = setNoCacheHeaders\nexports.setHeavyCacheHeaders = setHeavyCacheHeaders\nexports.initializeMimeTypes = initializeMimeTypes\nexports.serve404 = serve404\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/runner.js":"/**\n * Runner middleware is responsible for communication with `karma run`.\n *\n * It basically triggers a test run and streams stdout back.\n */\n\nvar _ = require('lodash')\nvar path = require('path')\nvar helper = require('../helper')\nvar log = require('../logger').create()\nvar constant = require('../constants')\nvar json = require('body-parser').json()\n\n// TODO(vojta): disable when single-run mode\nvar createRunnerMiddleware = function (emitter, fileList, capturedBrowsers, reporter, executor,\n  /* config.protocol */ protocol, /* config.hostname */ hostname, /* config.port */\n  port, /* config.urlRoot */ urlRoot, config) {\n  return function (request, response, next) {\n    if (request.url !== '/__run__' && request.url !== urlRoot + 'run') {\n      return next()\n    }\n\n    log.debug('Execution (fired by runner)')\n    response.writeHead(200)\n\n    if (!capturedBrowsers.length) {\n      var url = protocol + '//' + hostname + ':' + port + urlRoot\n\n      return response.end('No captured browser, open ' + url + '\\n')\n    }\n\n    json(request, response, function () {\n      if (!capturedBrowsers.areAllReady([])) {\n        response.write('Waiting for previous execution...\\n')\n      }\n\n      var data = request.body\n      emitter.once('run_start', function () {\n        var responseWrite = response.write.bind(response)\n        responseWrite.colors = data.colors\n        reporter.addAdapter(responseWrite)\n\n        // clean up, close runner response\n        emitter.once('run_complete', function (browsers, results) {\n          reporter.removeAdapter(responseWrite)\n          var emptyTestSuite = (results.failed + results.success) === 0 ? 0 : 1\n          response.end(constant.EXIT_CODE + emptyTestSuite + results.exitCode)\n        })\n      })\n\n      if (_.isEmpty(data.args)) {\n        log.debug('Ignoring empty client.args from run command')\n      } else if ((_.isArray(data.args) && _.isArray(config.client.args)) ||\n        (_.isPlainObject(data.args) && _.isPlainObject(config.client.args))) {\n        log.debug('Merging client.args with ', data.args)\n        config.client.args = _.merge(config.client.args, data.args)\n      } else {\n        log.warn('Replacing client.args with ', data.args, ' as their types do not match.')\n        config.client.args = data.args\n      }\n\n      var fullRefresh = true\n\n      if (helper.isArray(data.changedFiles)) {\n        data.changedFiles.forEach(function (filepath) {\n          fileList.changeFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (helper.isArray(data.addedFiles)) {\n        data.addedFiles.forEach(function (filepath) {\n          fileList.addFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (helper.isArray(data.removedFiles)) {\n        data.removedFiles.forEach(function (filepath) {\n          fileList.removeFile(path.resolve(config.basePath, filepath))\n          fullRefresh = false\n        })\n      }\n\n      if (fullRefresh && data.refresh !== false) {\n        log.debug('Refreshing all the files / patterns')\n        fileList.refresh().then(function () {\n          // Wait for the file list refresh to complete before starting test run,\n          // otherwise the context.html generation might not see new/updated files.\n          if (!config.autoWatch) {\n            executor.schedule()\n          }\n        })\n      } else {\n        executor.schedule()\n      }\n    })\n  }\n}\n\ncreateRunnerMiddleware.$inject = ['emitter', 'fileList', 'capturedBrowsers', 'reporter', 'executor',\n  'config.protocol', 'config.hostname', 'config.port', 'config.urlRoot', 'config']\n\n// PUBLIC API\nexports.create = createRunnerMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/stopper.js":"/**\n * Stopper middleware is responsible for communicating with `karma stop`.\n */\n\nvar log = require('../logger').create('middleware:stopper')\n\nvar createStopperMiddleware = function (urlRoot) {\n  return function (request, response, next) {\n    if (request.url !== urlRoot + 'stop') return next()\n    response.writeHead(200)\n    log.info('Stopping server')\n    response.end('OK')\n    process.kill(process.pid, 'SIGINT')\n  }\n}\n\ncreateStopperMiddleware.$inject = ['config.urlRoot']\nexports.create = createStopperMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/strip_host.js":"/**\n * Strip host middleware is responsible for stripping hostname from request path\n * This to handle requests that uses (normally over proxies) an absoluteURI as request path\n */\n\nvar createStripHostMiddleware = function () {\n  return function (request, response, next) {\n    function stripHostFromUrl (url) {\n      return url.replace(/^http[s]?:\\/\\/([a-z\\-.:\\d]+)\\//, '/')\n    }\n\n    request.normalizedUrl = stripHostFromUrl(request.url) || request.url\n    next()\n  }\n}\n\n// PUBLIC API\nexports.create = createStripHostMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/karma.js":"/**\n * Karma middleware is responsible for serving:\n * - client.html (the entrypoint for capturing a browser)\n * - debug.html\n * - context.html (the execution context, loaded within an iframe)\n * - karma.js\n *\n * The main part is generating context.html, as it contains:\n * - generating mappings\n * - including <script> and <link> tags\n * - setting propert caching headers\n */\n\nvar path = require('path')\nvar util = require('util')\nvar url = require('url')\nvar useragent = require('useragent')\n\nvar log = require('../logger').create('middleware:karma')\n\nvar urlparse = function (urlStr) {\n  var urlObj = url.parse(urlStr, true)\n  urlObj.query = urlObj.query || {}\n  return urlObj\n}\n\nvar common = require('./common')\n\nvar VERSION = require('../constants').VERSION\nvar SCRIPT_TAG = '<script type=\"%s\" src=\"%s\" %s></script>'\nvar CROSSORIGIN_ATTRIBUTE = 'crossorigin=\"anonymous\"'\nvar LINK_TAG_CSS = '<link type=\"text/css\" href=\"%s\" rel=\"stylesheet\">'\nvar LINK_TAG_HTML = '<link href=\"%s\" rel=\"import\">'\nvar SCRIPT_TYPE = {\n  '.js': 'text/javascript',\n  '.dart': 'application/dart'\n}\n\nvar filePathToUrlPath = function (filePath, basePath, urlRoot, proxyPath) {\n  if (filePath.indexOf(basePath) === 0) {\n    return proxyPath + urlRoot.substr(1) + 'base' + filePath.substr(basePath.length)\n  }\n\n  return proxyPath + urlRoot.substr(1) + 'absolute' + filePath\n}\n\nvar getXUACompatibleMetaElement = function (url) {\n  var tag = ''\n  var urlObj = urlparse(url)\n  if (urlObj.query['x-ua-compatible']) {\n    tag = '\\n<meta http-equiv=\"X-UA-Compatible\" content=\"' +\n      urlObj.query['x-ua-compatible'] + '\"/>'\n  }\n  return tag\n}\n\nvar getXUACompatibleUrl = function (url) {\n  var value = ''\n  var urlObj = urlparse(url)\n  if (urlObj.query['x-ua-compatible']) {\n    value = '?x-ua-compatible=' + encodeURIComponent(urlObj.query['x-ua-compatible'])\n  }\n  return value\n}\n\nvar isFirefox = function (req) {\n  if (!(req && req.headers)) {\n    return false\n  }\n\n  // Browser check\n  var firefox = useragent.is(req.headers['user-agent']).firefox\n\n  return firefox\n}\n\nvar createKarmaMiddleware = function (\n  filesPromise,\n  serveStaticFile,\n  serveFile,\n  injector,\n  basePath,\n  urlRoot,\n  upstreamProxy\n) {\n  var proxyPath = upstreamProxy ? upstreamProxy.path : '/'\n  return function (request, response, next) {\n    // These config values should be up to date on every request\n    var client = injector.get('config.client')\n    var customContextFile = injector.get('config.customContextFile')\n    var customDebugFile = injector.get('config.customDebugFile')\n    var customClientContextFile = injector.get('config.customClientContextFile')\n    var jsVersion = injector.get('config.jsVersion')\n    var includeCrossOriginAttribute = injector.get('config.crossOriginAttribute')\n\n    var requestUrl = request.normalizedUrl.replace(/\\?.*/, '')\n    var requestedRangeHeader = request.headers['range']\n\n    // redirect /__karma__ to /__karma__ (trailing slash)\n    if (requestUrl === urlRoot.substr(0, urlRoot.length - 1)) {\n      response.setHeader('Location', proxyPath + urlRoot.substr(1))\n      response.writeHead(301)\n      return response.end('MOVED PERMANENTLY')\n    }\n\n    // ignore urls outside urlRoot\n    if (requestUrl.indexOf(urlRoot) !== 0) {\n      return next()\n    }\n\n    // remove urlRoot prefix\n    requestUrl = requestUrl.substr(urlRoot.length - 1)\n\n    // serve client.html\n    if (requestUrl === '/') {\n      // redirect client_with_context.html\n      if (!client.useIframe && client.runInParent) {\n        requestUrl = '/client_with_context.html'\n      } else { // serve client.html\n        return serveStaticFile('/client.html', requestedRangeHeader, response, function (data) {\n          return data\n            .replace('\\n%X_UA_COMPATIBLE%', getXUACompatibleMetaElement(request.url))\n            .replace('%X_UA_COMPATIBLE_URL%', getXUACompatibleUrl(request.url))\n        })\n      }\n    }\n\n    // serve karma.js, context.js, and debug.js\n    var jsFiles = ['/karma.js', '/context.js', '/debug.js']\n    var isRequestingJsFile = jsFiles.indexOf(requestUrl) !== -1\n    if (isRequestingJsFile) {\n      return serveStaticFile(requestUrl, requestedRangeHeader, response, function (data) {\n        return data.replace('%KARMA_URL_ROOT%', urlRoot)\n          .replace('%KARMA_VERSION%', VERSION)\n          .replace('%KARMA_PROXY_PATH%', proxyPath)\n      })\n    }\n\n    // serve the favicon\n    if (requestUrl === '/favicon.ico') {\n      return serveStaticFile(requestUrl, requestedRangeHeader, response)\n    }\n\n    // serve context.html - execution context within the iframe\n    // or debug.html - execution context without channel to the server\n    var isRequestingContextFile = requestUrl === '/context.html'\n    var isRequestingDebugFile = requestUrl === '/debug.html'\n    var isRequestingClientContextFile = requestUrl === '/client_with_context.html'\n    if (isRequestingContextFile || isRequestingDebugFile || isRequestingClientContextFile) {\n      return filesPromise.then(function (files) {\n        var fileServer\n        var requestedFileUrl\n        log.debug('custom files', customContextFile, customDebugFile, customClientContextFile)\n        if (isRequestingContextFile && customContextFile) {\n          log.debug('Serving customContextFile %s', customContextFile)\n          fileServer = serveFile\n          requestedFileUrl = customContextFile\n        } else if (isRequestingDebugFile && customDebugFile) {\n          log.debug('Serving customDebugFile %s', customDebugFile)\n          fileServer = serveFile\n          requestedFileUrl = customDebugFile\n        } else if (isRequestingClientContextFile && customClientContextFile) {\n          log.debug('Serving customClientContextFile %s', customClientContextFile)\n          fileServer = serveFile\n          requestedFileUrl = customClientContextFile\n        } else {\n          log.debug('Serving static request %s', requestUrl)\n          fileServer = serveStaticFile\n          requestedFileUrl = requestUrl\n        }\n\n        fileServer(requestedFileUrl, requestedRangeHeader, response, function (data) {\n          common.setNoCacheHeaders(response)\n\n          var scriptTags = []\n          var scriptUrls = []\n          for (var i in files.included) {\n            var file = files.included[i]\n            var filePath = file.path\n            var fileExt = path.extname(filePath)\n\n            if (!files.included.hasOwnProperty(i)) {\n              continue\n            }\n\n            if (!file.isUrl) {\n              filePath = filePathToUrlPath(filePath, basePath, urlRoot, proxyPath)\n\n              if (requestUrl === '/context.html') {\n                filePath += '?' + file.sha\n              }\n            }\n\n            scriptUrls.push(filePath)\n\n            if (fileExt === '.css') {\n              scriptTags.push(util.format(LINK_TAG_CSS, filePath))\n              continue\n            }\n\n            if (fileExt === '.html') {\n              scriptTags.push(util.format(LINK_TAG_HTML, filePath))\n              continue\n            }\n\n            // The script tag to be placed\n            var scriptType = (SCRIPT_TYPE[fileExt] || 'text/javascript')\n\n            // In case there is a JavaScript version specified and this is a Firefox browser\n            if (jsVersion && jsVersion > 0 && isFirefox(request)) {\n              scriptType += ';version=' + jsVersion\n            }\n\n            var crossOriginAttribute = includeCrossOriginAttribute ? CROSSORIGIN_ATTRIBUTE : ''\n            scriptTags.push(util.format(SCRIPT_TAG, scriptType, filePath, crossOriginAttribute))\n          }\n\n          // TODO(vojta): don't compute if it's not in the template\n          var mappings = files.served.map(function (file) {\n            // Windows paths contain backslashes and generate bad IDs if not escaped\n            var filePath = filePathToUrlPath(file.path, basePath, urlRoot, proxyPath).replace(/\\\\/g, '\\\\\\\\')\n            // Escape single quotes that might be in the filename -\n            // double quotes should not be allowed!\n            filePath = filePath.replace(/'/g, '\\\\\\'')\n\n            return util.format(\"  '%s': '%s'\", filePath, file.sha)\n          })\n\n          var clientConfig = 'window.__karma__.config = ' + JSON.stringify(client) + ';\\n'\n\n          var scriptUrlsJS = 'window.__karma__.scriptUrls = ' + JSON.stringify(scriptUrls) + ';\\n'\n\n          mappings = 'window.__karma__.files = {\\n' + mappings.join(',\\n') + '\\n};\\n'\n\n          return data\n            .replace('%SCRIPTS%', scriptTags.join('\\n'))\n            .replace('%CLIENT_CONFIG%', clientConfig)\n            .replace('%SCRIPT_URL_ARRAY%', scriptUrlsJS)\n            .replace('%MAPPINGS%', mappings)\n            .replace('\\n%X_UA_COMPATIBLE%', getXUACompatibleMetaElement(request.url))\n        })\n      }, function (errorFiles) {\n        serveStaticFile(requestUrl, response, function (data) {\n          common.setNoCacheHeaders(response)\n          return data.replace('%SCRIPTS%', '').replace('%CLIENT_CONFIG%', '').replace('%MAPPINGS%',\n            'window.__karma__.error(\"TEST RUN WAS CANCELLED because ' +\n            (errorFiles.length > 1 ? 'these files contain' : 'this file contains') +\n            ' some errors:\\\\n  ' + errorFiles.join('\\\\n  ') + '\");')\n        })\n      })\n    } else if (requestUrl === '/context.json') {\n      return filesPromise.then(function (files) {\n        common.setNoCacheHeaders(response)\n        response.writeHead(200)\n        response.end(JSON.stringify({\n          files: files.included.map(function (file) {\n            return filePathToUrlPath(file.path + '?' + file.sha, basePath, urlRoot, proxyPath)\n          })\n        }))\n      })\n    }\n\n    return next()\n  }\n}\n\ncreateKarmaMiddleware.$inject = [\n  'filesPromise',\n  'serveStaticFile',\n  'serveFile',\n  'injector',\n  'config.basePath',\n  'config.urlRoot',\n  'config.upstreamProxy'\n]\n\n// PUBLIC API\nexports.create = createKarmaMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/source_files.js":"var from = require('core-js/library/fn/array/from')\nvar querystring = require('querystring')\nvar _ = require('lodash')\n\nvar common = require('./common')\nvar logger = require('../logger')\nvar log = logger.create('middleware:source-files')\n\n// Files is a Set\nvar findByPath = function (files, path) {\n  return _.find(from(files), function (file) {\n    return file.path === path\n  })\n}\n\nvar composeUrl = function (url, basePath, urlRoot, mustEscape) {\n  return (mustEscape ? querystring.unescape(url) : url)\n            .replace(urlRoot, '/')\n            .replace(/\\?.*$/, '')\n            .replace(/^\\/absolute/, '')\n            .replace(/^\\/base/, basePath)\n}\n\n// Source Files middleware is responsible for serving all the source files under the test.\nvar createSourceFilesMiddleware = function (filesPromise, serveFile, basePath, urlRoot) {\n  return function (request, response, next) {\n    var requestedFilePath = composeUrl(request.url, basePath, urlRoot, true)\n    // When a path contains HTML-encoded characters (e.g %2F used by Jenkins for branches with /)\n    var requestedFilePathUnescaped = composeUrl(request.url, basePath, urlRoot, false)\n\n    request.pause()\n\n    log.debug('Requesting %s', request.url, urlRoot)\n    log.debug('Fetching %s', requestedFilePath)\n\n    return filesPromise.then(function (files) {\n      // TODO(vojta): change served to be a map rather then an array\n      var file = findByPath(files.served, requestedFilePath) ||\n                 findByPath(files.served, requestedFilePathUnescaped)\n      var rangeHeader = request.headers['range']\n\n      if (file) {\n        serveFile(file.contentPath || file.path, rangeHeader, response, function () {\n          if (/\\?\\w+/.test(request.url)) {\n            // files with timestamps - cache one year, rely on timestamps\n            common.setHeavyCacheHeaders(response)\n          } else {\n            // without timestamps - no cache (debug)\n            common.setNoCacheHeaders(response)\n          }\n        }, file.content, file.doNotCache)\n      } else {\n        next()\n      }\n\n      request.resume()\n    })\n  }\n}\n\ncreateSourceFilesMiddleware.$inject = [\n  'filesPromise', 'serveFile', 'config.basePath', 'config.urlRoot'\n]\n\n// PUBLIC API\nexports.create = createSourceFilesMiddleware\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/middleware/proxy.js":"var url = require('url')\nvar httpProxy = require('http-proxy')\nvar _ = require('lodash')\n\nvar log = require('../logger').create('proxy')\n\nvar parseProxyConfig = function (proxies, config) {\n  var endsWithSlash = function (str) {\n    return str.substr(-1) === '/'\n  }\n\n  if (!proxies) {\n    return []\n  }\n\n  return _.sortBy(_.map(proxies, function (proxyConfiguration, proxyPath) {\n    if (typeof proxyConfiguration === 'string') {\n      proxyConfiguration = {target: proxyConfiguration}\n    }\n    var proxyUrl = proxyConfiguration.target\n    var proxyDetails = url.parse(proxyUrl)\n    var pathname = proxyDetails.pathname\n\n    // normalize the proxies config\n    // should we move this to lib/config.js ?\n    if (endsWithSlash(proxyPath) && !endsWithSlash(proxyUrl)) {\n      log.warn('proxy \"%s\" normalized to \"%s\"', proxyUrl, proxyUrl + '/')\n      proxyUrl += '/'\n      pathname += '/'\n    }\n\n    if (!endsWithSlash(proxyPath) && endsWithSlash(proxyUrl)) {\n      log.warn('proxy \"%s\" normalized to \"%s\"', proxyPath, proxyPath + '/')\n      proxyPath += '/'\n    }\n\n    if (pathname === '/' && !endsWithSlash(proxyUrl)) {\n      pathname = ''\n    }\n\n    var hostname = proxyDetails.hostname || config.hostname\n    var protocol = proxyDetails.protocol || config.protocol\n    var https = proxyDetails.protocol === 'https:'\n    var port\n    if (proxyDetails.port) {\n      port = proxyDetails.port\n    } else if (proxyDetails.protocol) {\n      port = proxyDetails.protocol === 'https:' ? '443' : '80'\n    } else {\n      port = config.port\n    }\n    var changeOrigin = 'changeOrigin' in proxyConfiguration ? proxyConfiguration.changeOrigin : false\n    var proxy = httpProxy.createProxyServer({\n      target: {\n        host: hostname,\n        port: port,\n        https: https,\n        protocol: protocol\n      },\n      xfwd: true,\n      changeOrigin: changeOrigin,\n      secure: config.proxyValidateSSL\n    })\n\n    ;['proxyReq', 'proxyRes'].forEach(function (name) {\n      var callback = proxyDetails[name] || config[name]\n      if (callback) {\n        proxy.on(name, callback)\n      }\n    })\n\n    proxy.on('error', function proxyError (err, req, res) {\n      if (err.code === 'ECONNRESET' && req.socket.destroyed) {\n        log.debug('failed to proxy %s (browser hung up the socket)', req.url)\n      } else {\n        log.warn('failed to proxy %s (%s)', req.url, err.message)\n      }\n\n      res.destroy()\n    })\n\n    return {\n      path: proxyPath,\n      baseUrl: pathname,\n      host: hostname,\n      port: port,\n      https: https,\n      proxy: proxy\n    }\n  }), 'path').reverse()\n}\n\n/**\n * Returns a handler which understands the proxies and its redirects, along with the proxy to use\n * @param proxies An array of proxy record objects\n * @param urlRoot The URL root that karma is mounted on\n * @return {Function} handler function\n */\nvar createProxyHandler = function (proxies, urlRoot) {\n  if (!proxies.length) {\n    var nullProxy = function createNullProxy (request, response, next) {\n      return next()\n    }\n    nullProxy.upgrade = function upgradeNullProxy () {}\n    return nullProxy\n  }\n\n  var middleware = function createProxy (request, response, next) {\n    var proxyRecord = _.find(proxies, function (p) {\n      return request.url.indexOf(p.path) === 0\n    })\n\n    if (!proxyRecord) {\n      return next()\n    }\n\n    log.debug('proxying request - %s to %s:%s', request.url, proxyRecord.host, proxyRecord.port)\n    request.url = request.url.replace(proxyRecord.path, proxyRecord.baseUrl)\n    proxyRecord.proxy.web(request, response)\n  }\n\n  middleware.upgrade = function upgradeProxy (request, socket, head) {\n    // special-case karma's route to avoid upgrading it\n    if (request.url.indexOf(urlRoot) === 0) {\n      log.debug('NOT upgrading proxyWebSocketRequest %s', request.url)\n      return\n    }\n\n    var proxyRecord = _.find(proxies, function (p) {\n      return request.url.indexOf(p.path) === 0\n    })\n\n    if (!proxyRecord) {\n      return\n    }\n\n    log.debug('upgrade proxyWebSocketRequest %s to %s:%s',\n      request.url, proxyRecord.host, proxyRecord.port)\n    request.url = request.url.replace(proxyRecord.path, proxyRecord.baseUrl)\n    proxyRecord.proxy.ws(request, socket, head)\n  }\n\n  return middleware\n}\n\nexports.create = function (/* config */config, /* config.proxies */proxies) {\n  return createProxyHandler(parseProxyConfig(proxies, config), config.urlRoot)\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/preprocessor.js":"var fs = require('graceful-fs')\nvar crypto = require('crypto')\nvar mm = require('minimatch')\nvar isBinaryFile = require('isbinaryfile')\nvar combineLists = require('combine-lists')\n\nvar log = require('./logger').create('preprocess')\n\nvar sha1 = function (data) {\n  var hash = crypto.createHash('sha1')\n  hash.update(data)\n  return hash.digest('hex')\n}\n\nvar createNextProcessor = function (preprocessors, file, done) {\n  return function nextPreprocessor (error, content) {\n    // normalize B-C\n    if (arguments.length === 1 && typeof error === 'string') {\n      content = error\n      error = null\n    }\n\n    if (error) {\n      file.content = null\n      file.contentPath = null\n      return done(error)\n    }\n\n    if (!preprocessors.length) {\n      file.contentPath = null\n      file.content = content\n      file.sha = sha1(content)\n      return done()\n    }\n\n    preprocessors.shift()(content, file, nextPreprocessor)\n  }\n}\n\nvar createPreprocessor = function (config, basePath, injector) {\n  var alreadyDisplayedErrors = {}\n  var instances = {}\n  var patterns = Object.keys(config)\n\n  var emitter = injector.get('emitter')\n\n  var instantiatePreprocessor = function (name) {\n    if (alreadyDisplayedErrors[name]) {\n      return\n    }\n\n    var p\n\n    try {\n      p = injector.get('preprocessor:' + name)\n    } catch (e) {\n      if (e.message.indexOf('No provider for \"preprocessor:' + name + '\"') !== -1) {\n        log.error('Can not load \"%s\", it is not registered!\\n  ' +\n          'Perhaps you are missing some plugin?', name)\n      } else {\n        log.error('Can not load \"%s\"!\\n  ' + e.stack, name)\n      }\n      alreadyDisplayedErrors[name] = true\n      emitter.emit('load_error', 'preprocessor', name)\n    }\n\n    return p\n  }\n\n  var allPreprocessors = []\n  patterns.forEach(function (pattern) {\n    allPreprocessors = combineLists(allPreprocessors, config[pattern])\n  })\n  allPreprocessors.forEach(instantiatePreprocessor)\n\n  return function preprocess (file, done) {\n    patterns = Object.keys(config)\n\n    return fs.readFile(file.originalPath, function (err, buffer) {\n      if (err) {\n        throw err\n      }\n\n      isBinaryFile(buffer, buffer.length, function (err, thisFileIsBinary) {\n        if (err) {\n          throw err\n        }\n\n        var preprocessorNames = []\n        for (var i = 0; i < patterns.length; i++) {\n          if (mm(file.originalPath, patterns[i], {dot: true})) {\n            if (thisFileIsBinary) {\n              log.warn('Ignoring preprocessing (%s) %s because it is a binary file.',\n                config[patterns[i]].join(', '), file.originalPath)\n            } else {\n              preprocessorNames = combineLists(preprocessorNames, config[patterns[i]])\n            }\n          }\n        }\n\n        var preprocessors = []\n        var nextPreprocessor = createNextProcessor(preprocessors, file, done)\n        preprocessorNames.forEach(function (name) {\n          var p = instances[name]\n          if (p == null) {\n            p = instantiatePreprocessor(name)\n          }\n\n          if (p == null) {\n            if (!alreadyDisplayedErrors[name]) {\n              alreadyDisplayedErrors[name] = true\n              log.error('Failed to instantiate preprocessor %s', name)\n              emitter.emit('load_error', 'preprocessor', name)\n            }\n            return\n          }\n\n          instances[name] = p\n          preprocessors.push(p)\n        })\n\n        nextPreprocessor(null, thisFileIsBinary ? buffer : buffer.toString())\n      })\n    })\n  }\n}\ncreatePreprocessor.$inject = ['config.preprocessors', 'config.basePath', 'injector']\n\nexports.createPreprocessor = createPreprocessor\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/launcher.js":"var Promise = require('bluebird')\nvar Jobs = require('qjobs')\n\nvar helper = require('./helper')\nvar log = require('./logger').create('launcher')\n\nvar baseDecorator = require('./launchers/base').decoratorFactory\nvar captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory\nvar retryDecorator = require('./launchers/retry').decoratorFactory\nvar processDecorator = require('./launchers/process').decoratorFactory\n\n// TODO(vojta): remove once nobody uses it\nvar baseBrowserDecoratorFactory = function (\n  baseLauncherDecorator,\n  captureTimeoutLauncherDecorator,\n  retryLauncherDecorator,\n  processLauncherDecorator,\n  processKillTimeout\n) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher)\n    captureTimeoutLauncherDecorator(launcher)\n    retryLauncherDecorator(launcher)\n    processLauncherDecorator(launcher, processKillTimeout)\n  }\n}\n\nvar Launcher = function (server, emitter, injector) {\n  this._browsers = []\n  var lastStartTime\n  var self = this\n\n  var getBrowserById = function (id) {\n    for (var i = 0; i < self._browsers.length; i++) {\n      if (self._browsers[i].id === id) {\n        return self._browsers[i]\n      }\n    }\n\n    return null\n  }\n\n  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    var self = this\n    return function (name) {\n      if (upstreamProxy) {\n        protocol = upstreamProxy.protocol\n        hostname = upstreamProxy.hostname\n        port = upstreamProxy.port\n        urlRoot = upstreamProxy.path + urlRoot.substr(1)\n      }\n      var url = protocol + '//' + hostname + ':' + port + urlRoot\n\n      var locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }\n\n      // TODO(vojta): determine script from name\n      if (name.indexOf('/') !== -1) {\n        name = 'Script'\n      }\n\n      try {\n        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)\n      } catch (e) {\n        if (e.message.indexOf('No provider for \"launcher:' + name + '\"') !== -1) {\n          log.error('Cannot load browser \"%s\": it is not registered! ' +\n            'Perhaps you are missing some plugin?', name)\n        } else {\n          log.error('Cannot load browser \"%s\"!\\n  ' + e.stack, name)\n        }\n\n        emitter.emit('load_error', 'launcher', name)\n        return\n      }\n\n      // TODO(vojta): remove in v1.0 (BC for old launchers)\n      if (!browser.forceKill) {\n        browser.forceKill = function () {\n          var me = this\n          return new Promise(function (resolve) {\n            me.kill(resolve)\n          })\n        }\n\n        browser.restart = function () {\n          var me = this\n          this.kill(function () {\n            me.start(url)\n          })\n        }\n      }\n\n      self.jobs.add(function (args, done) {\n        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)\n\n        browser.on('browser_process_failure', function () {\n          done(browser.error)\n        })\n\n        browser.on('done', function () {\n          // We are not done if there was an error as first the retry takes\n          // place which we catch with `browser_process_failure` if it fails\n          if (browser.error || browser.state === browser.STATE_RESTARTING) return\n\n          done(null, browser)\n        })\n\n        browser.start(url)\n      }, [])\n\n      self.jobs.run()\n      self._browsers.push(browser)\n    }\n  }\n\n  this.launch = function (names, concurrency) {\n    log.info(\n      'Launching browser%s %s with %s',\n      names.length > 1 ? 's' : '',\n      names.join(', '),\n      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency\n    )\n    this.jobs = new Jobs({maxConcurrency: concurrency})\n\n    var self = this\n    lastStartTime = Date.now()\n\n    if (server.loadErrors.length === 0) {\n      names.forEach(function (name) {\n        injector.invoke(self.launchSingle, self)(name)\n      })\n    } else {\n      // Empty task to ensure `end` is emitted\n      this.jobs.add(function (args, done) {\n        done()\n      }, [])\n    }\n\n    this.jobs.on('end', function (err) {\n      log.debug('Finished all browsers')\n\n      if (err) {\n        log.error(err)\n      }\n    })\n\n    this.jobs.run()\n\n    return self._browsers\n  }\n\n  this.launch.$inject = [\n    'config.browsers',\n    'config.concurrency',\n    'config.processKillTimeout'\n  ]\n\n  this.launchSingle.$inject = [\n    'config.protocol',\n    'config.hostname',\n    'config.port',\n    'config.urlRoot',\n    'config.upstreamProxy',\n    'config.processKillTimeout'\n  ]\n\n  this.kill = function (id, callback) {\n    var browser = getBrowserById(id)\n    callback = callback || function () {}\n\n    if (!browser) {\n      process.nextTick(callback)\n      return false\n    }\n\n    browser.forceKill().then(callback)\n    return true\n  }\n\n  this.restart = function (id) {\n    var browser = getBrowserById(id)\n\n    if (!browser) {\n      return false\n    }\n\n    browser.restart()\n    return true\n  }\n\n  this.killAll = function (callback) {\n    log.debug('Disconnecting all browsers')\n\n    var remaining = 0\n    var finish = function () {\n      remaining--\n      if (!remaining && callback) {\n        callback()\n      }\n    }\n\n    if (!self._browsers.length) {\n      return process.nextTick(callback)\n    }\n\n    self._browsers.forEach(function (browser) {\n      remaining++\n      browser.forceKill().then(finish)\n    })\n  }\n\n  this.areAllCaptured = function () {\n    return !self._browsers.some(function (browser) {\n      return !browser.isCaptured()\n    })\n  }\n\n  this.markCaptured = function (id) {\n    self._browsers.forEach(function (browser) {\n      if (browser.id === id) {\n        browser.markCaptured()\n        log.debug('%s (id %s) captured in %d secs', browser.name, browser.id,\n          (Date.now() - lastStartTime) / 1000)\n      }\n    })\n  }\n\n  // register events\n  emitter.on('exit', this.killAll)\n}\n\nLauncher.$inject = ['server', 'emitter', 'injector']\n\nLauncher.generateId = function () {\n  return '' + Math.floor(Math.random() * 100000000)\n}\n\n// PUBLISH\nexports.Launcher = Launcher\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/launchers/base.js":"var KarmaEventEmitter = require('../events').EventEmitter\nvar EventEmitter = require('events').EventEmitter\nvar Promise = require('bluebird')\n\nvar log = require('../logger').create('launcher')\nvar helper = require('../helper')\n\nvar BEING_CAPTURED = 1\nvar CAPTURED = 2\nvar BEING_KILLED = 3\nvar FINISHED = 4\nvar RESTARTING = 5\nvar BEING_FORCE_KILLED = 6\n\n/**\n * Base launcher that any custom launcher extends.\n */\nvar BaseLauncher = function (id, emitter) {\n  if (this.start) {\n    return\n  }\n\n  // TODO(vojta): figure out how to do inheritance with DI\n  Object.keys(EventEmitter.prototype).forEach(function (method) {\n    this[method] = EventEmitter.prototype[method]\n  }, this)\n  KarmaEventEmitter.call(this)\n\n  this.id = id\n  this.state = null\n  this.error = null\n\n  var self = this\n  var killingPromise\n  var previousUrl\n\n  this.start = function (url) {\n    previousUrl = url\n\n    this.error = null\n    this.state = BEING_CAPTURED\n    this.emit('start', url + '?id=' + this.id + (helper.isDefined(self.displayName) ? '&displayName=' + encodeURIComponent(self.displayName) : ''))\n  }\n\n  this.kill = function () {\n    // Already killed, or being killed.\n    if (killingPromise) {\n      return killingPromise\n    }\n\n    killingPromise = this.emitAsync('kill').then(function () {\n      self.state = FINISHED\n    })\n\n    this.state = BEING_KILLED\n\n    return killingPromise\n  }\n\n  this.forceKill = function () {\n    this.kill()\n    this.state = BEING_FORCE_KILLED\n\n    return killingPromise\n  }\n\n  this.restart = function () {\n    if (this.state === BEING_FORCE_KILLED) {\n      return\n    }\n\n    if (!killingPromise) {\n      killingPromise = this.emitAsync('kill')\n    }\n\n    killingPromise.then(function () {\n      if (self.state === BEING_FORCE_KILLED) {\n        self.state = FINISHED\n      } else {\n        killingPromise = null\n        log.debug('Restarting %s', self.name)\n        self.start(previousUrl)\n      }\n    })\n\n    self.state = RESTARTING\n  }\n\n  this.markCaptured = function () {\n    if (this.state === BEING_CAPTURED) {\n      this.state = CAPTURED\n    }\n  }\n\n  this.isCaptured = function () {\n    return this.state === CAPTURED\n  }\n\n  this.toString = function () {\n    return this.name\n  }\n\n  this._done = function (error) {\n    killingPromise = killingPromise || Promise.resolve()\n\n    this.error = this.error || error\n    this.emit('done')\n\n    if (this.error && this.state !== BEING_FORCE_KILLED && this.state !== RESTARTING) {\n      emitter.emit('browser_process_failure', this)\n    }\n\n    this.state = FINISHED\n  }\n\n  this.STATE_BEING_CAPTURED = BEING_CAPTURED\n  this.STATE_CAPTURED = CAPTURED\n  this.STATE_BEING_KILLED = BEING_KILLED\n  this.STATE_FINISHED = FINISHED\n  this.STATE_RESTARTING = RESTARTING\n  this.STATE_BEING_FORCE_KILLED = BEING_FORCE_KILLED\n}\n\nBaseLauncher.decoratorFactory = function (id, emitter) {\n  return function (launcher) {\n    BaseLauncher.call(launcher, id, emitter)\n  }\n}\n\nmodule.exports = BaseLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/events.js":"var events = require('events')\nvar util = require('util')\n\nvar helper = require('./helper')\n\nvar bindAllEvents = function (object, context) {\n  context = context || this\n\n  var bindMethod = function (method) {\n    context.on(helper.camelToSnake(method.substr(2)), function () {\n      var args = Array.prototype.slice.call(arguments, 0)\n      args.push(context)\n      object[method].apply(object, args)\n    })\n  }\n\n  for (var method in object) {\n    if (helper.isFunction(object[method]) && method.substr(0, 2) === 'on') {\n      bindMethod(method)\n    }\n  }\n}\n\nvar bufferEvents = function (emitter, eventsToBuffer) {\n  var listeners = []\n  var eventsToReply = []\n  var genericListener = function () {\n    eventsToReply.push(Array.prototype.slice.call(arguments))\n  }\n\n  eventsToBuffer.forEach(function (eventName) {\n    var listener = genericListener.bind(null, eventName)\n    listeners.push(listener)\n    emitter.on(eventName, listener)\n  })\n\n  return function () {\n    if (!eventsToReply) {\n      return\n    }\n\n    // remove all buffering listeners\n    listeners.forEach(function (listener, i) {\n      emitter.removeListener(eventsToBuffer[i], listener)\n    })\n\n    // reply\n    eventsToReply.forEach(function (args) {\n      events.EventEmitter.prototype.emit.apply(emitter, args)\n    })\n\n    // free-up\n    listeners = eventsToReply = null\n  }\n}\n\n// TODO(vojta): log.debug all events\nvar EventEmitter = function () {\n  this.bind = bindAllEvents\n\n  this.emitAsync = function (name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    var pending = this.listeners(name).length\n    var deferred = helper.defer()\n    var done = function () {\n      if (!--pending) {\n        deferred.resolve()\n      }\n    }\n\n    this.emit(name, done)\n\n    if (!pending) {\n      deferred.resolve()\n    }\n\n    return deferred.promise\n  }\n}\n\nutil.inherits(EventEmitter, events.EventEmitter)\n\n// PUBLISH\nexports.EventEmitter = EventEmitter\nexports.bindAll = bindAllEvents\nexports.bufferEvents = bufferEvents\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/launchers/capture_timeout.js":"var log = require('../logger').create('launcher')\n\n/**\n * Kill browser if it does not capture in given `captureTimeout`.\n */\nvar CaptureTimeoutLauncher = function (timer, captureTimeout) {\n  if (!captureTimeout) {\n    return\n  }\n\n  var self = this\n  var pendingTimeoutId = null\n\n  this.on('start', function () {\n    pendingTimeoutId = timer.setTimeout(function () {\n      pendingTimeoutId = null\n      if (self.state !== self.STATE_BEING_CAPTURED) {\n        return\n      }\n\n      log.warn('%s have not captured in %d ms, killing.', self.name, captureTimeout)\n      self.error = 'timeout'\n      self.kill()\n    }, captureTimeout)\n  })\n\n  this.on('done', function () {\n    if (pendingTimeoutId) {\n      timer.clearTimeout(pendingTimeoutId)\n      pendingTimeoutId = null\n    }\n  })\n}\n\nCaptureTimeoutLauncher.decoratorFactory = function (timer,\n  /* config.captureTimeout */ captureTimeout) {\n  return function (launcher) {\n    CaptureTimeoutLauncher.call(launcher, timer, captureTimeout)\n  }\n}\n\nCaptureTimeoutLauncher.decoratorFactory.$inject = ['timer', 'config.captureTimeout']\n\nmodule.exports = CaptureTimeoutLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/launchers/retry.js":"var log = require('../logger').create('launcher')\n\nvar RetryLauncher = function (retryLimit) {\n  var self = this\n\n  this._retryLimit = retryLimit\n\n  this.on('done', function () {\n    if (!self.error) {\n      return\n    }\n\n    if (self._retryLimit > 0) {\n      var attempt = retryLimit - self._retryLimit + 1\n      log.info('Trying to start %s again (%d/%d).', self.name, attempt, retryLimit)\n      self.restart()\n      self._retryLimit--\n    } else if (self._retryLimit === 0) {\n      log.error('%s failed %d times (%s). Giving up.', self.name, retryLimit, self.error)\n    } else {\n      log.debug('%s failed (%s). Not restarting.', self.name, self.error)\n    }\n  })\n}\n\nRetryLauncher.decoratorFactory = function (retryLimit) {\n  return function (launcher) {\n    RetryLauncher.call(launcher, retryLimit)\n  }\n}\n\nRetryLauncher.decoratorFactory.$inject = ['config.retryLimit']\n\nmodule.exports = RetryLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/launchers/process.js":"var path = require('path')\nvar log = require('../logger').create('launcher')\nvar env = process.env\n\nvar ProcessLauncher = function (spawn, tempDir, timer, processKillTimeout) {\n  var self = this\n  var onExitCallback\n  var killTimeout = processKillTimeout || 2000\n\n  this._tempDir = tempDir.getPath('/karma-' + this.id.toString())\n\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir)\n    self._start(url)\n  })\n\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done)\n    }\n\n    onExitCallback = done\n    self._process.kill()\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)\n  })\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url))\n  }\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]\n  }\n\n  this._getOptions = function (url) {\n    return [url]\n  }\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.indexOf(cmd.charAt(0)) !== -1) {\n      cmd = cmd.substring(1, cmd.length - 1)\n      log.warn('The path should not be quoted.\\n  Normalized the path to %s', cmd)\n    }\n\n    return path.normalize(cmd)\n  }\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error('No binary for %s browser on your platform.\\n  ' +\n        'Please, set \"%s\" env variable.', self.name, self.ENV_CMD)\n\n      // disable restarting\n      self._retryLimit = -1\n\n      return self._clearTempDirAndReportDone('no binary')\n    }\n\n    cmd = this._normalizeCommand(cmd)\n\n    log.debug(cmd + ' ' + args.join(' '))\n    self._process = spawn(cmd, args)\n\n    var errorOutput = ''\n\n    self._process.on('exit', function (code) {\n      self._onProcessExit(code, errorOutput)\n    })\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1\n        errorOutput = 'Can not find the binary ' + cmd + '\\n\\t' +\n          'Please set env variable ' + self.ENV_CMD\n      } else {\n        errorOutput += err.toString()\n      }\n    })\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString()\n    })\n  }\n\n  this._onProcessExit = function (code, errorOutput) {\n    log.debug('Process %s exited with code %d', self.name, code)\n\n    var error = null\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error('Cannot start %s\\n\\t%s', self.name, errorOutput)\n      error = 'cannot start'\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error('%s crashed.\\n\\t%s', self.name, errorOutput)\n      error = 'crashed'\n    }\n\n    self._process = null\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer)\n      self._killTimer = null\n    }\n    self._clearTempDirAndReportDone(error)\n  }\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error)\n      if (onExitCallback) {\n        onExitCallback()\n        onExitCallback = null\n      }\n    })\n  }\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return\n    }\n\n    log.warn('%s was not killed in %d ms, sending SIGKILL.', self.name, killTimeout)\n    self._process.kill('SIGKILL')\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn('%s was not killed by SIGKILL in %d ms, continuing.', self.name, killTimeout)\n      self._onProcessExit(-1, '')\n    }, killTimeout)\n  }\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    var spawn = require('child_process').spawn\n\n    var spawnWithoutOutput = function () {\n      var proc = spawn.apply(null, arguments)\n      proc.stdout.resume()\n      proc.stderr.resume()\n\n      return proc\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)\n  }\n}\n\nmodule.exports = ProcessLauncher\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/file-list.js":"// File List\n// =========\n//\n// The List is an object for tracking all files that karma knows about\n// currently.\n\n// Dependencies\n// ------------\n\nrequire('core-js')\nvar from = require('core-js/library/fn/array/from')\nvar Promise = require('bluebird')\nvar mm = require('minimatch')\nvar Glob = require('glob').Glob\nvar fs = Promise.promisifyAll(require('graceful-fs'))\nvar pathLib = require('path')\nvar _ = require('lodash')\n\nvar File = require('./file')\nvar Url = require('./url')\nvar helper = require('./helper')\nvar log = require('./logger').create('watcher')\nvar createPatternObject = require('./config').createPatternObject\n\n// Constants\n// ---------\n\nvar GLOB_OPTS = {\n  cwd: '/',\n  follow: true,\n  nodir: true,\n  sync: true\n}\n\n// Helper Functions\n// ----------------\n\nfunction byPath (a, b) {\n  if (a.path > b.path) return 1\n  if (a.path < b.path) return -1\n\n  return 0\n}\n\n// Constructor\n//\n// patterns      - Array\n// excludes      - Array\n// emitter       - EventEmitter\n// preprocess    - Function\n// batchInterval - Number\nvar List = function (patterns, excludes, emitter, preprocess, batchInterval) {\n  // Store options\n  this._patterns = patterns\n  this._excludes = excludes\n  this._emitter = emitter\n  this._preprocess = Promise.promisify(preprocess)\n  this._batchInterval = batchInterval\n\n  // The actual list of files\n  this.buckets = new Map()\n\n  // Internal tracker if we are refreshing.\n  // When a refresh is triggered this gets set\n  // to the promise that `this._refresh` returns.\n  // So we know we are refreshing when this promise\n  // is still pending, and we are done when it's either\n  // resolved or rejected.\n  this._refreshing = Promise.resolve()\n\n  var self = this\n\n  // Emit the `file_list_modified` event.\n  // This function is throttled to the value of `batchInterval`\n  // to avoid spamming the listener.\n  function emit () {\n    self._emitter.emit('file_list_modified', self.files)\n  }\n  var throttledEmit = _.throttle(emit, self._batchInterval, {leading: false})\n  self._emitModified = function (immediate) {\n    immediate ? emit() : throttledEmit()\n  }\n}\n\n// Private Interface\n// -----------------\n\n// Is the given path matched by any exclusion filter\n//\n// path - String\n//\n// Returns `undefined` if no match, otherwise the matching\n// pattern.\nList.prototype._isExcluded = function (path) {\n  return _.find(this._excludes, function (pattern) {\n    return mm(path, pattern)\n  })\n}\n\n// Find the matching include pattern for the given path.\n//\n// path - String\n//\n// Returns the match or `undefined` if none found.\nList.prototype._isIncluded = function (path) {\n  return _.find(this._patterns, function (pattern) {\n    return mm(path, pattern.pattern)\n  })\n}\n\n// Find the given path in the bucket corresponding\n// to the given pattern.\n//\n// path    - String\n// pattern - Object\n//\n// Returns a File or undefined\nList.prototype._findFile = function (path, pattern) {\n  if (!path || !pattern) return\n  if (!this.buckets.has(pattern.pattern)) return\n\n  return _.find(from(this.buckets.get(pattern.pattern)), function (file) {\n    return file.originalPath === path\n  })\n}\n\n// Is the given path already in the files list.\n//\n// path - String\n//\n// Returns a boolean.\nList.prototype._exists = function (path) {\n  var self = this\n\n  var patterns = this._patterns.filter(function (pattern) {\n    return mm(path, pattern.pattern)\n  })\n\n  return !!_.find(patterns, function (pattern) {\n    return self._findFile(path, pattern)\n  })\n}\n\n// Check if we are currently refreshing\nList.prototype._isRefreshing = function () {\n  return this._refreshing.isPending()\n}\n\n// Do the actual work of refreshing\nList.prototype._refresh = function () {\n  var self = this\n  var buckets = this.buckets\n  var matchedFiles = new Set()\n\n  var promise = Promise.map(this._patterns, function (patternObject) {\n    var pattern = patternObject.pattern\n\n    if (helper.isUrlAbsolute(pattern)) {\n      buckets.set(pattern, new Set([new Url(pattern)]))\n      return Promise.resolve()\n    }\n\n    var mg = new Glob(pathLib.normalize(pattern), GLOB_OPTS)\n    var files = mg.found\n    buckets.set(pattern, new Set())\n\n    if (_.isEmpty(files)) {\n      log.warn('Pattern \"%s\" does not match any file.', pattern)\n      return\n    }\n\n    return Promise.map(files, function (path) {\n      if (self._isExcluded(path)) {\n        log.debug('Excluded file \"%s\"', path)\n        return Promise.resolve()\n      }\n\n      if (matchedFiles.has(path)) {\n        return Promise.resolve()\n      }\n\n      matchedFiles.add(path)\n\n      var mtime = mg.statCache[path].mtime\n      var doNotCache = patternObject.nocache\n      var file = new File(path, mtime, doNotCache)\n\n      if (file.doNotCache) {\n        log.debug('Not preprocessing \"%s\" due to nocache')\n        return Promise.resolve(file)\n      }\n\n      return self._preprocess(file).then(function () {\n        return file\n      })\n    })\n    .then(function (files) {\n      files = _.compact(files)\n\n      if (_.isEmpty(files)) {\n        log.warn('All files matched by \"%s\" were excluded or matched by prior matchers.', pattern)\n      } else {\n        buckets.set(pattern, new Set(files))\n      }\n    })\n  })\n  .then(function () {\n    if (self._refreshing !== promise) {\n      return self._refreshing\n    }\n    self.buckets = buckets\n    self._emitModified(true)\n    return self.files\n  })\n\n  return promise\n}\n\n// Public Interface\n// ----------------\n\nObject.defineProperty(List.prototype, 'files', {\n  get: function () {\n    var self = this\n    var uniqueFlat = function (list) {\n      return _.uniq(_.flatten(list), 'path')\n    }\n\n    var expandPattern = function (p) {\n      return from(self.buckets.get(p.pattern) || []).sort(byPath)\n    }\n\n    var served = this._patterns.filter(function (pattern) {\n      return pattern.served\n    })\n    .map(expandPattern)\n\n    var lookup = {}\n    var included = {}\n    this._patterns.forEach(function (p) {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      var bucket = expandPattern(p)\n      bucket.forEach(function (file) {\n        var other = lookup[file.path]\n        if (other && other.compare(p) < 0) return\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: uniqueFlat(served),\n      included: _.values(included)\n    }\n  }\n})\n\n// Reglob all patterns to update the list.\n//\n// Returns a promise that is resolved when the refresh\n// is completed.\nList.prototype.refresh = function () {\n  this._refreshing = this._refresh()\n  return this._refreshing\n}\n\n// Set new patterns and excludes and update\n// the list accordingly\n//\n// patterns - Array, the new patterns.\n// excludes - Array, the new exclude patterns.\n//\n// Returns a promise that is resolved when the refresh\n// is completed.\nList.prototype.reload = function (patterns, excludes) {\n  this._patterns = patterns\n  this._excludes = excludes\n\n  // Wait until the current refresh is done and then do a\n  // refresh to ensure a refresh actually happens\n  return this.refresh()\n}\n\n// Add a new file from the list.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.addFile = function (path) {\n  var self = this\n\n  // Ensure we are not adding a file that should be excluded\n  var excluded = this._isExcluded(path)\n  if (excluded) {\n    log.debug('Add file \"%s\" ignored. Excluded by \"%s\".', path, excluded)\n\n    return Promise.resolve(this.files)\n  }\n\n  var pattern = this._isIncluded(path)\n\n  if (!pattern) {\n    log.debug('Add file \"%s\" ignored. Does not match any pattern.', path)\n    return Promise.resolve(this.files)\n  }\n\n  if (this._exists(path)) {\n    log.debug('Add file \"%s\" ignored. Already in the list.', path)\n    return Promise.resolve(this.files)\n  }\n\n  var file = new File(path)\n  this.buckets.get(pattern.pattern).add(file)\n\n  return Promise.all([\n    fs.statAsync(path),\n    this._refreshing\n  ]).spread(function (stat) {\n    file.mtime = stat.mtime\n    return self._preprocess(file)\n  })\n  .then(function () {\n    log.info('Added file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n}\n\n// Update the `mtime` of a file.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.changeFile = function (path) {\n  var self = this\n\n  var pattern = this._isIncluded(path)\n  var file = this._findFile(path, pattern)\n\n  if (!pattern || !file) {\n    log.debug('Changed file \"%s\" ignored. Does not match any file in the list.', path)\n    return Promise.resolve(this.files)\n  }\n\n  return Promise.all([\n    fs.statAsync(path),\n    this._refreshing\n  ]).spread(function (stat) {\n    if (stat.mtime <= file.mtime) throw new Promise.CancellationError()\n\n    file.mtime = stat.mtime\n    return self._preprocess(file)\n  })\n  .then(function () {\n    log.info('Changed file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n  .catch(Promise.CancellationError, function () {\n    return self.files\n  })\n}\n\n// Remove a file from the list.\n// This is called by the watcher\n//\n// path - String, the path of the file to update.\n//\n// Returns a promise that is resolved when the update\n// is completed.\nList.prototype.removeFile = function (path) {\n  var self = this\n\n  return Promise.try(function () {\n    var pattern = self._isIncluded(path)\n    var file = self._findFile(path, pattern)\n\n    if (!pattern || !file) {\n      log.debug('Removed file \"%s\" ignored. Does not match any file in the list.', path)\n      return self.files\n    }\n\n    self.buckets.get(pattern.pattern).delete(file)\n\n    log.info('Removed file \"%s\".', path)\n    self._emitModified()\n    return self.files\n  })\n}\n\n// Inject dependencies\nList.$inject = ['config.files', 'config.exclude', 'emitter', 'preprocess',\n  'config.autoWatchBatchDelay']\n\n// PUBLIC\nmodule.exports = List\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/file.js":"// File\n// ====\n//\n// File object used for tracking files in `file-list.js`\n\n// Dependencies\n// ------------\n\nvar _ = require('lodash')\n\n// Constructor\nvar File = function (path, mtime, doNotCache) {\n  // used for serving (processed path, eg some/file.coffee -> some/file.coffee.js)\n  this.path = path\n\n  // original absolute path, id of the file\n  this.originalPath = path\n\n  // where the content is stored (processed)\n  this.contentPath = path\n\n  this.mtime = mtime\n  this.isUrl = false\n\n  this.doNotCache = _.isUndefined(doNotCache) ? false : doNotCache\n}\n\nFile.prototype.toString = function () {\n  return this.path\n}\n\n// PUBLIC\nmodule.exports = File\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/url.js":"// Url\n// ===\n//\n// Url object used for tracking files in `file-list.js`\n\nvar Url = function (path) {\n  this.path = path\n  this.isUrl = true\n}\n\nUrl.prototype.toString = function () {\n  return this.path\n}\n\n// PUBLIC\nmodule.exports = Url\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/reporter.js":"var util = require('util')\nvar resolve = require('url').resolve\nvar SourceMapConsumer = require('source-map').SourceMapConsumer\nvar WeakMap = require('core-js/es6/weak-map')\nvar _ = require('lodash')\n\nvar log = require('./logger').create('reporter')\nvar MultiReporter = require('./reporters/multi')\nvar baseReporterDecoratorFactory = require('./reporters/base').decoratorFactory\n\nvar createErrorFormatter = function (config, emitter, SourceMapConsumer) {\n  var basePath = config.basePath\n  var lastServedFiles = []\n\n  emitter.on('file_list_modified', function (files) {\n    lastServedFiles = files.served\n  })\n\n  var findFile = function (path) {\n    for (var i = 0; i < lastServedFiles.length; i++) {\n      if (lastServedFiles[i].path === path) {\n        return lastServedFiles[i]\n      }\n    }\n    return null\n  }\n\n  var URL_REGEXP = new RegExp('(?:https?:\\\\/\\\\/' +\n    config.hostname + '(?:\\\\:' + config.port + ')?' + ')?\\\\/?' +\n    '(base/|absolute)' + // prefix, including slash for base/ to create relative paths.\n    '((?:[A-z]\\\\:)?[^\\\\?\\\\s\\\\:]*)' + // path\n    '(\\\\?\\\\w*)?' + // sha\n    '(\\\\:(\\\\d+))?' + // line\n    '(\\\\:(\\\\d+))?' + // column\n    '', 'g')\n\n  var getSourceMapConsumer = (function () {\n    var cache = new WeakMap()\n    return function (sourceMap) {\n      if (!cache.has(sourceMap)) {\n        cache.set(sourceMap, new SourceMapConsumer(sourceMap))\n      }\n      return cache.get(sourceMap)\n    }\n  }())\n\n  return function (input, indentation) {\n    indentation = _.isString(indentation) ? indentation : ''\n    if (_.isError(input)) {\n      input = input.message\n    } else if (_.isEmpty(input)) {\n      input = ''\n    } else if (!_.isString(input)) {\n      input = JSON.stringify(input, null, indentation)\n    }\n\n    // remove domain and timestamp from source files\n    // and resolve base path / absolute path urls into absolute path\n    var msg = input.replace(URL_REGEXP, function (_, prefix, path, __, ___, line, ____, column) {\n      // Find the file using basePath + path, but use the more readable path down below.\n      var file = findFile(prefix === 'base/' ? basePath + '/' + path : path)\n\n      if (file && file.sourceMap && line) {\n        line = parseInt(line || '0', 10)\n\n        column = parseInt(column, 10)\n\n        // When no column is given and we default to 0, it doesn't make sense to only search for smaller\n        // or equal columns in the sourcemap, let's search for equal or greater columns.\n        var bias = column ? SourceMapConsumer.GREATEST_LOWER_BOUND : SourceMapConsumer.LEAST_UPPER_BOUND\n\n        try {\n          var original = getSourceMapConsumer(file.sourceMap)\n            .originalPositionFor({line: line, column: (column || 0), bias: bias})\n\n          // Source maps often only have a local file name, resolve to turn into a full path if\n          // the path is not absolute yet.\n          var sourcePath = resolve(path, original.source)\n          var formattedColumn = column ? util.format(':%s', column) : ''\n          return util.format('%s:%d:%d <- %s:%d%s', sourcePath, original.line, original.column,\n              path, line, formattedColumn)\n        } catch (e) {\n          log.warn('SourceMap position not found for trace: %s', msg)\n          // Fall back to non-source-mapped formatting.\n        }\n      }\n\n      var result = path + (line ? ':' + line : '') + (column ? ':' + column : '')\n      return result || prefix\n    })\n\n    // indent every line\n    if (indentation) {\n      msg = indentation + msg.replace(/\\n/g, '\\n' + indentation)\n    }\n\n    // allow the user to format the error\n    if (config.formatError) {\n      return config.formatError(msg)\n    }\n\n    return msg + '\\n'\n  }\n}\n\nvar createReporters = function (names, config, emitter, injector) {\n  var errorFormatter = createErrorFormatter(config, emitter, SourceMapConsumer)\n  var reporters = []\n\n  // TODO(vojta): instantiate all reporters through DI\n  names.forEach(function (name) {\n    if (['dots', 'progress'].indexOf(name) !== -1) {\n      var Cls = require('./reporters/' + name)\n      var ClsColor = require('./reporters/' + name + '_color')\n      reporters.push(new Cls(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions))\n      return reporters.push(new ClsColor(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions))\n    }\n\n    var locals = {\n      baseReporterDecorator: ['factory', baseReporterDecoratorFactory],\n      formatError: ['value', errorFormatter]\n    }\n\n    try {\n      log.debug('Trying to load reporter: %s', name)\n      reporters.push(injector.createChild([locals], ['reporter:' + name]).get('reporter:' + name))\n    } catch (e) {\n      if (e.message.indexOf('No provider for \"reporter:' + name + '\"') !== -1) {\n        log.error('Can not load reporter \"%s\", it is not registered!\\n  ' +\n          'Perhaps you are missing some plugin?', name)\n      } else {\n        log.error('Can not load \"%s\"!\\n  ' + e.stack, name)\n      }\n      emitter.emit('load_error', 'reporter', name)\n      return\n    }\n    var colorName = name + '_color'\n    if (names.indexOf(colorName) !== -1) {\n      return\n    }\n    try {\n      log.debug('Trying to load color-version of reporter: %s (%s)', name, colorName)\n      reporters.push(injector.createChild([locals], ['reporter:' + name + '_color']).get('reporter:' + name))\n    } catch (e) {\n      log.debug('Couldn\\'t load color-version.')\n    }\n  })\n\n  // bind all reporters\n  reporters.forEach(function (reporter) {\n    emitter.bind(reporter)\n  })\n\n  return new MultiReporter(reporters)\n}\n\ncreateReporters.$inject = [\n  'config.reporters',\n  'config',\n  'emitter',\n  'injector'\n]\n\n// PUBLISH\nexports.createReporters = createReporters\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/reporters/multi.js":"var helper = require('../helper')\n\nvar MultiReporter = function (reporters) {\n  this.addAdapter = function (adapter) {\n    reporters.forEach(function (reporter) {\n      reporter.adapters.push(adapter)\n    })\n  }\n\n  this.removeAdapter = function (adapter) {\n    reporters.forEach(function (reporter) {\n      helper.arrayRemove(reporter.adapters, adapter)\n    })\n  }\n}\n\n// PUBLISH\nmodule.exports = MultiReporter\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/reporters/base.js":"var util = require('util')\n\nvar constants = require('../constants')\nvar helper = require('../helper')\n\nvar BaseReporter = function (formatError, reportSlow, useColors, browserConsoleLogOptions, adapter) {\n  this.adapters = [adapter || process.stdout.write.bind(process.stdout)]\n\n  this.onRunStart = function () {\n    this._browsers = []\n  }\n\n  this.onBrowserStart = function (browser) {\n    this._browsers.push(browser)\n  }\n\n  this.renderBrowser = function (browser) {\n    var results = browser.lastResult\n    var totalExecuted = results.success + results.failed\n    var msg = util.format('%s: Executed %d of %d', browser, totalExecuted, results.total)\n\n    if (results.failed) {\n      msg += util.format(this.X_FAILED, results.failed)\n    }\n\n    if (results.skipped) {\n      msg += util.format(' (skipped %d)', results.skipped)\n    }\n\n    if (browser.isReady) {\n      if (results.disconnected) {\n        msg += this.FINISHED_DISCONNECTED\n      } else if (results.error) {\n        msg += this.FINISHED_ERROR\n      } else if (!results.failed) {\n        msg += this.FINISHED_SUCCESS\n      }\n\n      msg += util.format(' (%s / %s)', helper.formatTimeInterval(results.totalTime),\n        helper.formatTimeInterval(results.netTime))\n    }\n\n    return msg\n  }\n\n  this.renderBrowser = this.renderBrowser.bind(this)\n\n  this.write = function () {\n    var msg = util.format.apply(null, Array.prototype.slice.call(arguments))\n    var self = this\n    this.adapters.forEach(function (adapter) {\n      if (!helper.isDefined(adapter.colors)) {\n        adapter.colors = useColors\n      }\n      if (!helper.isDefined(self.EXCLUSIVELY_USE_COLORS) || adapter.colors === self.EXCLUSIVELY_USE_COLORS) {\n        return adapter(msg)\n      }\n    })\n  }\n\n  this.writeCommonMsg = this.write\n\n  this.onBrowserError = function (browser, error) {\n    this.writeCommonMsg(util.format(this.ERROR, browser) + formatError(error, '  '))\n  }\n\n  this.onBrowserLog = function (browser, log, type) {\n    if (!browserConsoleLogOptions || !browserConsoleLogOptions.terminal) return\n    type = type.toUpperCase()\n    if (browserConsoleLogOptions.level) {\n      var logPriority = constants.LOG_PRIORITIES.indexOf(browserConsoleLogOptions.level.toUpperCase())\n      if (constants.LOG_PRIORITIES.indexOf(type) > logPriority) return\n    }\n    if (!helper.isString(log)) {\n      // TODO(vojta): change util to new syntax (config object)\n      log = util.inspect(log, false, undefined, this.USE_COLORS)\n    }\n    if (this._browsers && this._browsers.length === 1) {\n      this.writeCommonMsg(util.format(this.LOG_SINGLE_BROWSER, type, log))\n    } else {\n      this.writeCommonMsg(util.format(this.LOG_MULTI_BROWSER, browser, type, log))\n    }\n  }\n\n  this.onSpecComplete = function (browser, result) {\n    if (result.skipped) {\n      this.specSkipped(browser, result)\n    } else if (result.success) {\n      this.specSuccess(browser, result)\n    } else {\n      this.specFailure(browser, result)\n    }\n\n    if (reportSlow && result.time > reportSlow) {\n      var specName = result.suite.join(' ') + ' ' + result.description\n      var time = helper.formatTimeInterval(result.time)\n\n      this.writeCommonMsg(util.format(this.SPEC_SLOW, browser, time, specName))\n    }\n  }\n\n  this.specSuccess = this.specSkipped = function () {\n  }\n\n  this.specFailure = function (browser, result) {\n    var specName = result.suite.join(' ') + ' ' + result.description\n    var msg = util.format(this.SPEC_FAILURE, browser, specName)\n\n    result.log.forEach(function (log) {\n      msg += formatError(log, '\\t')\n    })\n\n    this.writeCommonMsg(msg)\n  }\n\n  this.onRunComplete = function (browsers, results) {\n    if (browsers.length > 1 && !results.error && !results.disconnected) {\n      if (!results.failed) {\n        this.write(this.TOTAL_SUCCESS, results.success)\n      } else {\n        this.write(this.TOTAL_FAILED, results.failed, results.success)\n      }\n    }\n  }\n\n  this.USE_COLORS = false\n  this.EXCLUSIVELY_USE_COLORS = undefined\n  this.LOG_SINGLE_BROWSER = '%s: %s\\n'\n  this.LOG_MULTI_BROWSER = '%s %s: %s\\n'\n\n  this.SPEC_FAILURE = '%s %s FAILED' + '\\n'\n  this.SPEC_SLOW = '%s SLOW %s: %s\\n'\n  this.ERROR = '%s ERROR\\n'\n\n  this.FINISHED_ERROR = ' ERROR'\n  this.FINISHED_SUCCESS = ' SUCCESS'\n  this.FINISHED_DISCONNECTED = ' DISCONNECTED'\n\n  this.X_FAILED = ' (%d FAILED)'\n\n  this.TOTAL_SUCCESS = 'TOTAL: %d SUCCESS\\n'\n  this.TOTAL_FAILED = 'TOTAL: %d FAILED, %d SUCCESS\\n'\n}\n\nBaseReporter.decoratorFactory = function (formatError, reportSlow, useColors, browserConsoleLogOptions) {\n  return function (self) {\n    BaseReporter.call(self, formatError, reportSlow, useColors, browserConsoleLogOptions)\n  }\n}\n\nBaseReporter.decoratorFactory.$inject = [\n  'formatError',\n  'config.reportSlowerThan',\n  'config.colors',\n  'config.browserConsoleLogOptions'\n]\n\n// PUBLISH\nmodule.exports = BaseReporter\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/executor.js":"var log = require('./logger').create()\n\nvar Executor = function (capturedBrowsers, config, emitter) {\n  var self = this\n  var executionScheduled = false\n  var pendingCount = 0\n  var runningBrowsers\n\n  var schedule = function () {\n    var nonReady = []\n\n    if (!capturedBrowsers.length) {\n      log.warn('No captured browser, open %s//%s:%s%s', config.protocol, config.hostname,\n        config.port, config.urlRoot)\n      return false\n    }\n\n    if (capturedBrowsers.areAllReady(nonReady)) {\n      log.debug('All browsers are ready, executing')\n      log.debug('Captured %s browsers', capturedBrowsers.length)\n      executionScheduled = false\n      capturedBrowsers.clearResults()\n      capturedBrowsers.setAllToExecuting()\n      pendingCount = capturedBrowsers.length\n      runningBrowsers = capturedBrowsers.clone()\n      emitter.emit('run_start', runningBrowsers)\n      self.socketIoSockets.emit('execute', config.client)\n      return true\n    }\n\n    log.info('Delaying execution, these browsers are not ready: ' + nonReady.join(', '))\n    executionScheduled = true\n    return false\n  }\n\n  this.schedule = schedule\n\n  this.onRunComplete = function () {\n    if (executionScheduled) {\n      schedule()\n    }\n  }\n\n  this.onBrowserComplete = function () {\n    pendingCount--\n\n    if (!pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(function () {\n        emitter.emit('run_complete', runningBrowsers, runningBrowsers.getResults())\n      }, 0)\n    }\n  }\n\n  // bind all the events\n  emitter.bind(this)\n}\n\nmodule.exports = Executor\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/browser.js":"var helper = require('./helper')\nvar events = require('./events')\nvar logger = require('./logger')\n\nvar Result = require('./browser_result')\n\n// The browser is ready to execute tests.\nvar READY = 1\n\n// The browser is executing the tests.\nvar EXECUTING = 2\n\n// The browser is not executing, but temporarily disconnected (waiting for reconnecting).\nvar READY_DISCONNECTED = 3\n\n// The browser is executing the tests, but temporarily disconnect (waiting for reconnecting).\nvar EXECUTING_DISCONNECTED = 4\n\n// The browser got permanently disconnected (being removed from the collection and destroyed).\nvar DISCONNECTED = 5\n\nvar Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,\n  /* config.browserDisconnectTimeout */ disconnectDelay,\n  /* config.browserNoActivityTimeout */ noActivityTimeout) {\n  var name = helper.browserFullNameToShort(fullName)\n  var log = logger.create(name)\n  var activeSockets = [socket]\n  var activeSocketsIds = function () {\n    return activeSockets.map(function (s) {\n      return s.id\n    }).join(', ')\n  }\n\n  var self = this\n  var pendingDisconnect\n  var disconnect = function (reason) {\n    self.state = DISCONNECTED\n    self.disconnectsCount++\n    log.warn('Disconnected (%d times)' + (reason || ''), self.disconnectsCount)\n    emitter.emit('browser_error', self, 'Disconnected' + reason)\n    collection.remove(self)\n  }\n\n  var noActivityTimeoutId\n  var refreshNoActivityTimeout = noActivityTimeout ? function () {\n    clearNoActivityTimeout()\n    noActivityTimeoutId = timer.setTimeout(function () {\n      self.lastResult.totalTimeEnd()\n      self.lastResult.disconnected = true\n      disconnect(', because no message in ' + noActivityTimeout + ' ms.')\n      emitter.emit('browser_complete', self)\n    }, noActivityTimeout)\n  } : function () {}\n\n  var clearNoActivityTimeout = noActivityTimeout ? function () {\n    if (noActivityTimeoutId) {\n      timer.clearTimeout(noActivityTimeoutId)\n      noActivityTimeoutId = null\n    }\n  } : function () {}\n\n  this.id = id\n  this.fullName = fullName\n  this.name = name\n  this.state = READY\n  this.lastResult = new Result()\n  this.disconnectsCount = 0\n\n  this.init = function () {\n    collection.add(this)\n\n    events.bindAll(this, socket)\n\n    log.info('Connected on socket %s with id %s', socket.id, id)\n\n    // TODO(vojta): move to collection\n    emitter.emit('browsers_change', collection)\n\n    emitter.emit('browser_register', this)\n  }\n\n  this.isReady = function () {\n    return this.state === READY\n  }\n\n  this.toString = function () {\n    return this.name\n  }\n\n  this.onKarmaError = function (error) {\n    if (this.isReady()) {\n      return\n    }\n\n    this.lastResult.error = true\n    emitter.emit('browser_error', this, error)\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onInfo = function (info) {\n    if (this.isReady()) {\n      return\n    }\n\n    // TODO(vojta): remove\n    if (helper.isDefined(info.dump)) {\n      emitter.emit('browser_log', this, info.dump, 'dump')\n    }\n\n    if (helper.isDefined(info.log)) {\n      emitter.emit('browser_log', this, info.log, info.type)\n    }\n\n    if (\n      !helper.isDefined(info.log) &&\n      !helper.isDefined(info.dump)\n    ) {\n      emitter.emit('browser_info', this, info)\n    }\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onStart = function (info) {\n    this.lastResult = new Result()\n    this.lastResult.total = info.total\n\n    if (info.total === null) {\n      log.warn('Adapter did not report total number of specs.')\n    }\n\n    emitter.emit('browser_start', this, info)\n    refreshNoActivityTimeout()\n  }\n\n  this.onComplete = function (result) {\n    if (this.isReady()) {\n      return\n    }\n\n    this.state = READY\n    this.lastResult.totalTimeEnd()\n\n    if (!this.lastResult.success) {\n      this.lastResult.error = true\n    }\n\n    emitter.emit('browsers_change', collection)\n    emitter.emit('browser_complete', this, result)\n\n    clearNoActivityTimeout()\n  }\n\n  this.onDisconnect = function (_, disconnectedSocket) {\n    activeSockets.splice(activeSockets.indexOf(disconnectedSocket), 1)\n\n    if (activeSockets.length) {\n      log.debug('Disconnected %s, still have %s', disconnectedSocket.id, activeSocketsIds())\n      return\n    }\n\n    if (this.state === READY) {\n      disconnect()\n    } else if (this.state === EXECUTING) {\n      log.debug('Disconnected during run, waiting %sms for reconnecting.', disconnectDelay)\n      this.state = EXECUTING_DISCONNECTED\n\n      pendingDisconnect = timer.setTimeout(function () {\n        self.lastResult.totalTimeEnd()\n        self.lastResult.disconnected = true\n        disconnect()\n        emitter.emit('browser_complete', self)\n      }, disconnectDelay)\n\n      clearNoActivityTimeout()\n    }\n  }\n\n  this.reconnect = function (newSocket) {\n    if (this.state === EXECUTING_DISCONNECTED) {\n      this.state = EXECUTING\n      log.debug('Reconnected on %s.', newSocket.id)\n    } else if (this.state === EXECUTING || this.state === READY) {\n      log.debug('New connection %s (already have %s)', newSocket.id, activeSocketsIds())\n    } else if (this.state === DISCONNECTED) {\n      this.state = READY\n      log.info('Connected on socket %s with id %s', newSocket.id, this.id)\n      collection.add(this)\n\n      // TODO(vojta): move to collection\n      emitter.emit('browsers_change', collection)\n\n      emitter.emit('browser_register', this)\n    }\n\n    var exists = activeSockets.some(function (s) {\n      return s.id === newSocket.id\n    })\n    if (!exists) {\n      activeSockets.push(newSocket)\n      events.bindAll(this, newSocket)\n    }\n\n    if (pendingDisconnect) {\n      timer.clearTimeout(pendingDisconnect)\n    }\n\n    refreshNoActivityTimeout()\n  }\n\n  this.onResult = function (result) {\n    if (result.length) {\n      return result.forEach(this.onResult, this)\n    }\n\n    // ignore - probably results from last run (after server disconnecting)\n    if (this.isReady()) {\n      return\n    }\n\n    this.lastResult.add(result)\n\n    emitter.emit('spec_complete', this, result)\n    refreshNoActivityTimeout()\n  }\n\n  this.serialize = function () {\n    return {\n      id: this.id,\n      name: this.name,\n      isReady: this.state === READY\n    }\n  }\n\n  this.execute = function (config) {\n    activeSockets.forEach(function (socket) {\n      socket.emit('execute', config)\n    })\n\n    this.state = EXECUTING\n    refreshNoActivityTimeout()\n  }\n}\n\nBrowser.STATE_READY = READY\nBrowser.STATE_EXECUTING = EXECUTING\nBrowser.STATE_READY_DISCONNECTED = READY_DISCONNECTED\nBrowser.STATE_EXECUTING_DISCONNECTED = EXECUTING_DISCONNECTED\nBrowser.STATE_DISCONNECTED = DISCONNECTED\n\nmodule.exports = Browser\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/browser_result.js":"var Result = function () {\n  var startTime = Date.now()\n\n  this.total = this.skipped = this.failed = this.success = 0\n  this.netTime = this.totalTime = 0\n  this.disconnected = this.error = false\n\n  this.totalTimeEnd = function () {\n    this.totalTime = Date.now() - startTime\n  }\n\n  this.add = function (result) {\n    if (result.skipped) {\n      this.skipped++\n    } else if (result.success) {\n      this.success++\n    } else {\n      this.failed++\n    }\n\n    this.netTime += result.time\n  }\n}\n\nmodule.exports = Result\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/browser_collection.js":"var EXECUTING = require('./browser').STATE_EXECUTING\nvar Result = require('./browser_result')\n\nvar Collection = function (emitter, browsers) {\n  browsers = browsers || []\n\n  this.add = function (browser) {\n    browsers.push(browser)\n    emitter.emit('browsers_change', this)\n  }\n\n  this.remove = function (browser) {\n    var index = browsers.indexOf(browser)\n\n    if (index === -1) {\n      return false\n    }\n\n    browsers.splice(index, 1)\n    emitter.emit('browsers_change', this)\n\n    return true\n  }\n\n  this.getById = function (browserId) {\n    for (var i = 0; i < browsers.length; i++) {\n      if (browsers[i].id === browserId) {\n        return browsers[i]\n      }\n    }\n\n    return null\n  }\n\n  this.setAllToExecuting = function () {\n    browsers.forEach(function (browser) {\n      browser.state = EXECUTING\n    })\n\n    emitter.emit('browsers_change', this)\n  }\n\n  this.areAllReady = function (nonReadyList) {\n    nonReadyList = nonReadyList || []\n\n    browsers.forEach(function (browser) {\n      if (!browser.isReady()) {\n        nonReadyList.push(browser)\n      }\n    })\n\n    return nonReadyList.length === 0\n  }\n\n  this.serialize = function () {\n    return browsers.map(function (browser) {\n      return browser.serialize()\n    })\n  }\n\n  this.getResults = function () {\n    var results = browsers.reduce(function (previous, current) {\n      previous.success += current.lastResult.success\n      previous.failed += current.lastResult.failed\n      previous.error = previous.error || current.lastResult.error\n      previous.disconnected = previous.disconnected || current.lastResult.disconnected\n      return previous\n    }, {success: 0, failed: 0, error: false, disconnected: false, exitCode: 0})\n\n    // compute exit status code\n    results.exitCode = results.failed || results.error || results.disconnected ? 1 : 0\n\n    return results\n  }\n\n  // TODO(vojta): can we remove this? (we clear the results per browser in onBrowserStart)\n  this.clearResults = function () {\n    browsers.forEach(function (browser) {\n      browser.lastResult = new Result()\n    })\n  }\n\n  this.clone = function () {\n    return new Collection(emitter, browsers.slice())\n  }\n\n  // Array APIs\n  this.map = function (callback, context) {\n    return browsers.map(callback, context)\n  }\n\n  this.forEach = function (callback, context) {\n    return browsers.forEach(callback, context)\n  }\n\n  // this.length\n  Object.defineProperty(this, 'length', {\n    get: function () {\n      return browsers.length\n    }\n  })\n}\nCollection.$inject = ['emitter']\n\nmodule.exports = Collection\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/emitter_wrapper.js":"function EmitterWrapper (emitter) {\n  this.listeners = {}\n  this.emitter = emitter\n}\n\nEmitterWrapper.prototype.addListener = EmitterWrapper.prototype.on = function (event, listener) {\n  this.emitter.addListener(event, listener)\n\n  if (!this.listeners.hasOwnProperty(event)) {\n    this.listeners[event] = []\n  }\n\n  this.listeners[event].push(listener)\n\n  return this\n}\n\nEmitterWrapper.prototype.removeAllListeners = function (event) {\n  var events = event ? [event] : Object.keys(this.listeners)\n  var self = this\n  events.forEach(function (event) {\n    self.listeners[event].forEach(function (listener) {\n      self.emitter.removeListener(event, listener)\n    })\n    delete self.listeners[event]\n  })\n\n  return this\n}\n\nmodule.exports = EmitterWrapper\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/runner.js":"var http = require('http')\n\nvar constant = require('./constants')\nvar helper = require('./helper')\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar log = logger.create('runner')\n\nvar parseExitCode = function (buffer, defaultCode, failOnEmptyTestSuite) {\n  var tailPos = buffer.length - Buffer.byteLength(constant.EXIT_CODE) - 2\n\n  if (tailPos < 0) {\n    return {exitCode: defaultCode, buffer: buffer}\n  }\n\n  // tail buffer which might contain the message\n  var tail = buffer.slice(tailPos)\n  var tailStr = tail.toString()\n  if (tailStr.substr(0, tailStr.length - 2) === constant.EXIT_CODE) {\n    var emptyInt = parseInt(tailStr.substr(-2, 1), 10)\n    var exitCode = parseInt(tailStr.substr(-1), 10)\n    if (failOnEmptyTestSuite === false && emptyInt === 0) {\n      log.warn('Test suite was empty.')\n      exitCode = 0\n    }\n    return {exitCode: exitCode, buffer: buffer.slice(0, tailPos)}\n  }\n\n  return {exitCode: defaultCode, buffer: buffer}\n}\n\n// TODO(vojta): read config file (port, host, urlRoot)\nexports.run = function (config, done) {\n  config = config || {}\n\n  logger.setupFromConfig(config)\n\n  done = helper.isFunction(done) ? done : process.exit\n  config = cfg.parseConfig(config.configFile, config)\n\n  var exitCode = 1\n  var options = {\n    hostname: config.hostname,\n    path: config.urlRoot + 'run',\n    port: config.port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }\n\n  var request = http.request(options, function (response) {\n    response.on('data', function (buffer) {\n      var parsedResult = parseExitCode(buffer, exitCode, config.failOnEmptyTestSuite)\n      exitCode = parsedResult.exitCode\n      process.stdout.write(parsedResult.buffer)\n    })\n\n    response.on('end', function () {\n      done(exitCode)\n    })\n  })\n\n  request.on('error', function (e) {\n    if (e.code === 'ECONNREFUSED') {\n      log.error('There is no server listening on port %d', options.port)\n      done(1, e.code)\n    } else {\n      throw e\n    }\n  })\n\n  request.end(JSON.stringify({\n    args: config.clientArgs,\n    removedFiles: config.removedFiles,\n    changedFiles: config.changedFiles,\n    addedFiles: config.addedFiles,\n    refresh: config.refresh,\n    colors: config.colors\n  }))\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/stopper.js":"var http = require('http')\n\nvar cfg = require('./config')\nvar logger = require('./logger')\nvar helper = require('./helper')\n\nexports.stop = function (config, done) {\n  config = config || {}\n  logger.setupFromConfig(config)\n  done = helper.isFunction(done) ? done : process.exit\n  var log = logger.create('stopper')\n  config = cfg.parseConfig(config.configFile, config)\n\n  var options = {\n    hostname: config.hostname,\n    path: config.urlRoot + 'stop',\n    port: config.port,\n    method: 'GET'\n  }\n\n  var request = http.request(options)\n\n  request.on('response', function (response) {\n    if (response.statusCode !== 200) {\n      log.error('Server returned status code: ' + response.statusCode)\n      done(1)\n      return\n    }\n\n    log.info('Server stopped.')\n    done(0)\n  })\n\n  request.on('error', function (e) {\n    if (e.code === 'ECONNREFUSED') {\n      log.error('There is no server listening on port %d', options.port)\n      done(1, e.code)\n    } else {\n      throw e\n    }\n  })\n  request.end()\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/common/stringify.js":"var serialize = require('dom-serialize')\nvar instanceOf = require('./util').instanceOf\nvar isNode = function (obj) {\n  return (obj.tagName || obj.nodeName) && obj.nodeType\n}\n\nvar stringify = function stringify (obj, depth) {\n  if (depth === 0) {\n    return '...'\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  switch (typeof obj) {\n    case 'string':\n      return \"'\" + obj + \"'\"\n    case 'undefined':\n      return 'undefined'\n    case 'function':\n      try {\n        // function abc(a, b, c) { /* code goes here */ }\n        //   -> function abc(a, b, c) { ... }\n        return obj.toString().replace(/\\{[\\s\\S]*\\}/, '{ ... }')\n      } catch (err) {\n        if (err instanceof TypeError) {\n          // Proxy(function abc(...) { ... })\n          return 'Proxy(function ' + (obj.name || '') + '(...) { ... })'\n        } else {\n          throw err\n        }\n      }\n    case 'boolean':\n      return obj ? 'true' : 'false'\n    case 'object':\n      var strs = []\n      if (instanceOf(obj, 'Array')) {\n        strs.push('[')\n        for (var i = 0, ii = obj.length; i < ii; i++) {\n          if (i) {\n            strs.push(', ')\n          }\n          strs.push(stringify(obj[i], depth - 1))\n        }\n        strs.push(']')\n      } else if (instanceOf(obj, 'Date')) {\n        return obj.toString()\n      } else if (instanceOf(obj, 'Text')) {\n        return obj.nodeValue\n      } else if (instanceOf(obj, 'Comment')) {\n        return '<!--' + obj.nodeValue + '-->'\n      } else if (obj.outerHTML) {\n        return obj.outerHTML\n      } else if (isNode(obj)) {\n        return serialize(obj)\n      } else {\n        var constructor = 'Object'\n        if (obj.constructor && typeof obj.constructor === 'function') {\n          constructor = obj.constructor.name\n        }\n\n        strs.push(constructor)\n        strs.push('{')\n        var first = true\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            if (first) {\n              first = false\n            } else {\n              strs.push(', ')\n            }\n\n            strs.push(key + ': ' + stringify(obj[key], depth - 1))\n          }\n        }\n        strs.push('}')\n      }\n      return strs.join('')\n    default:\n      return obj\n  }\n}\n\nmodule.exports = stringify\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/common/util.js":"exports.instanceOf = function (value, constructorName) {\n  return Object.prototype.toString.apply(value) === '[object ' + constructorName + ']'\n}\n\nexports.elm = function (id) {\n  return document.getElementById(id)\n}\n\nexports.generateId = function (prefix) {\n  return prefix + Math.floor(Math.random() * 10000)\n}\n\nexports.isUndefined = function (value) {\n  return typeof value === 'undefined'\n}\n\nexports.isDefined = function (value) {\n  return !exports.isUndefined(value)\n}\n\nexports.parseQueryParams = function (locationSearch) {\n  var params = {}\n  var pairs = locationSearch.substr(1).split('&')\n  var keyValue\n\n  for (var i = 0; i < pairs.length; i++) {\n    keyValue = pairs[i].split('=')\n    params[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1])\n  }\n\n  return params\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/config.tpl.js":"// Karma configuration\n// Generated on %DATE%\n\nmodule.exports = function(config) {\n  config.set({\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: '%BASE_PATH%',\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [%FRAMEWORKS%],\n\n\n    // list of files / patterns to load in the browser\n    files: [%FILES%\n    ],\n\n\n    // list of files to exclude\n    exclude: [%EXCLUDE%\n    ],\n\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: %PREPROCESSORS%,\n\n\n    // test results reporter to use\n    // possible values: 'dots', 'progress'\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: ['progress'],\n\n\n    // web server port\n    port: 9876,\n\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: %AUTO_WATCH%,\n\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: [%BROWSERS%],\n\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false,\n\n    // Concurrency level\n    // how many browser should be started simultaneous\n    concurrency: Infinity\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/context/karma.js":"// Load our dependencies\nvar stringify = require('../common/stringify')\n\n// Define our context Karma constructor\nvar ContextKarma = function (callParentKarmaMethod) {\n  // Define local variables\n  var hasError = false\n  var self = this\n\n  // Define our loggers\n  // DEV: These are intentionally repeated in client and context\n  this.log = function (type, args) {\n    var values = []\n\n    for (var i = 0; i < args.length; i++) {\n      values.push(this.stringify(args[i], 3))\n    }\n\n    this.info({log: values.join(', '), type: type})\n  }\n\n  this.stringify = stringify\n\n  // Define our proxy error handler\n  // DEV: We require one in our context to track `hasError`\n  this.error = function () {\n    hasError = true\n    callParentKarmaMethod('error', [].slice.call(arguments))\n    return false\n  }\n\n  // Define our start handler\n  var UNIMPLEMENTED_START = function () {\n    this.error('You need to include some adapter that implements __karma__.start method!')\n  }\n  // all files loaded, let's start the execution\n  this.loaded = function () {\n    // has error -> cancel\n    if (!hasError) {\n      this.start(this.config)\n    }\n\n    // remove reference to child iframe\n    this.start = UNIMPLEMENTED_START\n  }\n  // supposed to be overriden by the context\n  // TODO(vojta): support multiple callbacks (queue)\n  this.start = UNIMPLEMENTED_START\n\n  // Define proxy methods\n  // DEV: This is a closured `for` loop (same as a `forEach`) for IE support\n  var proxyMethods = ['complete', 'info', 'result']\n  for (var i = 0; i < proxyMethods.length; i++) {\n    (function bindProxyMethod (methodName) {\n      self[methodName] = function boundProxyMethod () {\n        callParentKarmaMethod(methodName, [].slice.call(arguments))\n      }\n    }(proxyMethods[i]))\n  }\n\n  // Define bindings for context window\n  this.setupContext = function (contextWindow) {\n    // If we clear the context after every run and we already had an error\n    //   then stop now. Otherwise, carry on.\n    if (self.config.clearContext && hasError) {\n      return\n    }\n\n    // Perform window level bindings\n    // DEV: We return `self.error` since we want to `return false` to ignore errors\n    contextWindow.onerror = function () {\n      return self.error.apply(self, arguments)\n    }\n    // DEV: We must defined a function since we don't want to pass the event object\n    contextWindow.onbeforeunload = function (e, b) {\n      callParentKarmaMethod('onbeforeunload', [])\n    }\n\n    contextWindow.dump = function () {\n      self.log('dump', arguments)\n    }\n\n    var _confirm = contextWindow.confirm\n    var _prompt = contextWindow.prompt\n\n    contextWindow.alert = function (msg) {\n      self.log('alert', [msg])\n    }\n\n    contextWindow.confirm = function (msg) {\n      self.log('confirm', [msg])\n      return _confirm(msg)\n    }\n\n    contextWindow.prompt = function (msg, defaultVal) {\n      self.log('prompt', [msg, defaultVal])\n      return _prompt(msg, defaultVal)\n    }\n\n    // If we want to overload our console, then do it\n    var getConsole = function (currentWindow) {\n      return currentWindow.console || {\n        log: function () {},\n        info: function () {},\n        warn: function () {},\n        error: function () {},\n        debug: function () {}\n      }\n    }\n    if (self.config.captureConsole) {\n      // patch the console\n      var localConsole = contextWindow.console = getConsole(contextWindow)\n      var logMethods = ['log', 'info', 'warn', 'error', 'debug']\n      var patchConsoleMethod = function (method) {\n        var orig = localConsole[method]\n        if (!orig) {\n          return\n        }\n        localConsole[method] = function () {\n          self.log(method, arguments)\n          return Function.prototype.apply.call(orig, localConsole, arguments)\n        }\n      }\n      for (var i = 0; i < logMethods.length; i++) {\n        patchConsoleMethod(logMethods[i])\n      }\n    }\n  }\n}\n\n// Define call/proxy methods\nContextKarma.getDirectCallParentKarmaMethod = function (parentWindow) {\n  return function directCallParentKarmaMethod (method, args) {\n    // If the method doesn't exist, then error out\n    if (!parentWindow.karma[method]) {\n      parentWindow.karma.error('Expected Karma method \"' + method + '\" to exist but it doesn\\'t')\n      return\n    }\n\n    // Otherwise, run our method\n    parentWindow.karma[method].apply(parentWindow.karma, args)\n  }\n}\nContextKarma.getPostMessageCallParentKarmaMethod = function (parentWindow) {\n  return function postMessageCallParentKarmaMethod (method, args) {\n    parentWindow.postMessage({__karmaMethod: method, __karmaArguments: args}, window.location.origin)\n  }\n}\n\n// Export our module\nmodule.exports = ContextKarma\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/context/main.js":"// Load in our dependencies\nvar ContextKarma = require('./karma')\n\n// Resolve our parent window\nvar parentWindow = window.opener || window.parent\n\n// Define a remote call method for Karma\nvar callParentKarmaMethod = ContextKarma.getDirectCallParentKarmaMethod(parentWindow)\n\n// If we don't have access to the window, then use `postMessage`\n// DEV: In Electron, we don't have access to the parent window due to it being in a separate process\n// DEV: We avoid using this in Internet Explorer as they only support strings\n//   http://caniuse.com/#search=postmessage\nvar haveParentAccess = false\ntry { haveParentAccess = !!parentWindow.window } catch (err) { /* Ignore errors (likely permisison errors) */ }\nif (!haveParentAccess) {\n  callParentKarmaMethod = ContextKarma.getPostMessageCallParentKarmaMethod(parentWindow)\n}\n\n// Define a window-scoped Karma\nwindow.__karma__ = new ContextKarma(callParentKarmaMethod)\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/gruntfile.js":"module.exports = function (grunt) {\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    pkgFile: 'package.json',\n    files: {\n      server: ['lib/**/*.js'],\n      client: ['client/**/*.js'],\n      common: ['common/**/*.js'],\n      context: ['context/**/*.js'],\n      grunt: ['grunt.js', 'tasks/*.js'],\n      scripts: ['scripts/init-dev-env.js']\n    },\n    browserify: {\n      client: {\n        files: {\n          'static/karma.js': ['client/main.js'],\n          'static/context.js': ['context/main.js']\n        }\n      }\n    },\n    test: {\n      unit: 'mochaTest:unit',\n      client: 'test/client/karma.conf.js',\n      e2e: 'cucumberjs:ci'\n    },\n    watch: {\n      client: {\n        files: '<%= files.client %>',\n        tasks: 'browserify:client'\n      }\n    },\n    mochaTest: {\n      options: {\n        require: 'babel-register',\n        reporter: 'dot',\n        ui: 'bdd',\n        quiet: false,\n        colors: true\n      },\n      unit: {\n        src: [\n          'test/unit/mocha-globals.js',\n          'test/unit/**/*.spec.js'\n        ]\n      }\n    },\n    cucumberjs: {\n      options: {\n        steps: 'test/e2e/steps',\n        format: 'progress',\n        require: 'test/e2e/support/env.js'\n      },\n      all: 'test/e2e/*.feature',\n      current: {\n        files: {\n          src: 'test/e2e/*.feature'\n        },\n        options: {\n          tags: '@current'\n        }\n      },\n      ci: {\n        files: {\n          src: 'test/e2e/*.feature'\n        },\n        options: {\n          tags: '~@not-jenkins'\n        }\n      }\n    },\n    eslint: {\n      options: {\n        quiet: true\n      },\n      target: [\n        '<%= files.server %>',\n        '<%= files.grunt %>',\n        '<%= files.scripts %>',\n        '<%= files.client %>',\n        '<%= files.common %>',\n        '<%= files.context %>',\n        'static/debug.js',\n        'test/**/*.js',\n        'gruntfile.js'\n      ]\n    },\n    'npm-publish': {\n      options: {\n        requires: ['build'],\n        abortIfDirty: true,\n        tag: 'latest'\n      }\n    },\n    'npm-contributors': {\n      options: {\n        commitMessage: 'chore: update contributors'\n      }\n    },\n    conventionalChangelog: {\n      release: {\n        options: {\n          changelogOpts: {\n            preset: 'angular'\n          }\n        },\n        src: 'CHANGELOG.md'\n      }\n    },\n    conventionalGithubReleaser: {\n      release: {\n        options: {\n          auth: {\n            type: 'oauth',\n            token: process.env.GH_TOKEN\n          },\n          changelogOpts: {\n            preset: 'angular'\n          }\n        }\n      }\n    },\n    bump: {\n      options: {\n        updateConfigs: ['pkg'],\n        commitFiles: [\n          'package.json',\n          'CHANGELOG.md'\n        ],\n        commitMessage: 'chore: release v%VERSION%',\n        prereleaseName: 'rc'\n      }\n    }\n  })\n\n  grunt.loadTasks('tasks')\n  require('load-grunt-tasks')(grunt)\n\n  grunt.registerTask('build', ['browserify:client'])\n  grunt.registerTask('default', ['build', 'test', 'lint'])\n  grunt.registerTask('test-appveyor', ['test:unit', 'test:client'])\n\n  grunt.registerTask('release', 'Build, bump and publish to NPM.', function (type) {\n    grunt.task.run([\n      'npm-contributors',\n      'bump:' + (type || 'patch') + ':bump-only',\n      'build',\n      'conventionalChangelog',\n      'bump-commit',\n      'conventionalGithubReleaser',\n      'npm-publish'\n    ])\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/completion.js":"var CUSTOM = ['']\nvar BOOLEAN = false\n\nvar options = {\n  start: {\n    '--port': CUSTOM,\n    '--auto-watch': BOOLEAN,\n    '--no-auto-watch': BOOLEAN,\n    '--log-level': ['disable', 'debug', 'info', 'warn', 'error'],\n    '--colors': BOOLEAN,\n    '--no-colors': BOOLEAN,\n    '--reporters': ['dots', 'progress'],\n    '--no-reporters': BOOLEAN,\n    '--browsers': ['Chrome', 'ChromeCanary', 'Firefox', 'PhantomJS', 'Safari', 'Opera'],\n    '--no-browsers': BOOLEAN,\n    '--single-run': BOOLEAN,\n    '--no-single-run': BOOLEAN,\n    '--help': BOOLEAN\n  },\n  init: {\n    '--log-level': ['disable', 'debug', 'info', 'warn', 'error'],\n    '--colors': BOOLEAN,\n    '--no-colors': BOOLEAN,\n    '--help': BOOLEAN\n  },\n  run: {\n    '--no-refresh': BOOLEAN,\n    '--port': CUSTOM,\n    '--help': BOOLEAN\n  }\n}\n\nvar parseEnv = function (argv, env) {\n  var words = argv.slice(5)\n\n  return {\n    words: words,\n    count: parseInt(env.COMP_CWORD, 10),\n    last: words[words.length - 1],\n    prev: words[words.length - 2]\n  }\n}\n\nvar opositeWord = function (word) {\n  if (word.charAt(0) !== '-') {\n    return null\n  }\n\n  return word.substr(0, 5) === '--no-' ? '--' + word.substr(5) : '--no-' + word.substr(2)\n}\n\nvar sendCompletionNoOptions = function () {}\n\nvar sendCompletion = function (possibleWords, env) {\n  var regexp = new RegExp('^' + env.last)\n  var filteredWords = possibleWords.filter(function (word) {\n    return regexp.test(word) && env.words.indexOf(word) === -1 &&\n      env.words.indexOf(opositeWord(word)) === -1\n  })\n\n  if (!filteredWords.length) {\n    return sendCompletionNoOptions(env)\n  }\n\n  filteredWords.forEach(function (word) {\n    console.log(word)\n  })\n}\n\nvar glob = require('glob')\nvar globOpts = {\n  mark: true,\n  nocase: true\n}\n\nvar sendCompletionFiles = function (env) {\n  glob(env.last + '*', globOpts, function (err, files) {\n    if (err) return console.error(err)\n\n    if (files.length === 1 && files[0].charAt(files[0].length - 1) === '/') {\n      sendCompletionFiles({last: files[0]})\n    } else {\n      console.log(files.join('\\n'))\n    }\n  })\n}\n\nvar sendCompletionConfirmLast = function (env) {\n  console.log(env.last)\n}\n\nvar complete = function (env) {\n  if (env.count === 1) {\n    if (env.words[0].charAt(0) === '-') {\n      return sendCompletion(['--help', '--version'], env)\n    }\n\n    return sendCompletion(Object.keys(options), env)\n  }\n\n  if (env.count === 2 && env.words[1].charAt(0) !== '-') {\n    // complete files (probably karma.conf.js)\n    return sendCompletionFiles(env)\n  }\n\n  var cmdOptions = options[env.words[0]]\n  var previousOption = cmdOptions[env.prev]\n\n  if (!cmdOptions) {\n    // no completion, wrong command\n    return sendCompletionNoOptions()\n  }\n\n  if (previousOption === CUSTOM && env.last) {\n    // custom value with already filled something\n    return sendCompletionConfirmLast(env)\n  }\n\n  if (previousOption) {\n    // custom options\n    return sendCompletion(previousOption, env)\n  }\n\n  return sendCompletion(Object.keys(cmdOptions), env)\n}\n\nvar completion = function () {\n  if (process.argv[3] === '--') {\n    return complete(parseEnv(process.argv, process.env))\n  }\n\n  // just print out the karma-completion.sh\n  var fs = require('graceful-fs')\n  var path = require('path')\n\n  fs.readFile(path.resolve(__dirname, '../scripts/karma-completion.sh'), 'utf8', function (err, data) {\n    if (err) return console.error(err)\n\n    process.stdout.write(data)\n    process.stdout.on('error', function (error) {\n      // Darwin is a real dick sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(karma completion)`\n      // can never ever work on OS X.\n      if (error.errno === 'EPIPE') {\n        error = null\n      }\n    })\n  })\n}\n\n// PUBLIC API\nexports.completion = completion\n\n// for testing\nexports.opositeWord = opositeWord\nexports.sendCompletion = sendCompletion\nexports.complete = complete\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/detached.js":"var fs = require('fs')\n\nvar Server = require('./server')\nvar configurationFile = process.argv[2]\nvar fileContents = fs.readFileSync(configurationFile, 'utf-8')\nfs.unlink(configurationFile, function () {})\nvar data = JSON.parse(fileContents)\nvar server = new Server(data)\nserver.start(data)\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/init.js":"var readline = require('readline')\nvar path = require('path')\nvar glob = require('glob')\nvar mm = require('minimatch')\nvar exec = require('child_process').exec\n\nvar helper = require('./helper')\nvar logger = require('./logger')\n\nvar log = logger.create('init')\n\nvar StateMachine = require('./init/state_machine')\nvar COLOR_SCHEME = require('./init/color_schemes')\nvar formatters = require('./init/formatters')\n\n// TODO(vojta): coverage\n// TODO(vojta): html preprocessors\n// TODO(vojta): SauceLabs\n// TODO(vojta): BrowserStack\n\nvar logQueue = []\nvar printLogQueue = function () {\n  while (logQueue.length) {\n    logQueue.shift()()\n  }\n}\n\nvar NODE_MODULES_DIR = path.resolve(__dirname, '../..')\n\n// Karma is not in node_modules, probably a symlink,\n// use current working dir.\nif (!/node_modules$/.test(NODE_MODULES_DIR)) {\n  NODE_MODULES_DIR = path.resolve('node_modules')\n}\n\nvar installPackage = function (pkgName) {\n  // Do not install if already installed.\n  try {\n    require(NODE_MODULES_DIR + '/' + pkgName)\n    return\n  } catch (e) {}\n\n  log.debug('Missing plugin \"%s\". Installing...', pkgName)\n\n  var options = {\n    cwd: path.resolve(NODE_MODULES_DIR, '..')\n  }\n\n  exec('npm install ' + pkgName + ' --save-dev', options, function (err, stdout, stderr) {\n    // Put the logs into the queue and print them after answering current question.\n    // Otherwise the log would clobber the interactive terminal.\n    logQueue.push(function () {\n      if (!err) {\n        log.debug('%s successfully installed.', pkgName)\n      } else if (/is not in the npm registry/.test(stderr)) {\n        log.warn('Failed to install \"%s\". It is not in the NPM registry!\\n' +\n          '  Please install it manually.', pkgName)\n      } else if (/Error: EACCES/.test(stderr)) {\n        log.warn('Failed to install \"%s\". No permissions to write in %s!\\n' +\n          '  Please install it manually.', pkgName, options.cwd)\n      } else {\n        log.warn('Failed to install \"%s\"\\n  Please install it manually.', pkgName)\n      }\n    })\n  })\n}\n\nvar validatePattern = function (pattern) {\n  if (!glob.sync(pattern).length) {\n    log.warn('There is no file matching this pattern.\\n')\n  }\n}\n\nvar validateBrowser = function (name) {\n  // TODO(vojta): check if the path resolves to a binary\n  installPackage('karma-' + name.toLowerCase().replace('canary', '') + '-launcher')\n}\n\nvar validateFramework = function (name) {\n  installPackage('karma-' + name)\n}\n\nvar validateRequireJs = function (useRequire) {\n  if (useRequire) {\n    validateFramework('requirejs')\n  }\n}\n\nvar questions = [{\n  id: 'framework',\n  question: 'Which testing framework do you want to use ?',\n  hint: 'Press tab to list possible options. Enter to move to the next question.',\n  options: ['jasmine', 'mocha', 'qunit', 'nodeunit', 'nunit', ''],\n  validate: validateFramework\n}, {\n  id: 'requirejs',\n  question: 'Do you want to use Require.js ?',\n  hint: 'This will add Require.js plugin.\\n' +\n    'Press tab to list possible options. Enter to move to the next question.',\n  options: ['no', 'yes'],\n  validate: validateRequireJs,\n  boolean: true\n}, {\n  id: 'browsers',\n  question: 'Do you want to capture any browsers automatically ?',\n  hint: 'Press tab to list possible options. Enter empty string to move to the next question.',\n  options: ['Chrome', 'ChromeCanary', 'Firefox', 'Safari', 'PhantomJS', 'Opera', 'IE', ''],\n  validate: validateBrowser,\n  multiple: true\n}, {\n  id: 'files',\n  question: 'What is the location of your source and test files ?',\n  hint: 'You can use glob patterns, eg. \"js/*.js\" or \"test/**/*Spec.js\".\\n' +\n    'Enter empty string to move to the next question.',\n  multiple: true,\n  validate: validatePattern\n}, {\n  id: 'exclude',\n  question: 'Should any of the files included by the previous patterns be excluded ?',\n  hint: 'You can use glob patterns, eg. \"**/*.swp\".\\n' +\n    'Enter empty string to move to the next question.',\n  multiple: true,\n  validate: validatePattern\n}, {\n  id: 'generateTestMain',\n  question: 'Do you wanna generate a bootstrap file for RequireJS?',\n  hint: 'This will generate test-main.js/coffee that configures RequireJS and starts the tests.',\n  options: ['no', 'yes'],\n  boolean: true,\n  condition: function (answers) {\n    return answers.requirejs\n  }\n}, {\n  id: 'includedFiles',\n  question: 'Which files do you want to include with <script> tag ?',\n  hint: 'This should be a script that bootstraps your test by configuring Require.js and ' +\n    'kicking __karma__.start(), probably your test-main.js file.\\n' +\n    'Enter empty string to move to the next question.',\n  multiple: true,\n  validate: validatePattern,\n  condition: function (answers) {\n    return answers.requirejs && !answers.generateTestMain\n  }\n}, {\n  id: 'autoWatch',\n  question: 'Do you want Karma to watch all the files and run the tests on change ?',\n  hint: 'Press tab to list possible options.',\n  options: ['yes', 'no'],\n  boolean: true\n}]\n\nvar getBasePath = function (configFilePath, cwd) {\n  var configParts = path.dirname(configFilePath).split(path.sep)\n  var cwdParts = cwd.split(path.sep)\n  var base = []\n\n  while (configParts.length && configParts[0] === cwdParts[0]) {\n    configParts.shift()\n    cwdParts.shift()\n  }\n\n  while (configParts.length) {\n    var part = configParts.shift()\n    if (part === '..') {\n      base.unshift(cwdParts.pop())\n    } else if (part !== '.') {\n      base.unshift('..')\n    }\n  }\n\n  return base.join(path.sep)\n}\n\nvar processAnswers = function (answers, basePath, testMainFile) {\n  var processedAnswers = {\n    basePath: basePath,\n    files: answers.files,\n    onlyServedFiles: [],\n    exclude: answers.exclude,\n    autoWatch: answers.autoWatch,\n    generateTestMain: answers.generateTestMain,\n    browsers: answers.browsers,\n    frameworks: [],\n    preprocessors: {}\n  }\n\n  if (answers.framework) {\n    processedAnswers.frameworks.push(answers.framework)\n  }\n\n  if (answers.requirejs) {\n    processedAnswers.frameworks.push('requirejs')\n    processedAnswers.files = answers.includedFiles || []\n    processedAnswers.onlyServedFiles = answers.files\n\n    if (answers.generateTestMain) {\n      processedAnswers.files.push(testMainFile)\n    }\n  }\n\n  var allPatterns = answers.files.concat(answers.includedFiles || [])\n  if (allPatterns.some(function (pattern) {\n    return mm(pattern, '**/*.coffee')\n  })) {\n    installPackage('karma-coffee-preprocessor')\n    processedAnswers.preprocessors['**/*.coffee'] = ['coffee']\n  }\n\n  return processedAnswers\n}\n\nexports.init = function (config) {\n  logger.setupFromConfig(config)\n\n  var colorScheme = COLOR_SCHEME.ON\n\n  if (helper.isDefined(config.colors)) {\n    colorScheme = config.colors ? COLOR_SCHEME.ON : COLOR_SCHEME.OFF\n  }\n  // need to be registered before creating readlineInterface\n  process.stdin.on('keypress', function (s, key) {\n    sm.onKeypress(key)\n  })\n\n  var rli = readline.createInterface(process.stdin, process.stdout)\n  var sm = new StateMachine(rli, colorScheme)\n\n  rli.on('line', sm.onLine.bind(sm))\n\n  // clean colors\n  rli.on('SIGINT', function () {\n    sm.kill()\n    process.exit(0)\n  })\n\n  sm.on('next_question', printLogQueue)\n\n  sm.process(questions, function (answers) {\n    var cwd = process.cwd()\n    var configFile = config.configFile || 'karma.conf.js'\n    var isCoffee = path.extname(configFile) === '.coffee'\n    var testMainFile = isCoffee ? 'test-main.coffee' : 'test-main.js'\n    var formatter = formatters.createForPath(configFile)\n    var processedAnswers = processAnswers(answers, getBasePath(configFile, cwd), testMainFile)\n    var configFilePath = path.resolve(cwd, configFile)\n    var testMainFilePath = path.resolve(cwd, testMainFile)\n\n    if (isCoffee) {\n      installPackage('coffee-script')\n    }\n\n    if (processedAnswers.generateTestMain) {\n      formatter.writeRequirejsConfigFile(testMainFilePath)\n      console.log(colorScheme.success(\n        'RequireJS bootstrap file generated at \"' + testMainFilePath + '\".\\n'\n      ))\n    }\n\n    formatter.writeConfigFile(configFilePath, processedAnswers)\n    console.log(colorScheme.success('Config file generated at \"' + configFilePath + '\".\\n'))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/init/state_machine.js":"var util = require('util')\nvar EventEmitter = require('events').EventEmitter\n\nvar StateMachine = function (rli, colors) {\n  var questions\n  var currentQuestion\n  var answers\n  var currentOptions\n  var currentOptionsPointer\n  var currentQuestionId\n  var done\n\n  EventEmitter.call(this)\n\n  var showPrompt = function () {\n    rli.write(colors.ANSWER)\n    rli.prompt()\n  }\n\n  this.onKeypress = function (key) {\n    if (!currentOptions || !key) {\n      return\n    }\n\n    if (key.name === 'tab' || key.name === 'right' || key.name === 'down') {\n      this.suggestNextOption()\n    } else if (key.name === 'left' || key.name === 'up') {\n      currentOptionsPointer = currentOptionsPointer + currentOptions.length - 2\n      this.suggestNextOption()\n    }\n\n    if (!key.ctrl && !key.meta && key.name !== 'enter' && key.name !== 'return') {\n      key.name = 'escape'\n    }\n  }\n\n  this.suggestNextOption = function () {\n    if (!currentOptions) {\n      return\n    }\n\n    currentOptionsPointer = (currentOptionsPointer + 1) % currentOptions.length\n    rli._deleteLineLeft()\n    rli._deleteLineRight()\n    rli.write(currentOptions[currentOptionsPointer])\n  }\n\n  this.kill = function () {\n    currentOptions = null\n    currentQuestionId = null\n    rli.write('\\n' + colors.RESET + '\\n')\n    rli.close()\n  }\n\n  this.onLine = function (line) {\n    if (currentQuestionId) {\n      rli.write(colors.RESET)\n      line = line.trim().replace(colors.ANSWER, '').replace(colors.RESET, '')\n\n      if (currentOptions) {\n        currentOptionsPointer = currentOptions.indexOf(line)\n        if (currentOptionsPointer === -1) {\n          return\n        }\n      }\n\n      if (line === '') {\n        line = null\n      }\n\n      if (currentQuestion.boolean) {\n        line = (line === 'yes' || line === 'true' || line === 'on')\n      }\n\n      if (line !== null && currentQuestion.validate) {\n        currentQuestion.validate(line)\n      }\n\n      if (currentQuestion.multiple) {\n        answers[currentQuestionId] = answers[currentQuestionId] || []\n        if (line !== null) {\n          answers[currentQuestionId].push(line)\n          showPrompt()\n\n          if (currentOptions) {\n            currentOptions.splice(currentOptionsPointer, 1)\n            currentOptionsPointer = -1\n          }\n        } else {\n          this.nextQuestion()\n        }\n      } else {\n        answers[currentQuestionId] = line\n        this.nextQuestion()\n      }\n    }\n  }\n\n  this.nextQuestion = function () {\n    currentQuestion = questions.shift()\n\n    while (currentQuestion && currentQuestion.condition && !currentQuestion.condition(answers)) {\n      currentQuestion = questions.shift()\n    }\n\n    this.emit('next_question', currentQuestion)\n\n    if (currentQuestion) {\n      currentQuestionId = null\n\n      rli.write('\\n' + colors.question(currentQuestion.question) + '\\n')\n      rli.write(currentQuestion.hint + '\\n')\n      showPrompt()\n\n      currentOptions = currentQuestion.options || null\n      currentOptionsPointer = -1\n      currentQuestionId = currentQuestion.id\n\n      this.suggestNextOption()\n    } else {\n      currentQuestionId = null\n      currentOptions = null\n\n      // end\n      this.kill()\n      done(answers)\n    }\n  }\n\n  this.process = function (_questions, _done) {\n    questions = _questions\n    answers = {}\n    done = _done\n\n    this.nextQuestion()\n  }\n}\n\nutil.inherits(StateMachine, EventEmitter)\n\nmodule.exports = StateMachine\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/init/color_schemes.js":"var COLORS_ON = {\n  RESET: '\\x1B[39m',\n  ANSWER: '\\x1B[36m', // NYAN\n  SUCCESS: '\\x1B[32m', // GREEN\n  QUESTION: '\\x1B[1m', // BOLD\n  question: function (str) {\n    return this.QUESTION + str + '\\x1B[22m'\n  },\n  success: function (str) {\n    return this.SUCCESS + str + this.RESET\n  }\n}\n\nvar COLORS_OFF = {\n  RESET: '',\n  ANSWER: '',\n  SUCCESS: '',\n  QUESTION: '',\n  question: function (str) {\n    return str\n  },\n  success: function (str) {\n    return str\n  }\n}\n\nexports.ON = COLORS_ON\nexports.OFF = COLORS_OFF\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/init/formatters.js":"var fs = require('graceful-fs')\nvar util = require('util')\nvar path = require('path')\n\nvar JS_TEMPLATE_PATH = path.join(__dirname, '/../../config.tpl.js')\nvar COFFEE_TEMPLATE_PATH = path.join(__dirname, '/../../config.tpl.coffee')\nvar JS_REQUIREJS_TEMPLATE_PATH = path.join(__dirname, '/../../requirejs.config.tpl.js')\nvar COFFEE_REQUIREJS_TEMPLATE_PATH = path.join(__dirname, '/../../requirejs.config.tpl.coffee')\nvar COFFEE_REGEXP = /\\.coffee$/\nvar LIVE_TEMPLATE_PATH = path.join(__dirname, '/../../config.tpl.ls')\nvar LIVE_REGEXP = /\\.ls$/\nvar TYPE_TEMPLATE_PATH = path.join(__dirname, '/../../config.tpl.ts')\nvar TYPE_REGEXP = /\\.ts$/\n\nvar isCoffeeFile = function (filename) {\n  return COFFEE_REGEXP.test(filename)\n}\n\nvar isLiveFile = function (filename) {\n  return LIVE_REGEXP.test(filename)\n}\n\nvar isTypeFile = function (filename) {\n  return TYPE_REGEXP.test(filename)\n}\n\nvar JavaScriptFormatter = function () {\n  var quote = function (value) {\n    return \"'\" + value + \"'\"\n  }\n\n  var quoteNonIncludedPattern = function (value) {\n    return util.format('{pattern: %s, included: false}', quote(value))\n  }\n\n  var pad = function (str, pad) {\n    return str.replace(/\\n/g, '\\n' + pad).replace(/\\s+$/gm, '')\n  }\n\n  var formatQuottedList = function (list) {\n    return list.map(quote).join(', ')\n  }\n\n  this.TEMPLATE_FILE_PATH = JS_TEMPLATE_PATH\n  this.REQUIREJS_TEMPLATE_FILE = JS_REQUIREJS_TEMPLATE_PATH\n\n  this.formatFiles = function (includedFiles, onlyServedFiles) {\n    var files = includedFiles.map(quote)\n\n    onlyServedFiles.forEach(function (onlyServedFile) {\n      files.push(quoteNonIncludedPattern(onlyServedFile))\n    })\n\n    files = files.map(function (file) {\n      return '\\n      ' + file\n    })\n\n    return files.join(',')\n  }\n\n  this.formatPreprocessors = function (preprocessors) {\n    var lines = []\n    Object.keys(preprocessors).forEach(function (pattern) {\n      lines.push('  ' + quote(pattern) + ': [' + formatQuottedList(preprocessors[pattern]) + ']')\n    })\n\n    return pad('{\\n' + lines.join(',\\n') + '\\n}', '    ')\n  }\n\n  this.formatFrameworks = formatQuottedList\n\n  this.formatBrowsers = formatQuottedList\n\n  this.formatAnswers = function (answers) {\n    return {\n      DATE: new Date(),\n      BASE_PATH: answers.basePath,\n      FRAMEWORKS: this.formatFrameworks(answers.frameworks),\n      FILES: this.formatFiles(answers.files, answers.onlyServedFiles),\n      EXCLUDE: this.formatFiles(answers.exclude, []),\n      AUTO_WATCH: answers.autoWatch ? 'true' : 'false',\n      BROWSERS: this.formatBrowsers(answers.browsers),\n      PREPROCESSORS: this.formatPreprocessors(answers.preprocessors)\n    }\n  }\n\n  this.generateConfigFile = function (answers) {\n    var template = fs.readFileSync(this.TEMPLATE_FILE_PATH).toString()\n    var replacements = this.formatAnswers(answers)\n\n    return template.replace(/%(.*)%/g, function (a, key) {\n      return replacements[key]\n    })\n  }\n\n  this.writeConfigFile = function (path, answers) {\n    fs.writeFileSync(path, this.generateConfigFile(answers))\n  }\n\n  this.generateRequirejsConfigFile = function () {\n    var template = fs.readFileSync(this.REQUIREJS_TEMPLATE_FILE).toString()\n    return template\n  }\n\n  this.writeRequirejsConfigFile = function (path) {\n    fs.writeFileSync(path, this.generateRequirejsConfigFile())\n  }\n}\n\nvar CoffeeFormatter = function () {\n  JavaScriptFormatter.call(this)\n\n  this.TEMPLATE_FILE_PATH = COFFEE_TEMPLATE_PATH\n  this.REQUIREJS_TEMPLATE_FILE = COFFEE_REQUIREJS_TEMPLATE_PATH\n}\n\nvar LiveFormatter = function () {\n  JavaScriptFormatter.call(this)\n\n  this.TEMPLATE_FILE_PATH = LIVE_TEMPLATE_PATH\n}\n\nvar TypeFormatter = function () {\n  JavaScriptFormatter.call(this)\n\n  this.TEMPLATE_FILE_PATH = TYPE_TEMPLATE_PATH\n}\n\nexports.JavaScript = JavaScriptFormatter\nexports.Coffee = CoffeeFormatter\nexports.Live = LiveFormatter\nexports.Type = TypeFormatter\n\nexports.createForPath = function (path) {\n  if (isCoffeeFile(path)) {\n    return new CoffeeFormatter()\n  }\n\n  if (isLiveFile(path)) {\n    return new LiveFormatter()\n  }\n\n  if (isTypeFile(path)) {\n    return new TypeFormatter()\n  }\n\n  return new JavaScriptFormatter()\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/lib/temp_dir.js":"var path = require('path')\nvar fs = require('graceful-fs')\nvar os = require('os')\nvar rimraf = require('rimraf')\nvar log = require('./logger').create('temp-dir')\n\nvar TEMP_DIR = os.tmpdir()\n\nmodule.exports = {\n  getPath: function (suffix) {\n    return path.normalize(TEMP_DIR + suffix)\n  },\n\n  create: function (path) {\n    log.debug('Creating temp dir at %s', path)\n\n    try {\n      fs.mkdirSync(path)\n    } catch (e) {\n      log.warn('Failed to create a temp dir at %s', path)\n    }\n\n    return path\n  },\n\n  remove: function (path, done) {\n    log.debug('Cleaning temp dir %s', path)\n    rimraf(path, done)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/requirejs.config.tpl.js":"var allTestFiles = []\nvar TEST_REGEXP = /(spec|test)\\.js$/i\n\n// Get a list of all the test files to include\nObject.keys(window.__karma__.files).forEach(function (file) {\n  if (TEST_REGEXP.test(file)) {\n    // Normalize paths to RequireJS module names.\n    // If you require sub-dependencies of test files to be loaded as-is (requiring file extension)\n    // then do not normalize the paths\n    var normalizedTestModule = file.replace(/^\\/base\\/|\\.js$/g, '')\n    allTestFiles.push(normalizedTestModule)\n  }\n})\n\nrequire.config({\n  // Karma serves files under /base, which is the basePath from your config file\n  baseUrl: '/base',\n\n  // dynamically load all test files\n  deps: allTestFiles,\n\n  // we have to kickoff jasmine, as it is asynchronous\n  callback: window.__karma__.start\n})\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/static/context.js":"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar serialize = require('dom-serialize')\nvar instanceOf = require('./util').instanceOf\nvar isNode = function (obj) {\n  return (obj.tagName || obj.nodeName) && obj.nodeType\n}\n\nvar stringify = function stringify (obj, depth) {\n  if (depth === 0) {\n    return '...'\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  switch (typeof obj) {\n    case 'string':\n      return \"'\" + obj + \"'\"\n    case 'undefined':\n      return 'undefined'\n    case 'function':\n      try {\n        // function abc(a, b, c) { /* code goes here */ }\n        //   -> function abc(a, b, c) { ... }\n        return obj.toString().replace(/\\{[\\s\\S]*\\}/, '{ ... }')\n      } catch (err) {\n        if (err instanceof TypeError) {\n          // Proxy(function abc(...) { ... })\n          return 'Proxy(function ' + (obj.name || '') + '(...) { ... })'\n        } else {\n          throw err\n        }\n      }\n    case 'boolean':\n      return obj ? 'true' : 'false'\n    case 'object':\n      var strs = []\n      if (instanceOf(obj, 'Array')) {\n        strs.push('[')\n        for (var i = 0, ii = obj.length; i < ii; i++) {\n          if (i) {\n            strs.push(', ')\n          }\n          strs.push(stringify(obj[i], depth - 1))\n        }\n        strs.push(']')\n      } else if (instanceOf(obj, 'Date')) {\n        return obj.toString()\n      } else if (instanceOf(obj, 'Text')) {\n        return obj.nodeValue\n      } else if (instanceOf(obj, 'Comment')) {\n        return '<!--' + obj.nodeValue + '-->'\n      } else if (obj.outerHTML) {\n        return obj.outerHTML\n      } else if (isNode(obj)) {\n        return serialize(obj)\n      } else {\n        var constructor = 'Object'\n        if (obj.constructor && typeof obj.constructor === 'function') {\n          constructor = obj.constructor.name\n        }\n\n        strs.push(constructor)\n        strs.push('{')\n        var first = true\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            if (first) {\n              first = false\n            } else {\n              strs.push(', ')\n            }\n\n            strs.push(key + ': ' + stringify(obj[key], depth - 1))\n          }\n        }\n        strs.push('}')\n      }\n      return strs.join('')\n    default:\n      return obj\n  }\n}\n\nmodule.exports = stringify\n\n},{\"./util\":2,\"dom-serialize\":6}],2:[function(require,module,exports){\nexports.instanceOf = function (value, constructorName) {\n  return Object.prototype.toString.apply(value) === '[object ' + constructorName + ']'\n}\n\nexports.elm = function (id) {\n  return document.getElementById(id)\n}\n\nexports.generateId = function (prefix) {\n  return prefix + Math.floor(Math.random() * 10000)\n}\n\nexports.isUndefined = function (value) {\n  return typeof value === 'undefined'\n}\n\nexports.isDefined = function (value) {\n  return !exports.isUndefined(value)\n}\n\nexports.parseQueryParams = function (locationSearch) {\n  var params = {}\n  var pairs = locationSearch.substr(1).split('&')\n  var keyValue\n\n  for (var i = 0; i < pairs.length; i++) {\n    keyValue = pairs[i].split('=')\n    params[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1])\n  }\n\n  return params\n}\n\n},{}],3:[function(require,module,exports){\n// Load our dependencies\nvar stringify = require('../common/stringify')\n\n// Define our context Karma constructor\nvar ContextKarma = function (callParentKarmaMethod) {\n  // Define local variables\n  var hasError = false\n  var self = this\n\n  // Define our loggers\n  // DEV: These are intentionally repeated in client and context\n  this.log = function (type, args) {\n    var values = []\n\n    for (var i = 0; i < args.length; i++) {\n      values.push(this.stringify(args[i], 3))\n    }\n\n    this.info({log: values.join(', '), type: type})\n  }\n\n  this.stringify = stringify\n\n  // Define our proxy error handler\n  // DEV: We require one in our context to track `hasError`\n  this.error = function () {\n    hasError = true\n    callParentKarmaMethod('error', [].slice.call(arguments))\n    return false\n  }\n\n  // Define our start handler\n  var UNIMPLEMENTED_START = function () {\n    this.error('You need to include some adapter that implements __karma__.start method!')\n  }\n  // all files loaded, let's start the execution\n  this.loaded = function () {\n    // has error -> cancel\n    if (!hasError) {\n      this.start(this.config)\n    }\n\n    // remove reference to child iframe\n    this.start = UNIMPLEMENTED_START\n  }\n  // supposed to be overriden by the context\n  // TODO(vojta): support multiple callbacks (queue)\n  this.start = UNIMPLEMENTED_START\n\n  // Define proxy methods\n  // DEV: This is a closured `for` loop (same as a `forEach`) for IE support\n  var proxyMethods = ['complete', 'info', 'result']\n  for (var i = 0; i < proxyMethods.length; i++) {\n    (function bindProxyMethod (methodName) {\n      self[methodName] = function boundProxyMethod () {\n        callParentKarmaMethod(methodName, [].slice.call(arguments))\n      }\n    }(proxyMethods[i]))\n  }\n\n  // Define bindings for context window\n  this.setupContext = function (contextWindow) {\n    // If we clear the context after every run and we already had an error\n    //   then stop now. Otherwise, carry on.\n    if (self.config.clearContext && hasError) {\n      return\n    }\n\n    // Perform window level bindings\n    // DEV: We return `self.error` since we want to `return false` to ignore errors\n    contextWindow.onerror = function () {\n      return self.error.apply(self, arguments)\n    }\n    // DEV: We must defined a function since we don't want to pass the event object\n    contextWindow.onbeforeunload = function (e, b) {\n      callParentKarmaMethod('onbeforeunload', [])\n    }\n\n    contextWindow.dump = function () {\n      self.log('dump', arguments)\n    }\n\n    var _confirm = contextWindow.confirm\n    var _prompt = contextWindow.prompt\n\n    contextWindow.alert = function (msg) {\n      self.log('alert', [msg])\n    }\n\n    contextWindow.confirm = function (msg) {\n      self.log('confirm', [msg])\n      return _confirm(msg)\n    }\n\n    contextWindow.prompt = function (msg, defaultVal) {\n      self.log('prompt', [msg, defaultVal])\n      return _prompt(msg, defaultVal)\n    }\n\n    // If we want to overload our console, then do it\n    var getConsole = function (currentWindow) {\n      return currentWindow.console || {\n        log: function () {},\n        info: function () {},\n        warn: function () {},\n        error: function () {},\n        debug: function () {}\n      }\n    }\n    if (self.config.captureConsole) {\n      // patch the console\n      var localConsole = contextWindow.console = getConsole(contextWindow)\n      var logMethods = ['log', 'info', 'warn', 'error', 'debug']\n      var patchConsoleMethod = function (method) {\n        var orig = localConsole[method]\n        if (!orig) {\n          return\n        }\n        localConsole[method] = function () {\n          self.log(method, arguments)\n          return Function.prototype.apply.call(orig, localConsole, arguments)\n        }\n      }\n      for (var i = 0; i < logMethods.length; i++) {\n        patchConsoleMethod(logMethods[i])\n      }\n    }\n  }\n}\n\n// Define call/proxy methods\nContextKarma.getDirectCallParentKarmaMethod = function (parentWindow) {\n  return function directCallParentKarmaMethod (method, args) {\n    // If the method doesn't exist, then error out\n    if (!parentWindow.karma[method]) {\n      parentWindow.karma.error('Expected Karma method \"' + method + '\" to exist but it doesn\\'t')\n      return\n    }\n\n    // Otherwise, run our method\n    parentWindow.karma[method].apply(parentWindow.karma, args)\n  }\n}\nContextKarma.getPostMessageCallParentKarmaMethod = function (parentWindow) {\n  return function postMessageCallParentKarmaMethod (method, args) {\n    parentWindow.postMessage({__karmaMethod: method, __karmaArguments: args}, window.location.origin)\n  }\n}\n\n// Export our module\nmodule.exports = ContextKarma\n\n},{\"../common/stringify\":1}],4:[function(require,module,exports){\n// Load in our dependencies\nvar ContextKarma = require('./karma')\n\n// Resolve our parent window\nvar parentWindow = window.opener || window.parent\n\n// Define a remote call method for Karma\nvar callParentKarmaMethod = ContextKarma.getDirectCallParentKarmaMethod(parentWindow)\n\n// If we don't have access to the window, then use `postMessage`\n// DEV: In Electron, we don't have access to the parent window due to it being in a separate process\n// DEV: We avoid using this in Internet Explorer as they only support strings\n//   http://caniuse.com/#search=postmessage\nvar haveParentAccess = false\ntry { haveParentAccess = !!parentWindow.window } catch (err) { /* Ignore errors (likely permisison errors) */ }\nif (!haveParentAccess) {\n  callParentKarmaMethod = ContextKarma.getPostMessageCallParentKarmaMethod(parentWindow)\n}\n\n// Define a window-scoped Karma\nwindow.__karma__ = new ContextKarma(callParentKarmaMethod)\n\n},{\"./karma\":3}],5:[function(require,module,exports){\n(function (global){\n\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(require,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar extend = require('extend');\nvar encode = require('ent/encode');\nvar CustomEvent = require('custom-event');\nvar voidElements = require('void-elements');\n\n/**\n * Module exports.\n */\n\nexports = module.exports = serialize;\nexports.serializeElement = serializeElement;\nexports.serializeAttribute = serializeAttribute;\nexports.serializeText = serializeText;\nexports.serializeComment = serializeComment;\nexports.serializeDocument = serializeDocument;\nexports.serializeDoctype = serializeDoctype;\nexports.serializeDocumentFragment = serializeDocumentFragment;\nexports.serializeNodeList = serializeNodeList;\n\n/**\n * Serializes any DOM node. Returns a string.\n *\n * @param {Node} node - DOM Node to serialize\n * @param {String} [context] - optional arbitrary \"context\" string to use (useful for event listeners)\n * @param {Function} [fn] - optional callback function to use in the \"serialize\" event for this call\n * @param {EventTarget} [eventTarget] - optional EventTarget instance to emit the \"serialize\" event on (defaults to `node`)\n * return {String}\n * @public\n */\n\nfunction serialize (node, context, fn, eventTarget) {\n  if (!node) return '';\n  if ('function' === typeof context) {\n    fn = context;\n    context = null;\n  }\n  if (!context) context = null;\n\n  var rtn;\n  var nodeType = node.nodeType;\n\n  if (!nodeType && 'number' === typeof node.length) {\n    // assume it's a NodeList or Array of Nodes\n    rtn = exports.serializeNodeList(node, context, fn);\n  } else {\n\n    if ('function' === typeof fn) {\n      // one-time \"serialize\" event listener\n      node.addEventListener('serialize', fn, false);\n    }\n\n    // emit a custom \"serialize\" event on `node`, in case there\n    // are event listeners for custom serialization of this node\n    var e = new CustomEvent('serialize', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        serialize: null,\n        context: context\n      }\n    });\n\n    e.serializeTarget = node;\n\n    var target = eventTarget || node;\n    var cancelled = !target.dispatchEvent(e);\n\n    // `e.detail.serialize` can be set to a:\n    //   String - returned directly\n    //   Node   - goes through serializer logic instead of `node`\n    //   Anything else - get Stringified first, and then returned directly\n    var s = e.detail.serialize;\n    if (s != null) {\n      if ('string' === typeof s) {\n        rtn = s;\n      } else if ('number' === typeof s.nodeType) {\n        // make it go through the serialization logic\n        rtn = serialize(s, context, null, target);\n      } else {\n        rtn = String(s);\n      }\n    } else if (!cancelled) {\n      // default serialization logic\n      switch (nodeType) {\n        case 1 /* element */:\n          rtn = exports.serializeElement(node, context, eventTarget);\n          break;\n        case 2 /* attribute */:\n          rtn = exports.serializeAttribute(node);\n          break;\n        case 3 /* text */:\n          rtn = exports.serializeText(node);\n          break;\n        case 8 /* comment */:\n          rtn = exports.serializeComment(node);\n          break;\n        case 9 /* document */:\n          rtn = exports.serializeDocument(node, context, eventTarget);\n          break;\n        case 10 /* doctype */:\n          rtn = exports.serializeDoctype(node);\n          break;\n        case 11 /* document fragment */:\n          rtn = exports.serializeDocumentFragment(node, context, eventTarget);\n          break;\n      }\n    }\n\n    if ('function' === typeof fn) {\n      node.removeEventListener('serialize', fn, false);\n    }\n  }\n\n  return rtn || '';\n}\n\n/**\n * Serialize an Attribute node.\n */\n\nfunction serializeAttribute (node, opts) {\n  return node.name + '=\"' + encode(node.value, extend({\n    named: true\n  }, opts)) + '\"';\n}\n\n/**\n * Serialize a DOM element.\n */\n\nfunction serializeElement (node, context, eventTarget) {\n  var c, i, l;\n  var name = node.nodeName.toLowerCase();\n\n  // opening tag\n  var r = '<' + name;\n\n  // attributes\n  for (i = 0, c = node.attributes, l = c.length; i < l; i++) {\n    r += ' ' + exports.serializeAttribute(c[i]);\n  }\n\n  r += '>';\n\n  // child nodes\n  r += exports.serializeNodeList(node.childNodes, context, null, eventTarget);\n\n  // closing tag, only for non-void elements\n  if (!voidElements[name]) {\n    r += '</' + name + '>';\n  }\n\n  return r;\n}\n\n/**\n * Serialize a text node.\n */\n\nfunction serializeText (node, opts) {\n  return encode(node.nodeValue, extend({\n    named: true,\n    special: { '<': true, '>': true, '&': true }\n  }, opts));\n}\n\n/**\n * Serialize a comment node.\n */\n\nfunction serializeComment (node) {\n  return '<!--' + node.nodeValue + '-->';\n}\n\n/**\n * Serialize a Document node.\n */\n\nfunction serializeDocument (node, context, eventTarget) {\n  return exports.serializeNodeList(node.childNodes, context, null, eventTarget);\n}\n\n/**\n * Serialize a DOCTYPE node.\n * See: http://stackoverflow.com/a/10162353\n */\n\nfunction serializeDoctype (node) {\n  var r = '<!DOCTYPE ' + node.name;\n\n  if (node.publicId) {\n    r += ' PUBLIC \"' + node.publicId + '\"';\n  }\n\n  if (!node.publicId && node.systemId) {\n    r += ' SYSTEM';\n  }\n\n  if (node.systemId) {\n    r += ' \"' + node.systemId + '\"';\n  }\n\n  r += '>';\n  return r;\n}\n\n/**\n * Serialize a DocumentFragment instance.\n */\n\nfunction serializeDocumentFragment (node, context, eventTarget) {\n  return exports.serializeNodeList(node.childNodes, context, null, eventTarget);\n}\n\n/**\n * Serialize a NodeList/Array of nodes.\n */\n\nfunction serializeNodeList (list, context, fn, eventTarget) {\n  var r = '';\n  for (var i = 0, l = list.length; i < l; i++) {\n    r += serialize(list[i], context, fn, eventTarget);\n  }\n  return r;\n}\n\n},{\"custom-event\":5,\"ent/encode\":7,\"extend\":9,\"void-elements\":11}],7:[function(require,module,exports){\nvar punycode = require('punycode');\nvar revEntities = require('./reversed.json');\n\nmodule.exports = encode;\n\nfunction encode (str, opts) {\n    if (typeof str !== 'string') {\n        throw new TypeError('Expected a String');\n    }\n    if (!opts) opts = {};\n\n    var numeric = true;\n    if (opts.named) numeric = false;\n    if (opts.numeric !== undefined) numeric = opts.numeric;\n\n    var special = opts.special || {\n        '\"': true, \"'\": true,\n        '<': true, '>': true,\n        '&': true\n    };\n\n    var codePoints = punycode.ucs2.decode(str);\n    var chars = [];\n    for (var i = 0; i < codePoints.length; i++) {\n        var cc = codePoints[i];\n        var c = punycode.ucs2.encode([ cc ]);\n        var e = revEntities[cc];\n        if (e && (cc >= 127 || special[c]) && !numeric) {\n            chars.push('&' + (/;$/.test(e) ? e : e + ';'));\n        }\n        else if (cc < 32 || cc >= 127 || special[c]) {\n            chars.push('&#' + cc + ';');\n        }\n        else {\n            chars.push(c);\n        }\n    }\n    return chars.join('');\n}\n\n},{\"./reversed.json\":8,\"punycode\":10}],8:[function(require,module,exports){\nmodule.exports={\n    \"9\": \"Tab;\",\n    \"10\": \"NewLine;\",\n    \"33\": \"excl;\",\n    \"34\": \"quot;\",\n    \"35\": \"num;\",\n    \"36\": \"dollar;\",\n    \"37\": \"percnt;\",\n    \"38\": \"amp;\",\n    \"39\": \"apos;\",\n    \"40\": \"lpar;\",\n    \"41\": \"rpar;\",\n    \"42\": \"midast;\",\n    \"43\": \"plus;\",\n    \"44\": \"comma;\",\n    \"46\": \"period;\",\n    \"47\": \"sol;\",\n    \"58\": \"colon;\",\n    \"59\": \"semi;\",\n    \"60\": \"lt;\",\n    \"61\": \"equals;\",\n    \"62\": \"gt;\",\n    \"63\": \"quest;\",\n    \"64\": \"commat;\",\n    \"91\": \"lsqb;\",\n    \"92\": \"bsol;\",\n    \"93\": \"rsqb;\",\n    \"94\": \"Hat;\",\n    \"95\": \"UnderBar;\",\n    \"96\": \"grave;\",\n    \"123\": \"lcub;\",\n    \"124\": \"VerticalLine;\",\n    \"125\": \"rcub;\",\n    \"160\": \"NonBreakingSpace;\",\n    \"161\": \"iexcl;\",\n    \"162\": \"cent;\",\n    \"163\": \"pound;\",\n    \"164\": \"curren;\",\n    \"165\": \"yen;\",\n    \"166\": \"brvbar;\",\n    \"167\": \"sect;\",\n    \"168\": \"uml;\",\n    \"169\": \"copy;\",\n    \"170\": \"ordf;\",\n    \"171\": \"laquo;\",\n    \"172\": \"not;\",\n    \"173\": \"shy;\",\n    \"174\": \"reg;\",\n    \"175\": \"strns;\",\n    \"176\": \"deg;\",\n    \"177\": \"pm;\",\n    \"178\": \"sup2;\",\n    \"179\": \"sup3;\",\n    \"180\": \"DiacriticalAcute;\",\n    \"181\": \"micro;\",\n    \"182\": \"para;\",\n    \"183\": \"middot;\",\n    \"184\": \"Cedilla;\",\n    \"185\": \"sup1;\",\n    \"186\": \"ordm;\",\n    \"187\": \"raquo;\",\n    \"188\": \"frac14;\",\n    \"189\": \"half;\",\n    \"190\": \"frac34;\",\n    \"191\": \"iquest;\",\n    \"192\": \"Agrave;\",\n    \"193\": \"Aacute;\",\n    \"194\": \"Acirc;\",\n    \"195\": \"Atilde;\",\n    \"196\": \"Auml;\",\n    \"197\": \"Aring;\",\n    \"198\": \"AElig;\",\n    \"199\": \"Ccedil;\",\n    \"200\": \"Egrave;\",\n    \"201\": \"Eacute;\",\n    \"202\": \"Ecirc;\",\n    \"203\": \"Euml;\",\n    \"204\": \"Igrave;\",\n    \"205\": \"Iacute;\",\n    \"206\": \"Icirc;\",\n    \"207\": \"Iuml;\",\n    \"208\": \"ETH;\",\n    \"209\": \"Ntilde;\",\n    \"210\": \"Ograve;\",\n    \"211\": \"Oacute;\",\n    \"212\": \"Ocirc;\",\n    \"213\": \"Otilde;\",\n    \"214\": \"Ouml;\",\n    \"215\": \"times;\",\n    \"216\": \"Oslash;\",\n    \"217\": \"Ugrave;\",\n    \"218\": \"Uacute;\",\n    \"219\": \"Ucirc;\",\n    \"220\": \"Uuml;\",\n    \"221\": \"Yacute;\",\n    \"222\": \"THORN;\",\n    \"223\": \"szlig;\",\n    \"224\": \"agrave;\",\n    \"225\": \"aacute;\",\n    \"226\": \"acirc;\",\n    \"227\": \"atilde;\",\n    \"228\": \"auml;\",\n    \"229\": \"aring;\",\n    \"230\": \"aelig;\",\n    \"231\": \"ccedil;\",\n    \"232\": \"egrave;\",\n    \"233\": \"eacute;\",\n    \"234\": \"ecirc;\",\n    \"235\": \"euml;\",\n    \"236\": \"igrave;\",\n    \"237\": \"iacute;\",\n    \"238\": \"icirc;\",\n    \"239\": \"iuml;\",\n    \"240\": \"eth;\",\n    \"241\": \"ntilde;\",\n    \"242\": \"ograve;\",\n    \"243\": \"oacute;\",\n    \"244\": \"ocirc;\",\n    \"245\": \"otilde;\",\n    \"246\": \"ouml;\",\n    \"247\": \"divide;\",\n    \"248\": \"oslash;\",\n    \"249\": \"ugrave;\",\n    \"250\": \"uacute;\",\n    \"251\": \"ucirc;\",\n    \"252\": \"uuml;\",\n    \"253\": \"yacute;\",\n    \"254\": \"thorn;\",\n    \"255\": \"yuml;\",\n    \"256\": \"Amacr;\",\n    \"257\": \"amacr;\",\n    \"258\": \"Abreve;\",\n    \"259\": \"abreve;\",\n    \"260\": \"Aogon;\",\n    \"261\": \"aogon;\",\n    \"262\": \"Cacute;\",\n    \"263\": \"cacute;\",\n    \"264\": \"Ccirc;\",\n    \"265\": \"ccirc;\",\n    \"266\": \"Cdot;\",\n    \"267\": \"cdot;\",\n    \"268\": \"Ccaron;\",\n    \"269\": \"ccaron;\",\n    \"270\": \"Dcaron;\",\n    \"271\": \"dcaron;\",\n    \"272\": \"Dstrok;\",\n    \"273\": \"dstrok;\",\n    \"274\": \"Emacr;\",\n    \"275\": \"emacr;\",\n    \"278\": \"Edot;\",\n    \"279\": \"edot;\",\n    \"280\": \"Eogon;\",\n    \"281\": \"eogon;\",\n    \"282\": \"Ecaron;\",\n    \"283\": \"ecaron;\",\n    \"284\": \"Gcirc;\",\n    \"285\": \"gcirc;\",\n    \"286\": \"Gbreve;\",\n    \"287\": \"gbreve;\",\n    \"288\": \"Gdot;\",\n    \"289\": \"gdot;\",\n    \"290\": \"Gcedil;\",\n    \"292\": \"Hcirc;\",\n    \"293\": \"hcirc;\",\n    \"294\": \"Hstrok;\",\n    \"295\": \"hstrok;\",\n    \"296\": \"Itilde;\",\n    \"297\": \"itilde;\",\n    \"298\": \"Imacr;\",\n    \"299\": \"imacr;\",\n    \"302\": \"Iogon;\",\n    \"303\": \"iogon;\",\n    \"304\": \"Idot;\",\n    \"305\": \"inodot;\",\n    \"306\": \"IJlig;\",\n    \"307\": \"ijlig;\",\n    \"308\": \"Jcirc;\",\n    \"309\": \"jcirc;\",\n    \"310\": \"Kcedil;\",\n    \"311\": \"kcedil;\",\n    \"312\": \"kgreen;\",\n    \"313\": \"Lacute;\",\n    \"314\": \"lacute;\",\n    \"315\": \"Lcedil;\",\n    \"316\": \"lcedil;\",\n    \"317\": \"Lcaron;\",\n    \"318\": \"lcaron;\",\n    \"319\": \"Lmidot;\",\n    \"320\": \"lmidot;\",\n    \"321\": \"Lstrok;\",\n    \"322\": \"lstrok;\",\n    \"323\": \"Nacute;\",\n    \"324\": \"nacute;\",\n    \"325\": \"Ncedil;\",\n    \"326\": \"ncedil;\",\n    \"327\": \"Ncaron;\",\n    \"328\": \"ncaron;\",\n    \"329\": \"napos;\",\n    \"330\": \"ENG;\",\n    \"331\": \"eng;\",\n    \"332\": \"Omacr;\",\n    \"333\": \"omacr;\",\n    \"336\": \"Odblac;\",\n    \"337\": \"odblac;\",\n    \"338\": \"OElig;\",\n    \"339\": \"oelig;\",\n    \"340\": \"Racute;\",\n    \"341\": \"racute;\",\n    \"342\": \"Rcedil;\",\n    \"343\": \"rcedil;\",\n    \"344\": \"Rcaron;\",\n    \"345\": \"rcaron;\",\n    \"346\": \"Sacute;\",\n    \"347\": \"sacute;\",\n    \"348\": \"Scirc;\",\n    \"349\": \"scirc;\",\n    \"350\": \"Scedil;\",\n    \"351\": \"scedil;\",\n    \"352\": \"Scaron;\",\n    \"353\": \"scaron;\",\n    \"354\": \"Tcedil;\",\n    \"355\": \"tcedil;\",\n    \"356\": \"Tcaron;\",\n    \"357\": \"tcaron;\",\n    \"358\": \"Tstrok;\",\n    \"359\": \"tstrok;\",\n    \"360\": \"Utilde;\",\n    \"361\": \"utilde;\",\n    \"362\": \"Umacr;\",\n    \"363\": \"umacr;\",\n    \"364\": \"Ubreve;\",\n    \"365\": \"ubreve;\",\n    \"366\": \"Uring;\",\n    \"367\": \"uring;\",\n    \"368\": \"Udblac;\",\n    \"369\": \"udblac;\",\n    \"370\": \"Uogon;\",\n    \"371\": \"uogon;\",\n    \"372\": \"Wcirc;\",\n    \"373\": \"wcirc;\",\n    \"374\": \"Ycirc;\",\n    \"375\": \"ycirc;\",\n    \"376\": \"Yuml;\",\n    \"377\": \"Zacute;\",\n    \"378\": \"zacute;\",\n    \"379\": \"Zdot;\",\n    \"380\": \"zdot;\",\n    \"381\": \"Zcaron;\",\n    \"382\": \"zcaron;\",\n    \"402\": \"fnof;\",\n    \"437\": \"imped;\",\n    \"501\": \"gacute;\",\n    \"567\": \"jmath;\",\n    \"710\": \"circ;\",\n    \"711\": \"Hacek;\",\n    \"728\": \"breve;\",\n    \"729\": \"dot;\",\n    \"730\": \"ring;\",\n    \"731\": \"ogon;\",\n    \"732\": \"tilde;\",\n    \"733\": \"DiacriticalDoubleAcute;\",\n    \"785\": \"DownBreve;\",\n    \"913\": \"Alpha;\",\n    \"914\": \"Beta;\",\n    \"915\": \"Gamma;\",\n    \"916\": \"Delta;\",\n    \"917\": \"Epsilon;\",\n    \"918\": \"Zeta;\",\n    \"919\": \"Eta;\",\n    \"920\": \"Theta;\",\n    \"921\": \"Iota;\",\n    \"922\": \"Kappa;\",\n    \"923\": \"Lambda;\",\n    \"924\": \"Mu;\",\n    \"925\": \"Nu;\",\n    \"926\": \"Xi;\",\n    \"927\": \"Omicron;\",\n    \"928\": \"Pi;\",\n    \"929\": \"Rho;\",\n    \"931\": \"Sigma;\",\n    \"932\": \"Tau;\",\n    \"933\": \"Upsilon;\",\n    \"934\": \"Phi;\",\n    \"935\": \"Chi;\",\n    \"936\": \"Psi;\",\n    \"937\": \"Omega;\",\n    \"945\": \"alpha;\",\n    \"946\": \"beta;\",\n    \"947\": \"gamma;\",\n    \"948\": \"delta;\",\n    \"949\": \"epsilon;\",\n    \"950\": \"zeta;\",\n    \"951\": \"eta;\",\n    \"952\": \"theta;\",\n    \"953\": \"iota;\",\n    \"954\": \"kappa;\",\n    \"955\": \"lambda;\",\n    \"956\": \"mu;\",\n    \"957\": \"nu;\",\n    \"958\": \"xi;\",\n    \"959\": \"omicron;\",\n    \"960\": \"pi;\",\n    \"961\": \"rho;\",\n    \"962\": \"varsigma;\",\n    \"963\": \"sigma;\",\n    \"964\": \"tau;\",\n    \"965\": \"upsilon;\",\n    \"966\": \"phi;\",\n    \"967\": \"chi;\",\n    \"968\": \"psi;\",\n    \"969\": \"omega;\",\n    \"977\": \"vartheta;\",\n    \"978\": \"upsih;\",\n    \"981\": \"varphi;\",\n    \"982\": \"varpi;\",\n    \"988\": \"Gammad;\",\n    \"989\": \"gammad;\",\n    \"1008\": \"varkappa;\",\n    \"1009\": \"varrho;\",\n    \"1013\": \"varepsilon;\",\n    \"1014\": \"bepsi;\",\n    \"1025\": \"IOcy;\",\n    \"1026\": \"DJcy;\",\n    \"1027\": \"GJcy;\",\n    \"1028\": \"Jukcy;\",\n    \"1029\": \"DScy;\",\n    \"1030\": \"Iukcy;\",\n    \"1031\": \"YIcy;\",\n    \"1032\": \"Jsercy;\",\n    \"1033\": \"LJcy;\",\n    \"1034\": \"NJcy;\",\n    \"1035\": \"TSHcy;\",\n    \"1036\": \"KJcy;\",\n    \"1038\": \"Ubrcy;\",\n    \"1039\": \"DZcy;\",\n    \"1040\": \"Acy;\",\n    \"1041\": \"Bcy;\",\n    \"1042\": \"Vcy;\",\n    \"1043\": \"Gcy;\",\n    \"1044\": \"Dcy;\",\n    \"1045\": \"IEcy;\",\n    \"1046\": \"ZHcy;\",\n    \"1047\": \"Zcy;\",\n    \"1048\": \"Icy;\",\n    \"1049\": \"Jcy;\",\n    \"1050\": \"Kcy;\",\n    \"1051\": \"Lcy;\",\n    \"1052\": \"Mcy;\",\n    \"1053\": \"Ncy;\",\n    \"1054\": \"Ocy;\",\n    \"1055\": \"Pcy;\",\n    \"1056\": \"Rcy;\",\n    \"1057\": \"Scy;\",\n    \"1058\": \"Tcy;\",\n    \"1059\": \"Ucy;\",\n    \"1060\": \"Fcy;\",\n    \"1061\": \"KHcy;\",\n    \"1062\": \"TScy;\",\n    \"1063\": \"CHcy;\",\n    \"1064\": \"SHcy;\",\n    \"1065\": \"SHCHcy;\",\n    \"1066\": \"HARDcy;\",\n    \"1067\": \"Ycy;\",\n    \"1068\": \"SOFTcy;\",\n    \"1069\": \"Ecy;\",\n    \"1070\": \"YUcy;\",\n    \"1071\": \"YAcy;\",\n    \"1072\": \"acy;\",\n    \"1073\": \"bcy;\",\n    \"1074\": \"vcy;\",\n    \"1075\": \"gcy;\",\n    \"1076\": \"dcy;\",\n    \"1077\": \"iecy;\",\n    \"1078\": \"zhcy;\",\n    \"1079\": \"zcy;\",\n    \"1080\": \"icy;\",\n    \"1081\": \"jcy;\",\n    \"1082\": \"kcy;\",\n    \"1083\": \"lcy;\",\n    \"1084\": \"mcy;\",\n    \"1085\": \"ncy;\",\n    \"1086\": \"ocy;\",\n    \"1087\": \"pcy;\",\n    \"1088\": \"rcy;\",\n    \"1089\": \"scy;\",\n    \"1090\": \"tcy;\",\n    \"1091\": \"ucy;\",\n    \"1092\": \"fcy;\",\n    \"1093\": \"khcy;\",\n    \"1094\": \"tscy;\",\n    \"1095\": \"chcy;\",\n    \"1096\": \"shcy;\",\n    \"1097\": \"shchcy;\",\n    \"1098\": \"hardcy;\",\n    \"1099\": \"ycy;\",\n    \"1100\": \"softcy;\",\n    \"1101\": \"ecy;\",\n    \"1102\": \"yucy;\",\n    \"1103\": \"yacy;\",\n    \"1105\": \"iocy;\",\n    \"1106\": \"djcy;\",\n    \"1107\": \"gjcy;\",\n    \"1108\": \"jukcy;\",\n    \"1109\": \"dscy;\",\n    \"1110\": \"iukcy;\",\n    \"1111\": \"yicy;\",\n    \"1112\": \"jsercy;\",\n    \"1113\": \"ljcy;\",\n    \"1114\": \"njcy;\",\n    \"1115\": \"tshcy;\",\n    \"1116\": \"kjcy;\",\n    \"1118\": \"ubrcy;\",\n    \"1119\": \"dzcy;\",\n    \"8194\": \"ensp;\",\n    \"8195\": \"emsp;\",\n    \"8196\": \"emsp13;\",\n    \"8197\": \"emsp14;\",\n    \"8199\": \"numsp;\",\n    \"8200\": \"puncsp;\",\n    \"8201\": \"ThinSpace;\",\n    \"8202\": \"VeryThinSpace;\",\n    \"8203\": \"ZeroWidthSpace;\",\n    \"8204\": \"zwnj;\",\n    \"8205\": \"zwj;\",\n    \"8206\": \"lrm;\",\n    \"8207\": \"rlm;\",\n    \"8208\": \"hyphen;\",\n    \"8211\": \"ndash;\",\n    \"8212\": \"mdash;\",\n    \"8213\": \"horbar;\",\n    \"8214\": \"Vert;\",\n    \"8216\": \"OpenCurlyQuote;\",\n    \"8217\": \"rsquor;\",\n    \"8218\": \"sbquo;\",\n    \"8220\": \"OpenCurlyDoubleQuote;\",\n    \"8221\": \"rdquor;\",\n    \"8222\": \"ldquor;\",\n    \"8224\": \"dagger;\",\n    \"8225\": \"ddagger;\",\n    \"8226\": \"bullet;\",\n    \"8229\": \"nldr;\",\n    \"8230\": \"mldr;\",\n    \"8240\": \"permil;\",\n    \"8241\": \"pertenk;\",\n    \"8242\": \"prime;\",\n    \"8243\": \"Prime;\",\n    \"8244\": \"tprime;\",\n    \"8245\": \"bprime;\",\n    \"8249\": \"lsaquo;\",\n    \"8250\": \"rsaquo;\",\n    \"8254\": \"OverBar;\",\n    \"8257\": \"caret;\",\n    \"8259\": \"hybull;\",\n    \"8260\": \"frasl;\",\n    \"8271\": \"bsemi;\",\n    \"8279\": \"qprime;\",\n    \"8287\": \"MediumSpace;\",\n    \"8288\": \"NoBreak;\",\n    \"8289\": \"ApplyFunction;\",\n    \"8290\": \"it;\",\n    \"8291\": \"InvisibleComma;\",\n    \"8364\": \"euro;\",\n    \"8411\": \"TripleDot;\",\n    \"8412\": \"DotDot;\",\n    \"8450\": \"Copf;\",\n    \"8453\": \"incare;\",\n    \"8458\": \"gscr;\",\n    \"8459\": \"Hscr;\",\n    \"8460\": \"Poincareplane;\",\n    \"8461\": \"quaternions;\",\n    \"8462\": \"planckh;\",\n    \"8463\": \"plankv;\",\n    \"8464\": \"Iscr;\",\n    \"8465\": \"imagpart;\",\n    \"8466\": \"Lscr;\",\n    \"8467\": \"ell;\",\n    \"8469\": \"Nopf;\",\n    \"8470\": \"numero;\",\n    \"8471\": \"copysr;\",\n    \"8472\": \"wp;\",\n    \"8473\": \"primes;\",\n    \"8474\": \"rationals;\",\n    \"8475\": \"Rscr;\",\n    \"8476\": \"Rfr;\",\n    \"8477\": \"Ropf;\",\n    \"8478\": \"rx;\",\n    \"8482\": \"trade;\",\n    \"8484\": \"Zopf;\",\n    \"8487\": \"mho;\",\n    \"8488\": \"Zfr;\",\n    \"8489\": \"iiota;\",\n    \"8492\": \"Bscr;\",\n    \"8493\": \"Cfr;\",\n    \"8495\": \"escr;\",\n    \"8496\": \"expectation;\",\n    \"8497\": \"Fscr;\",\n    \"8499\": \"phmmat;\",\n    \"8500\": \"oscr;\",\n    \"8501\": \"aleph;\",\n    \"8502\": \"beth;\",\n    \"8503\": \"gimel;\",\n    \"8504\": \"daleth;\",\n    \"8517\": \"DD;\",\n    \"8518\": \"DifferentialD;\",\n    \"8519\": \"exponentiale;\",\n    \"8520\": \"ImaginaryI;\",\n    \"8531\": \"frac13;\",\n    \"8532\": \"frac23;\",\n    \"8533\": \"frac15;\",\n    \"8534\": \"frac25;\",\n    \"8535\": \"frac35;\",\n    \"8536\": \"frac45;\",\n    \"8537\": \"frac16;\",\n    \"8538\": \"frac56;\",\n    \"8539\": \"frac18;\",\n    \"8540\": \"frac38;\",\n    \"8541\": \"frac58;\",\n    \"8542\": \"frac78;\",\n    \"8592\": \"slarr;\",\n    \"8593\": \"uparrow;\",\n    \"8594\": \"srarr;\",\n    \"8595\": \"ShortDownArrow;\",\n    \"8596\": \"leftrightarrow;\",\n    \"8597\": \"varr;\",\n    \"8598\": \"UpperLeftArrow;\",\n    \"8599\": \"UpperRightArrow;\",\n    \"8600\": \"searrow;\",\n    \"8601\": \"swarrow;\",\n    \"8602\": \"nleftarrow;\",\n    \"8603\": \"nrightarrow;\",\n    \"8605\": \"rightsquigarrow;\",\n    \"8606\": \"twoheadleftarrow;\",\n    \"8607\": \"Uarr;\",\n    \"8608\": \"twoheadrightarrow;\",\n    \"8609\": \"Darr;\",\n    \"8610\": \"leftarrowtail;\",\n    \"8611\": \"rightarrowtail;\",\n    \"8612\": \"mapstoleft;\",\n    \"8613\": \"UpTeeArrow;\",\n    \"8614\": \"RightTeeArrow;\",\n    \"8615\": \"mapstodown;\",\n    \"8617\": \"larrhk;\",\n    \"8618\": \"rarrhk;\",\n    \"8619\": \"looparrowleft;\",\n    \"8620\": \"rarrlp;\",\n    \"8621\": \"leftrightsquigarrow;\",\n    \"8622\": \"nleftrightarrow;\",\n    \"8624\": \"lsh;\",\n    \"8625\": \"rsh;\",\n    \"8626\": \"ldsh;\",\n    \"8627\": \"rdsh;\",\n    \"8629\": \"crarr;\",\n    \"8630\": \"curvearrowleft;\",\n    \"8631\": \"curvearrowright;\",\n    \"8634\": \"olarr;\",\n    \"8635\": \"orarr;\",\n    \"8636\": \"lharu;\",\n    \"8637\": \"lhard;\",\n    \"8638\": \"upharpoonright;\",\n    \"8639\": \"upharpoonleft;\",\n    \"8640\": \"RightVector;\",\n    \"8641\": \"rightharpoondown;\",\n    \"8642\": \"RightDownVector;\",\n    \"8643\": \"LeftDownVector;\",\n    \"8644\": \"rlarr;\",\n    \"8645\": \"UpArrowDownArrow;\",\n    \"8646\": \"lrarr;\",\n    \"8647\": \"llarr;\",\n    \"8648\": \"uuarr;\",\n    \"8649\": \"rrarr;\",\n    \"8650\": \"downdownarrows;\",\n    \"8651\": \"ReverseEquilibrium;\",\n    \"8652\": \"rlhar;\",\n    \"8653\": \"nLeftarrow;\",\n    \"8654\": \"nLeftrightarrow;\",\n    \"8655\": \"nRightarrow;\",\n    \"8656\": \"Leftarrow;\",\n    \"8657\": \"Uparrow;\",\n    \"8658\": \"Rightarrow;\",\n    \"8659\": \"Downarrow;\",\n    \"8660\": \"Leftrightarrow;\",\n    \"8661\": \"vArr;\",\n    \"8662\": \"nwArr;\",\n    \"8663\": \"neArr;\",\n    \"8664\": \"seArr;\",\n    \"8665\": \"swArr;\",\n    \"8666\": \"Lleftarrow;\",\n    \"8667\": \"Rrightarrow;\",\n    \"8669\": \"zigrarr;\",\n    \"8676\": \"LeftArrowBar;\",\n    \"8677\": \"RightArrowBar;\",\n    \"8693\": \"duarr;\",\n    \"8701\": \"loarr;\",\n    \"8702\": \"roarr;\",\n    \"8703\": \"hoarr;\",\n    \"8704\": \"forall;\",\n    \"8705\": \"complement;\",\n    \"8706\": \"PartialD;\",\n    \"8707\": \"Exists;\",\n    \"8708\": \"NotExists;\",\n    \"8709\": \"varnothing;\",\n    \"8711\": \"nabla;\",\n    \"8712\": \"isinv;\",\n    \"8713\": \"notinva;\",\n    \"8715\": \"SuchThat;\",\n    \"8716\": \"NotReverseElement;\",\n    \"8719\": \"Product;\",\n    \"8720\": \"Coproduct;\",\n    \"8721\": \"sum;\",\n    \"8722\": \"minus;\",\n    \"8723\": \"mp;\",\n    \"8724\": \"plusdo;\",\n    \"8726\": \"ssetmn;\",\n    \"8727\": \"lowast;\",\n    \"8728\": \"SmallCircle;\",\n    \"8730\": \"Sqrt;\",\n    \"8733\": \"vprop;\",\n    \"8734\": \"infin;\",\n    \"8735\": \"angrt;\",\n    \"8736\": \"angle;\",\n    \"8737\": \"measuredangle;\",\n    \"8738\": \"angsph;\",\n    \"8739\": \"VerticalBar;\",\n    \"8740\": \"nsmid;\",\n    \"8741\": \"spar;\",\n    \"8742\": \"nspar;\",\n    \"8743\": \"wedge;\",\n    \"8744\": \"vee;\",\n    \"8745\": \"cap;\",\n    \"8746\": \"cup;\",\n    \"8747\": \"Integral;\",\n    \"8748\": \"Int;\",\n    \"8749\": \"tint;\",\n    \"8750\": \"oint;\",\n    \"8751\": \"DoubleContourIntegral;\",\n    \"8752\": \"Cconint;\",\n    \"8753\": \"cwint;\",\n    \"8754\": \"cwconint;\",\n    \"8755\": \"CounterClockwiseContourIntegral;\",\n    \"8756\": \"therefore;\",\n    \"8757\": \"because;\",\n    \"8758\": \"ratio;\",\n    \"8759\": \"Proportion;\",\n    \"8760\": \"minusd;\",\n    \"8762\": \"mDDot;\",\n    \"8763\": \"homtht;\",\n    \"8764\": \"Tilde;\",\n    \"8765\": \"bsim;\",\n    \"8766\": \"mstpos;\",\n    \"8767\": \"acd;\",\n    \"8768\": \"wreath;\",\n    \"8769\": \"nsim;\",\n    \"8770\": \"esim;\",\n    \"8771\": \"TildeEqual;\",\n    \"8772\": \"nsimeq;\",\n    \"8773\": \"TildeFullEqual;\",\n    \"8774\": \"simne;\",\n    \"8775\": \"NotTildeFullEqual;\",\n    \"8776\": \"TildeTilde;\",\n    \"8777\": \"NotTildeTilde;\",\n    \"8778\": \"approxeq;\",\n    \"8779\": \"apid;\",\n    \"8780\": \"bcong;\",\n    \"8781\": \"CupCap;\",\n    \"8782\": \"HumpDownHump;\",\n    \"8783\": \"HumpEqual;\",\n    \"8784\": \"esdot;\",\n    \"8785\": \"eDot;\",\n    \"8786\": \"fallingdotseq;\",\n    \"8787\": \"risingdotseq;\",\n    \"8788\": \"coloneq;\",\n    \"8789\": \"eqcolon;\",\n    \"8790\": \"eqcirc;\",\n    \"8791\": \"cire;\",\n    \"8793\": \"wedgeq;\",\n    \"8794\": \"veeeq;\",\n    \"8796\": \"trie;\",\n    \"8799\": \"questeq;\",\n    \"8800\": \"NotEqual;\",\n    \"8801\": \"equiv;\",\n    \"8802\": \"NotCongruent;\",\n    \"8804\": \"leq;\",\n    \"8805\": \"GreaterEqual;\",\n    \"8806\": \"LessFullEqual;\",\n    \"8807\": \"GreaterFullEqual;\",\n    \"8808\": \"lneqq;\",\n    \"8809\": \"gneqq;\",\n    \"8810\": \"NestedLessLess;\",\n    \"8811\": \"NestedGreaterGreater;\",\n    \"8812\": \"twixt;\",\n    \"8813\": \"NotCupCap;\",\n    \"8814\": \"NotLess;\",\n    \"8815\": \"NotGreater;\",\n    \"8816\": \"NotLessEqual;\",\n    \"8817\": \"NotGreaterEqual;\",\n    \"8818\": \"lsim;\",\n    \"8819\": \"gtrsim;\",\n    \"8820\": \"NotLessTilde;\",\n    \"8821\": \"NotGreaterTilde;\",\n    \"8822\": \"lg;\",\n    \"8823\": \"gtrless;\",\n    \"8824\": \"ntlg;\",\n    \"8825\": \"ntgl;\",\n    \"8826\": \"Precedes;\",\n    \"8827\": \"Succeeds;\",\n    \"8828\": \"PrecedesSlantEqual;\",\n    \"8829\": \"SucceedsSlantEqual;\",\n    \"8830\": \"prsim;\",\n    \"8831\": \"succsim;\",\n    \"8832\": \"nprec;\",\n    \"8833\": \"nsucc;\",\n    \"8834\": \"subset;\",\n    \"8835\": \"supset;\",\n    \"8836\": \"nsub;\",\n    \"8837\": \"nsup;\",\n    \"8838\": \"SubsetEqual;\",\n    \"8839\": \"supseteq;\",\n    \"8840\": \"nsubseteq;\",\n    \"8841\": \"nsupseteq;\",\n    \"8842\": \"subsetneq;\",\n    \"8843\": \"supsetneq;\",\n    \"8845\": \"cupdot;\",\n    \"8846\": \"uplus;\",\n    \"8847\": \"SquareSubset;\",\n    \"8848\": \"SquareSuperset;\",\n    \"8849\": \"SquareSubsetEqual;\",\n    \"8850\": \"SquareSupersetEqual;\",\n    \"8851\": \"SquareIntersection;\",\n    \"8852\": \"SquareUnion;\",\n    \"8853\": \"oplus;\",\n    \"8854\": \"ominus;\",\n    \"8855\": \"otimes;\",\n    \"8856\": \"osol;\",\n    \"8857\": \"odot;\",\n    \"8858\": \"ocir;\",\n    \"8859\": \"oast;\",\n    \"8861\": \"odash;\",\n    \"8862\": \"plusb;\",\n    \"8863\": \"minusb;\",\n    \"8864\": \"timesb;\",\n    \"8865\": \"sdotb;\",\n    \"8866\": \"vdash;\",\n    \"8867\": \"LeftTee;\",\n    \"8868\": \"top;\",\n    \"8869\": \"UpTee;\",\n    \"8871\": \"models;\",\n    \"8872\": \"vDash;\",\n    \"8873\": \"Vdash;\",\n    \"8874\": \"Vvdash;\",\n    \"8875\": \"VDash;\",\n    \"8876\": \"nvdash;\",\n    \"8877\": \"nvDash;\",\n    \"8878\": \"nVdash;\",\n    \"8879\": \"nVDash;\",\n    \"8880\": \"prurel;\",\n    \"8882\": \"vltri;\",\n    \"8883\": \"vrtri;\",\n    \"8884\": \"trianglelefteq;\",\n    \"8885\": \"trianglerighteq;\",\n    \"8886\": \"origof;\",\n    \"8887\": \"imof;\",\n    \"8888\": \"mumap;\",\n    \"8889\": \"hercon;\",\n    \"8890\": \"intercal;\",\n    \"8891\": \"veebar;\",\n    \"8893\": \"barvee;\",\n    \"8894\": \"angrtvb;\",\n    \"8895\": \"lrtri;\",\n    \"8896\": \"xwedge;\",\n    \"8897\": \"xvee;\",\n    \"8898\": \"xcap;\",\n    \"8899\": \"xcup;\",\n    \"8900\": \"diamond;\",\n    \"8901\": \"sdot;\",\n    \"8902\": \"Star;\",\n    \"8903\": \"divonx;\",\n    \"8904\": \"bowtie;\",\n    \"8905\": \"ltimes;\",\n    \"8906\": \"rtimes;\",\n    \"8907\": \"lthree;\",\n    \"8908\": \"rthree;\",\n    \"8909\": \"bsime;\",\n    \"8910\": \"cuvee;\",\n    \"8911\": \"cuwed;\",\n    \"8912\": \"Subset;\",\n    \"8913\": \"Supset;\",\n    \"8914\": \"Cap;\",\n    \"8915\": \"Cup;\",\n    \"8916\": \"pitchfork;\",\n    \"8917\": \"epar;\",\n    \"8918\": \"ltdot;\",\n    \"8919\": \"gtrdot;\",\n    \"8920\": \"Ll;\",\n    \"8921\": \"ggg;\",\n    \"8922\": \"LessEqualGreater;\",\n    \"8923\": \"gtreqless;\",\n    \"8926\": \"curlyeqprec;\",\n    \"8927\": \"curlyeqsucc;\",\n    \"8928\": \"nprcue;\",\n    \"8929\": \"nsccue;\",\n    \"8930\": \"nsqsube;\",\n    \"8931\": \"nsqsupe;\",\n    \"8934\": \"lnsim;\",\n    \"8935\": \"gnsim;\",\n    \"8936\": \"prnsim;\",\n    \"8937\": \"succnsim;\",\n    \"8938\": \"ntriangleleft;\",\n    \"8939\": \"ntriangleright;\",\n    \"8940\": \"ntrianglelefteq;\",\n    \"8941\": \"ntrianglerighteq;\",\n    \"8942\": \"vellip;\",\n    \"8943\": \"ctdot;\",\n    \"8944\": \"utdot;\",\n    \"8945\": \"dtdot;\",\n    \"8946\": \"disin;\",\n    \"8947\": \"isinsv;\",\n    \"8948\": \"isins;\",\n    \"8949\": \"isindot;\",\n    \"8950\": \"notinvc;\",\n    \"8951\": \"notinvb;\",\n    \"8953\": \"isinE;\",\n    \"8954\": \"nisd;\",\n    \"8955\": \"xnis;\",\n    \"8956\": \"nis;\",\n    \"8957\": \"notnivc;\",\n    \"8958\": \"notnivb;\",\n    \"8965\": \"barwedge;\",\n    \"8966\": \"doublebarwedge;\",\n    \"8968\": \"LeftCeiling;\",\n    \"8969\": \"RightCeiling;\",\n    \"8970\": \"lfloor;\",\n    \"8971\": \"RightFloor;\",\n    \"8972\": \"drcrop;\",\n    \"8973\": \"dlcrop;\",\n    \"8974\": \"urcrop;\",\n    \"8975\": \"ulcrop;\",\n    \"8976\": \"bnot;\",\n    \"8978\": \"profline;\",\n    \"8979\": \"profsurf;\",\n    \"8981\": \"telrec;\",\n    \"8982\": \"target;\",\n    \"8988\": \"ulcorner;\",\n    \"8989\": \"urcorner;\",\n    \"8990\": \"llcorner;\",\n    \"8991\": \"lrcorner;\",\n    \"8994\": \"sfrown;\",\n    \"8995\": \"ssmile;\",\n    \"9005\": \"cylcty;\",\n    \"9006\": \"profalar;\",\n    \"9014\": \"topbot;\",\n    \"9021\": \"ovbar;\",\n    \"9023\": \"solbar;\",\n    \"9084\": \"angzarr;\",\n    \"9136\": \"lmoustache;\",\n    \"9137\": \"rmoustache;\",\n    \"9140\": \"tbrk;\",\n    \"9141\": \"UnderBracket;\",\n    \"9142\": \"bbrktbrk;\",\n    \"9180\": \"OverParenthesis;\",\n    \"9181\": \"UnderParenthesis;\",\n    \"9182\": \"OverBrace;\",\n    \"9183\": \"UnderBrace;\",\n    \"9186\": \"trpezium;\",\n    \"9191\": \"elinters;\",\n    \"9251\": \"blank;\",\n    \"9416\": \"oS;\",\n    \"9472\": \"HorizontalLine;\",\n    \"9474\": \"boxv;\",\n    \"9484\": \"boxdr;\",\n    \"9488\": \"boxdl;\",\n    \"9492\": \"boxur;\",\n    \"9496\": \"boxul;\",\n    \"9500\": \"boxvr;\",\n    \"9508\": \"boxvl;\",\n    \"9516\": \"boxhd;\",\n    \"9524\": \"boxhu;\",\n    \"9532\": \"boxvh;\",\n    \"9552\": \"boxH;\",\n    \"9553\": \"boxV;\",\n    \"9554\": \"boxdR;\",\n    \"9555\": \"boxDr;\",\n    \"9556\": \"boxDR;\",\n    \"9557\": \"boxdL;\",\n    \"9558\": \"boxDl;\",\n    \"9559\": \"boxDL;\",\n    \"9560\": \"boxuR;\",\n    \"9561\": \"boxUr;\",\n    \"9562\": \"boxUR;\",\n    \"9563\": \"boxuL;\",\n    \"9564\": \"boxUl;\",\n    \"9565\": \"boxUL;\",\n    \"9566\": \"boxvR;\",\n    \"9567\": \"boxVr;\",\n    \"9568\": \"boxVR;\",\n    \"9569\": \"boxvL;\",\n    \"9570\": \"boxVl;\",\n    \"9571\": \"boxVL;\",\n    \"9572\": \"boxHd;\",\n    \"9573\": \"boxhD;\",\n    \"9574\": \"boxHD;\",\n    \"9575\": \"boxHu;\",\n    \"9576\": \"boxhU;\",\n    \"9577\": \"boxHU;\",\n    \"9578\": \"boxvH;\",\n    \"9579\": \"boxVh;\",\n    \"9580\": \"boxVH;\",\n    \"9600\": \"uhblk;\",\n    \"9604\": \"lhblk;\",\n    \"9608\": \"block;\",\n    \"9617\": \"blk14;\",\n    \"9618\": \"blk12;\",\n    \"9619\": \"blk34;\",\n    \"9633\": \"square;\",\n    \"9642\": \"squf;\",\n    \"9643\": \"EmptyVerySmallSquare;\",\n    \"9645\": \"rect;\",\n    \"9646\": \"marker;\",\n    \"9649\": \"fltns;\",\n    \"9651\": \"xutri;\",\n    \"9652\": \"utrif;\",\n    \"9653\": \"utri;\",\n    \"9656\": \"rtrif;\",\n    \"9657\": \"triangleright;\",\n    \"9661\": \"xdtri;\",\n    \"9662\": \"dtrif;\",\n    \"9663\": \"triangledown;\",\n    \"9666\": \"ltrif;\",\n    \"9667\": \"triangleleft;\",\n    \"9674\": \"lozenge;\",\n    \"9675\": \"cir;\",\n    \"9708\": \"tridot;\",\n    \"9711\": \"xcirc;\",\n    \"9720\": \"ultri;\",\n    \"9721\": \"urtri;\",\n    \"9722\": \"lltri;\",\n    \"9723\": \"EmptySmallSquare;\",\n    \"9724\": \"FilledSmallSquare;\",\n    \"9733\": \"starf;\",\n    \"9734\": \"star;\",\n    \"9742\": \"phone;\",\n    \"9792\": \"female;\",\n    \"9794\": \"male;\",\n    \"9824\": \"spadesuit;\",\n    \"9827\": \"clubsuit;\",\n    \"9829\": \"heartsuit;\",\n    \"9830\": \"diams;\",\n    \"9834\": \"sung;\",\n    \"9837\": \"flat;\",\n    \"9838\": \"natural;\",\n    \"9839\": \"sharp;\",\n    \"10003\": \"checkmark;\",\n    \"10007\": \"cross;\",\n    \"10016\": \"maltese;\",\n    \"10038\": \"sext;\",\n    \"10072\": \"VerticalSeparator;\",\n    \"10098\": \"lbbrk;\",\n    \"10099\": \"rbbrk;\",\n    \"10184\": \"bsolhsub;\",\n    \"10185\": \"suphsol;\",\n    \"10214\": \"lobrk;\",\n    \"10215\": \"robrk;\",\n    \"10216\": \"LeftAngleBracket;\",\n    \"10217\": \"RightAngleBracket;\",\n    \"10218\": \"Lang;\",\n    \"10219\": \"Rang;\",\n    \"10220\": \"loang;\",\n    \"10221\": \"roang;\",\n    \"10229\": \"xlarr;\",\n    \"10230\": \"xrarr;\",\n    \"10231\": \"xharr;\",\n    \"10232\": \"xlArr;\",\n    \"10233\": \"xrArr;\",\n    \"10234\": \"xhArr;\",\n    \"10236\": \"xmap;\",\n    \"10239\": \"dzigrarr;\",\n    \"10498\": \"nvlArr;\",\n    \"10499\": \"nvrArr;\",\n    \"10500\": \"nvHarr;\",\n    \"10501\": \"Map;\",\n    \"10508\": \"lbarr;\",\n    \"10509\": \"rbarr;\",\n    \"10510\": \"lBarr;\",\n    \"10511\": \"rBarr;\",\n    \"10512\": \"RBarr;\",\n    \"10513\": \"DDotrahd;\",\n    \"10514\": \"UpArrowBar;\",\n    \"10515\": \"DownArrowBar;\",\n    \"10518\": \"Rarrtl;\",\n    \"10521\": \"latail;\",\n    \"10522\": \"ratail;\",\n    \"10523\": \"lAtail;\",\n    \"10524\": \"rAtail;\",\n    \"10525\": \"larrfs;\",\n    \"10526\": \"rarrfs;\",\n    \"10527\": \"larrbfs;\",\n    \"10528\": \"rarrbfs;\",\n    \"10531\": \"nwarhk;\",\n    \"10532\": \"nearhk;\",\n    \"10533\": \"searhk;\",\n    \"10534\": \"swarhk;\",\n    \"10535\": \"nwnear;\",\n    \"10536\": \"toea;\",\n    \"10537\": \"tosa;\",\n    \"10538\": \"swnwar;\",\n    \"10547\": \"rarrc;\",\n    \"10549\": \"cudarrr;\",\n    \"10550\": \"ldca;\",\n    \"10551\": \"rdca;\",\n    \"10552\": \"cudarrl;\",\n    \"10553\": \"larrpl;\",\n    \"10556\": \"curarrm;\",\n    \"10557\": \"cularrp;\",\n    \"10565\": \"rarrpl;\",\n    \"10568\": \"harrcir;\",\n    \"10569\": \"Uarrocir;\",\n    \"10570\": \"lurdshar;\",\n    \"10571\": \"ldrushar;\",\n    \"10574\": \"LeftRightVector;\",\n    \"10575\": \"RightUpDownVector;\",\n    \"10576\": \"DownLeftRightVector;\",\n    \"10577\": \"LeftUpDownVector;\",\n    \"10578\": \"LeftVectorBar;\",\n    \"10579\": \"RightVectorBar;\",\n    \"10580\": \"RightUpVectorBar;\",\n    \"10581\": \"RightDownVectorBar;\",\n    \"10582\": \"DownLeftVectorBar;\",\n    \"10583\": \"DownRightVectorBar;\",\n    \"10584\": \"LeftUpVectorBar;\",\n    \"10585\": \"LeftDownVectorBar;\",\n    \"10586\": \"LeftTeeVector;\",\n    \"10587\": \"RightTeeVector;\",\n    \"10588\": \"RightUpTeeVector;\",\n    \"10589\": \"RightDownTeeVector;\",\n    \"10590\": \"DownLeftTeeVector;\",\n    \"10591\": \"DownRightTeeVector;\",\n    \"10592\": \"LeftUpTeeVector;\",\n    \"10593\": \"LeftDownTeeVector;\",\n    \"10594\": \"lHar;\",\n    \"10595\": \"uHar;\",\n    \"10596\": \"rHar;\",\n    \"10597\": \"dHar;\",\n    \"10598\": \"luruhar;\",\n    \"10599\": \"ldrdhar;\",\n    \"10600\": \"ruluhar;\",\n    \"10601\": \"rdldhar;\",\n    \"10602\": \"lharul;\",\n    \"10603\": \"llhard;\",\n    \"10604\": \"rharul;\",\n    \"10605\": \"lrhard;\",\n    \"10606\": \"UpEquilibrium;\",\n    \"10607\": \"ReverseUpEquilibrium;\",\n    \"10608\": \"RoundImplies;\",\n    \"10609\": \"erarr;\",\n    \"10610\": \"simrarr;\",\n    \"10611\": \"larrsim;\",\n    \"10612\": \"rarrsim;\",\n    \"10613\": \"rarrap;\",\n    \"10614\": \"ltlarr;\",\n    \"10616\": \"gtrarr;\",\n    \"10617\": \"subrarr;\",\n    \"10619\": \"suplarr;\",\n    \"10620\": \"lfisht;\",\n    \"10621\": \"rfisht;\",\n    \"10622\": \"ufisht;\",\n    \"10623\": \"dfisht;\",\n    \"10629\": \"lopar;\",\n    \"10630\": \"ropar;\",\n    \"10635\": \"lbrke;\",\n    \"10636\": \"rbrke;\",\n    \"10637\": \"lbrkslu;\",\n    \"10638\": \"rbrksld;\",\n    \"10639\": \"lbrksld;\",\n    \"10640\": \"rbrkslu;\",\n    \"10641\": \"langd;\",\n    \"10642\": \"rangd;\",\n    \"10643\": \"lparlt;\",\n    \"10644\": \"rpargt;\",\n    \"10645\": \"gtlPar;\",\n    \"10646\": \"ltrPar;\",\n    \"10650\": \"vzigzag;\",\n    \"10652\": \"vangrt;\",\n    \"10653\": \"angrtvbd;\",\n    \"10660\": \"ange;\",\n    \"10661\": \"range;\",\n    \"10662\": \"dwangle;\",\n    \"10663\": \"uwangle;\",\n    \"10664\": \"angmsdaa;\",\n    \"10665\": \"angmsdab;\",\n    \"10666\": \"angmsdac;\",\n    \"10667\": \"angmsdad;\",\n    \"10668\": \"angmsdae;\",\n    \"10669\": \"angmsdaf;\",\n    \"10670\": \"angmsdag;\",\n    \"10671\": \"angmsdah;\",\n    \"10672\": \"bemptyv;\",\n    \"10673\": \"demptyv;\",\n    \"10674\": \"cemptyv;\",\n    \"10675\": \"raemptyv;\",\n    \"10676\": \"laemptyv;\",\n    \"10677\": \"ohbar;\",\n    \"10678\": \"omid;\",\n    \"10679\": \"opar;\",\n    \"10681\": \"operp;\",\n    \"10683\": \"olcross;\",\n    \"10684\": \"odsold;\",\n    \"10686\": \"olcir;\",\n    \"10687\": \"ofcir;\",\n    \"10688\": \"olt;\",\n    \"10689\": \"ogt;\",\n    \"10690\": \"cirscir;\",\n    \"10691\": \"cirE;\",\n    \"10692\": \"solb;\",\n    \"10693\": \"bsolb;\",\n    \"10697\": \"boxbox;\",\n    \"10701\": \"trisb;\",\n    \"10702\": \"rtriltri;\",\n    \"10703\": \"LeftTriangleBar;\",\n    \"10704\": \"RightTriangleBar;\",\n    \"10716\": \"iinfin;\",\n    \"10717\": \"infintie;\",\n    \"10718\": \"nvinfin;\",\n    \"10723\": \"eparsl;\",\n    \"10724\": \"smeparsl;\",\n    \"10725\": \"eqvparsl;\",\n    \"10731\": \"lozf;\",\n    \"10740\": \"RuleDelayed;\",\n    \"10742\": \"dsol;\",\n    \"10752\": \"xodot;\",\n    \"10753\": \"xoplus;\",\n    \"10754\": \"xotime;\",\n    \"10756\": \"xuplus;\",\n    \"10758\": \"xsqcup;\",\n    \"10764\": \"qint;\",\n    \"10765\": \"fpartint;\",\n    \"10768\": \"cirfnint;\",\n    \"10769\": \"awint;\",\n    \"10770\": \"rppolint;\",\n    \"10771\": \"scpolint;\",\n    \"10772\": \"npolint;\",\n    \"10773\": \"pointint;\",\n    \"10774\": \"quatint;\",\n    \"10775\": \"intlarhk;\",\n    \"10786\": \"pluscir;\",\n    \"10787\": \"plusacir;\",\n    \"10788\": \"simplus;\",\n    \"10789\": \"plusdu;\",\n    \"10790\": \"plussim;\",\n    \"10791\": \"plustwo;\",\n    \"10793\": \"mcomma;\",\n    \"10794\": \"minusdu;\",\n    \"10797\": \"loplus;\",\n    \"10798\": \"roplus;\",\n    \"10799\": \"Cross;\",\n    \"10800\": \"timesd;\",\n    \"10801\": \"timesbar;\",\n    \"10803\": \"smashp;\",\n    \"10804\": \"lotimes;\",\n    \"10805\": \"rotimes;\",\n    \"10806\": \"otimesas;\",\n    \"10807\": \"Otimes;\",\n    \"10808\": \"odiv;\",\n    \"10809\": \"triplus;\",\n    \"10810\": \"triminus;\",\n    \"10811\": \"tritime;\",\n    \"10812\": \"iprod;\",\n    \"10815\": \"amalg;\",\n    \"10816\": \"capdot;\",\n    \"10818\": \"ncup;\",\n    \"10819\": \"ncap;\",\n    \"10820\": \"capand;\",\n    \"10821\": \"cupor;\",\n    \"10822\": \"cupcap;\",\n    \"10823\": \"capcup;\",\n    \"10824\": \"cupbrcap;\",\n    \"10825\": \"capbrcup;\",\n    \"10826\": \"cupcup;\",\n    \"10827\": \"capcap;\",\n    \"10828\": \"ccups;\",\n    \"10829\": \"ccaps;\",\n    \"10832\": \"ccupssm;\",\n    \"10835\": \"And;\",\n    \"10836\": \"Or;\",\n    \"10837\": \"andand;\",\n    \"10838\": \"oror;\",\n    \"10839\": \"orslope;\",\n    \"10840\": \"andslope;\",\n    \"10842\": \"andv;\",\n    \"10843\": \"orv;\",\n    \"10844\": \"andd;\",\n    \"10845\": \"ord;\",\n    \"10847\": \"wedbar;\",\n    \"10854\": \"sdote;\",\n    \"10858\": \"simdot;\",\n    \"10861\": \"congdot;\",\n    \"10862\": \"easter;\",\n    \"10863\": \"apacir;\",\n    \"10864\": \"apE;\",\n    \"10865\": \"eplus;\",\n    \"10866\": \"pluse;\",\n    \"10867\": \"Esim;\",\n    \"10868\": \"Colone;\",\n    \"10869\": \"Equal;\",\n    \"10871\": \"eDDot;\",\n    \"10872\": \"equivDD;\",\n    \"10873\": \"ltcir;\",\n    \"10874\": \"gtcir;\",\n    \"10875\": \"ltquest;\",\n    \"10876\": \"gtquest;\",\n    \"10877\": \"LessSlantEqual;\",\n    \"10878\": \"GreaterSlantEqual;\",\n    \"10879\": \"lesdot;\",\n    \"10880\": \"gesdot;\",\n    \"10881\": \"lesdoto;\",\n    \"10882\": \"gesdoto;\",\n    \"10883\": \"lesdotor;\",\n    \"10884\": \"gesdotol;\",\n    \"10885\": \"lessapprox;\",\n    \"10886\": \"gtrapprox;\",\n    \"10887\": \"lneq;\",\n    \"10888\": \"gneq;\",\n    \"10889\": \"lnapprox;\",\n    \"10890\": \"gnapprox;\",\n    \"10891\": \"lesseqqgtr;\",\n    \"10892\": \"gtreqqless;\",\n    \"10893\": \"lsime;\",\n    \"10894\": \"gsime;\",\n    \"10895\": \"lsimg;\",\n    \"10896\": \"gsiml;\",\n    \"10897\": \"lgE;\",\n    \"10898\": \"glE;\",\n    \"10899\": \"lesges;\",\n    \"10900\": \"gesles;\",\n    \"10901\": \"eqslantless;\",\n    \"10902\": \"eqslantgtr;\",\n    \"10903\": \"elsdot;\",\n    \"10904\": \"egsdot;\",\n    \"10905\": \"el;\",\n    \"10906\": \"eg;\",\n    \"10909\": \"siml;\",\n    \"10910\": \"simg;\",\n    \"10911\": \"simlE;\",\n    \"10912\": \"simgE;\",\n    \"10913\": \"LessLess;\",\n    \"10914\": \"GreaterGreater;\",\n    \"10916\": \"glj;\",\n    \"10917\": \"gla;\",\n    \"10918\": \"ltcc;\",\n    \"10919\": \"gtcc;\",\n    \"10920\": \"lescc;\",\n    \"10921\": \"gescc;\",\n    \"10922\": \"smt;\",\n    \"10923\": \"lat;\",\n    \"10924\": \"smte;\",\n    \"10925\": \"late;\",\n    \"10926\": \"bumpE;\",\n    \"10927\": \"preceq;\",\n    \"10928\": \"succeq;\",\n    \"10931\": \"prE;\",\n    \"10932\": \"scE;\",\n    \"10933\": \"prnE;\",\n    \"10934\": \"succneqq;\",\n    \"10935\": \"precapprox;\",\n    \"10936\": \"succapprox;\",\n    \"10937\": \"prnap;\",\n    \"10938\": \"succnapprox;\",\n    \"10939\": \"Pr;\",\n    \"10940\": \"Sc;\",\n    \"10941\": \"subdot;\",\n    \"10942\": \"supdot;\",\n    \"10943\": \"subplus;\",\n    \"10944\": \"supplus;\",\n    \"10945\": \"submult;\",\n    \"10946\": \"supmult;\",\n    \"10947\": \"subedot;\",\n    \"10948\": \"supedot;\",\n    \"10949\": \"subseteqq;\",\n    \"10950\": \"supseteqq;\",\n    \"10951\": \"subsim;\",\n    \"10952\": \"supsim;\",\n    \"10955\": \"subsetneqq;\",\n    \"10956\": \"supsetneqq;\",\n    \"10959\": \"csub;\",\n    \"10960\": \"csup;\",\n    \"10961\": \"csube;\",\n    \"10962\": \"csupe;\",\n    \"10963\": \"subsup;\",\n    \"10964\": \"supsub;\",\n    \"10965\": \"subsub;\",\n    \"10966\": \"supsup;\",\n    \"10967\": \"suphsub;\",\n    \"10968\": \"supdsub;\",\n    \"10969\": \"forkv;\",\n    \"10970\": \"topfork;\",\n    \"10971\": \"mlcp;\",\n    \"10980\": \"DoubleLeftTee;\",\n    \"10982\": \"Vdashl;\",\n    \"10983\": \"Barv;\",\n    \"10984\": \"vBar;\",\n    \"10985\": \"vBarv;\",\n    \"10987\": \"Vbar;\",\n    \"10988\": \"Not;\",\n    \"10989\": \"bNot;\",\n    \"10990\": \"rnmid;\",\n    \"10991\": \"cirmid;\",\n    \"10992\": \"midcir;\",\n    \"10993\": \"topcir;\",\n    \"10994\": \"nhpar;\",\n    \"10995\": \"parsim;\",\n    \"11005\": \"parsl;\",\n    \"64256\": \"fflig;\",\n    \"64257\": \"filig;\",\n    \"64258\": \"fllig;\",\n    \"64259\": \"ffilig;\",\n    \"64260\": \"ffllig;\"\n}\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n},{}],10:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],11:[function(require,module,exports){\n/**\n * This file automatically generated from `pre-publish.js`.\n * Do not manually edit.\n */\n\nmodule.exports = {\n  \"area\": true,\n  \"base\": true,\n  \"br\": true,\n  \"col\": true,\n  \"embed\": true,\n  \"hr\": true,\n  \"img\": true,\n  \"input\": true,\n  \"keygen\": true,\n  \"link\": true,\n  \"menuitem\": true,\n  \"meta\": true,\n  \"param\": true,\n  \"source\": true,\n  \"track\": true,\n  \"wbr\": true\n};\n\n},{}]},{},[4]);\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/static/debug.js":"// Override the Karma setup for local debugging\nwindow.__karma__.info = function (info) {\n  if (info.dump && window.console) window.console.log(info.dump)\n}\nwindow.__karma__.complete = function () {\n  if (window.console) window.console.log('Skipped ' + this.skipped + ' tests')\n}\nwindow.__karma__.skipped = 0\nwindow.__karma__.result = window.console ? function (result) {\n  if (result.skipped) {\n    this.skipped++\n    return\n  }\n  var msg = result.success ? 'SUCCESS ' : 'FAILED '\n  window.console.log(msg + result.suite.join(' ') + ' ' + result.description)\n\n  for (var i = 0; i < result.log.length; i++) {\n    // Throwing error without losing stack trace\n    (function (err) {\n      setTimeout(function () {\n        throw err\n      })\n    })(result.log[i])\n  }\n} : function () {}\nwindow.__karma__.loaded = function () {\n  this.start()\n}\n","/home/travis/build/npmtest/node-npmtest-karma/node_modules/karma/wallaby.js":"const babel = require('babel-core')\n\nmodule.exports = function (wallaby) {\n  return {\n    files: [\n      {\n        pattern: 'package.json',\n        instrument: false\n      },\n      {\n        pattern: 'config.tpl.js',\n        instrument: false\n      },\n      {\n        pattern: 'test/unit/certificates/server.key',\n        instrument: false\n      },\n      {\n        pattern: 'test/unit/certificates/server.crt',\n        instrument: false\n      },\n      {\n        pattern: 'test/unit/**/*.spec.js',\n        ignore: true\n      },\n      'lib/**/*.js',\n      'test/unit/**/*.js',\n      'test/unit/mocha-globals.js'\n    ],\n\n    tests: [\n      'test/unit/**/*.spec.js'\n    ],\n\n    compilers: {\n      '**/*.js': wallaby.compilers.babel({\n        babel: babel\n      })\n    },\n\n    bootstrap: function (w) {\n      var path = require('path')\n      var mocha = w.testFramework\n\n      mocha.suite.on('pre-require', function () {\n        // always passing wallaby.js globals to mocks.loadFile\n        var mocks = require('mocks')\n        var loadFile = mocks.loadFile\n        mocks.loadFile = function (filePath, mocks, globals, mockNested) {\n          mocks = mocks || {}\n          globals = globals || {}\n          globals.$_$wp = global.$_$wp || {}\n          globals.$_$wpe = global.$_$wpe || {}\n          globals.$_$w = global.$_$w || {}\n          globals.$_$wf = global.$_$wf || {}\n          globals.$_$tracer = global.$_$tracer || {}\n          return loadFile(filePath, mocks, globals, mockNested)\n        }\n\n        // loading mocha-globals for each run\n        require(path.join(process.cwd(), 'test/unit/mocha-globals'))\n      })\n    },\n\n    env: {\n      type: 'node',\n      params: {\n        runner: '--harmony --harmony_arrow_functions'\n      }\n    }\n  }\n}\n"}